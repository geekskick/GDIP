ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"tasks.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.global	pxCurrentTCB
  19              		.bss
  20              		.align	2
  21              		.type	pxCurrentTCB, %object
  22              		.size	pxCurrentTCB, 4
  23              	pxCurrentTCB:
  24 0000 00000000 		.space	4
  25              		.align	2
  26              	pxReadyTasksLists:
  27 0004 00000000 		.space	100
  27      00000000 
  27      00000000 
  27      00000000 
  27      00000000 
  28              		.align	2
  29              	xDelayedTaskList1:
  30 0068 00000000 		.space	20
  30      00000000 
  30      00000000 
  30      00000000 
  30      00000000 
  31              		.align	2
  32              	xDelayedTaskList2:
  33 007c 00000000 		.space	20
  33      00000000 
  33      00000000 
  33      00000000 
  33      00000000 
  34              		.align	2
  35              	pxDelayedTaskList:
  36 0090 00000000 		.space	4
  37              		.align	2
  38              	pxOverflowDelayedTaskList:
  39 0094 00000000 		.space	4
  40              		.align	2
  41              	xPendingReadyList:
  42 0098 00000000 		.space	20
  42      00000000 
  42      00000000 
  42      00000000 
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 2


  42      00000000 
  43              		.align	2
  44              	xTasksWaitingTermination:
  45 00ac 00000000 		.space	20
  45      00000000 
  45      00000000 
  45      00000000 
  45      00000000 
  46              		.align	2
  47              	uxDeletedTasksWaitingCleanUp:
  48 00c0 00000000 		.space	4
  49              		.align	2
  50              	xSuspendedTaskList:
  51 00c4 00000000 		.space	20
  51      00000000 
  51      00000000 
  51      00000000 
  51      00000000 
  52              		.align	2
  53              	uxCurrentNumberOfTasks:
  54 00d8 00000000 		.space	4
  55              		.align	2
  56              	xTickCount:
  57 00dc 00000000 		.space	4
  58              		.align	2
  59              	uxTopReadyPriority:
  60 00e0 00000000 		.space	4
  61              		.align	2
  62              	xSchedulerRunning:
  63 00e4 00000000 		.space	4
  64              		.align	2
  65              	uxPendedTicks:
  66 00e8 00000000 		.space	4
  67              		.align	2
  68              	xYieldPending:
  69 00ec 00000000 		.space	4
  70              		.align	2
  71              	xNumOfOverflows:
  72 00f0 00000000 		.space	4
  73              		.align	2
  74              	uxTaskNumber:
  75 00f4 00000000 		.space	4
  76              		.align	2
  77              	xNextTaskUnblockTime:
  78 00f8 00000000 		.space	4
  79              		.align	2
  80              	xIdleTaskHandle:
  81 00fc 00000000 		.space	4
  82              		.align	2
  83              	uxSchedulerSuspended:
  84 0100 00000000 		.space	4
  85              		.section	.text.xTaskCreate,"ax",%progbits
  86              		.align	2
  87              		.global	xTaskCreate
  88              		.thumb
  89              		.thumb_func
  90              		.type	xTaskCreate, %function
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 3


  91              	xTaskCreate:
  92              	.LFB68:
  93              		.file 1 "..\\..\\..\\Source\\tasks.c"
   1:..\..\..\Source/tasks.c **** /*
   2:..\..\..\Source/tasks.c ****     FreeRTOS V9.0.0rc2 - Copyright (C) 2016 Real Time Engineers Ltd.
   3:..\..\..\Source/tasks.c ****     All rights reserved
   4:..\..\..\Source/tasks.c **** 
   5:..\..\..\Source/tasks.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:..\..\..\Source/tasks.c **** 
   7:..\..\..\Source/tasks.c ****     This file is part of the FreeRTOS distribution.
   8:..\..\..\Source/tasks.c **** 
   9:..\..\..\Source/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  10:..\..\..\Source/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  11:..\..\..\Source/tasks.c ****     Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
  12:..\..\..\Source/tasks.c **** 
  13:..\..\..\Source/tasks.c ****     ***************************************************************************
  14:..\..\..\Source/tasks.c ****     >>!   NOTE: The modification to the GPL is included to allow you to     !<<
  15:..\..\..\Source/tasks.c ****     >>!   distribute a combined work that includes FreeRTOS without being   !<<
  16:..\..\..\Source/tasks.c ****     >>!   obliged to provide the source code for proprietary components     !<<
  17:..\..\..\Source/tasks.c ****     >>!   outside of the FreeRTOS kernel.                                   !<<
  18:..\..\..\Source/tasks.c ****     ***************************************************************************
  19:..\..\..\Source/tasks.c **** 
  20:..\..\..\Source/tasks.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  21:..\..\..\Source/tasks.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  22:..\..\..\Source/tasks.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available on the following
  23:..\..\..\Source/tasks.c ****     link: http://www.freertos.org/a00114.html
  24:..\..\..\Source/tasks.c **** 
  25:..\..\..\Source/tasks.c ****     ***************************************************************************
  26:..\..\..\Source/tasks.c ****      *                                                                       *
  27:..\..\..\Source/tasks.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  28:..\..\..\Source/tasks.c ****      *    robust, strictly quality controlled, supported, and cross          *
  29:..\..\..\Source/tasks.c ****      *    platform software that is more than just the market leader, it     *
  30:..\..\..\Source/tasks.c ****      *    is the industry's de facto standard.                               *
  31:..\..\..\Source/tasks.c ****      *                                                                       *
  32:..\..\..\Source/tasks.c ****      *    Help yourself get started quickly while simultaneously helping     *
  33:..\..\..\Source/tasks.c ****      *    to support the FreeRTOS project by purchasing a FreeRTOS           *
  34:..\..\..\Source/tasks.c ****      *    tutorial book, reference manual, or both:                          *
  35:..\..\..\Source/tasks.c ****      *    http://www.FreeRTOS.org/Documentation                              *
  36:..\..\..\Source/tasks.c ****      *                                                                       *
  37:..\..\..\Source/tasks.c ****     ***************************************************************************
  38:..\..\..\Source/tasks.c **** 
  39:..\..\..\Source/tasks.c ****     http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
  40:..\..\..\Source/tasks.c ****     the FAQ page "My application does not run, what could be wrong?".  Have you
  41:..\..\..\Source/tasks.c ****     defined configASSERT()?
  42:..\..\..\Source/tasks.c **** 
  43:..\..\..\Source/tasks.c ****     http://www.FreeRTOS.org/support - In return for receiving this top quality
  44:..\..\..\Source/tasks.c ****     embedded software for free we request you assist our global community by
  45:..\..\..\Source/tasks.c ****     participating in the support forum.
  46:..\..\..\Source/tasks.c **** 
  47:..\..\..\Source/tasks.c ****     http://www.FreeRTOS.org/training - Investing in training allows your team to
  48:..\..\..\Source/tasks.c ****     be as productive as possible as early as possible.  Now you can receive
  49:..\..\..\Source/tasks.c ****     FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
  50:..\..\..\Source/tasks.c ****     Ltd, and the world's leading authority on the world's leading RTOS.
  51:..\..\..\Source/tasks.c **** 
  52:..\..\..\Source/tasks.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  53:..\..\..\Source/tasks.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  54:..\..\..\Source/tasks.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 4


  55:..\..\..\Source/tasks.c **** 
  56:..\..\..\Source/tasks.c ****     http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
  57:..\..\..\Source/tasks.c ****     Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
  58:..\..\..\Source/tasks.c **** 
  59:..\..\..\Source/tasks.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
  60:..\..\..\Source/tasks.c ****     Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
  61:..\..\..\Source/tasks.c ****     licenses offer ticketed support, indemnification and commercial middleware.
  62:..\..\..\Source/tasks.c **** 
  63:..\..\..\Source/tasks.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  64:..\..\..\Source/tasks.c ****     engineered and independently SIL3 certified version for use in safety and
  65:..\..\..\Source/tasks.c ****     mission critical applications that require provable dependability.
  66:..\..\..\Source/tasks.c **** 
  67:..\..\..\Source/tasks.c ****     1 tab == 4 spaces!
  68:..\..\..\Source/tasks.c **** */
  69:..\..\..\Source/tasks.c **** 
  70:..\..\..\Source/tasks.c **** /* Standard includes. */
  71:..\..\..\Source/tasks.c **** #include <stdlib.h>
  72:..\..\..\Source/tasks.c **** #include <string.h>
  73:..\..\..\Source/tasks.c **** 
  74:..\..\..\Source/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  75:..\..\..\Source/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  76:..\..\..\Source/tasks.c **** task.h is included from an application file. */
  77:..\..\..\Source/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  78:..\..\..\Source/tasks.c **** 
  79:..\..\..\Source/tasks.c **** /* FreeRTOS includes. */
  80:..\..\..\Source/tasks.c **** #include "FreeRTOS.h"
  81:..\..\..\Source/tasks.c **** #include "task.h"
  82:..\..\..\Source/tasks.c **** #include "timers.h"
  83:..\..\..\Source/tasks.c **** #include "StackMacros.h"
  84:..\..\..\Source/tasks.c **** 
  85:..\..\..\Source/tasks.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
  86:..\..\..\Source/tasks.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
  87:..\..\..\Source/tasks.c **** header files above, but not in this file, in order to generate the correct
  88:..\..\..\Source/tasks.c **** privileged Vs unprivileged linkage and placement. */
  89:..\..\..\Source/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  90:..\..\..\Source/tasks.c **** 
  91:..\..\..\Source/tasks.c **** /* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
  92:..\..\..\Source/tasks.c **** functions but without including stdio.h here. */
  93:..\..\..\Source/tasks.c **** #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
  94:..\..\..\Source/tasks.c **** 	/* At the bottom of this file are two optional functions that can be used
  95:..\..\..\Source/tasks.c **** 	to generate human readable text from the raw data generated by the
  96:..\..\..\Source/tasks.c **** 	uxTaskGetSystemState() function.  Note the formatting functions are provided
  97:..\..\..\Source/tasks.c **** 	for convenience only, and are NOT considered part of the kernel. */
  98:..\..\..\Source/tasks.c **** 	#include <stdio.h>
  99:..\..\..\Source/tasks.c **** #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
 100:..\..\..\Source/tasks.c **** 
 101:..\..\..\Source/tasks.c **** #if( configUSE_PREEMPTION == 0 )
 102:..\..\..\Source/tasks.c **** 	/* If the cooperative scheduler is being used then a yield should not be
 103:..\..\..\Source/tasks.c **** 	performed just because a higher priority task has been woken. */
 104:..\..\..\Source/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION()
 105:..\..\..\Source/tasks.c **** #else
 106:..\..\..\Source/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
 107:..\..\..\Source/tasks.c **** #endif
 108:..\..\..\Source/tasks.c **** 
 109:..\..\..\Source/tasks.c **** /* Values that can be assigned to the ucNotifyState member of the TCB. */
 110:..\..\..\Source/tasks.c **** #define taskNOT_WAITING_NOTIFICATION	( ( uint8_t ) 0 )
 111:..\..\..\Source/tasks.c **** #define taskWAITING_NOTIFICATION		( ( uint8_t ) 1 )
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 5


 112:..\..\..\Source/tasks.c **** #define taskNOTIFICATION_RECEIVED		( ( uint8_t ) 2 )
 113:..\..\..\Source/tasks.c **** 
 114:..\..\..\Source/tasks.c **** /*
 115:..\..\..\Source/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 116:..\..\..\Source/tasks.c ****  * is used purely for checking the high water mark for tasks.
 117:..\..\..\Source/tasks.c ****  */
 118:..\..\..\Source/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
 119:..\..\..\Source/tasks.c **** 
 120:..\..\..\Source/tasks.c **** /*
 121:..\..\..\Source/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 122:..\..\..\Source/tasks.c ****  */
 123:..\..\..\Source/tasks.c **** #define tskBLOCKED_CHAR		( 'B' )
 124:..\..\..\Source/tasks.c **** #define tskREADY_CHAR		( 'R' )
 125:..\..\..\Source/tasks.c **** #define tskDELETED_CHAR		( 'D' )
 126:..\..\..\Source/tasks.c **** #define tskSUSPENDED_CHAR	( 'S' )
 127:..\..\..\Source/tasks.c **** 
 128:..\..\..\Source/tasks.c **** /*
 129:..\..\..\Source/tasks.c ****  * Some kernel aware debuggers require the data the debugger needs access to be
 130:..\..\..\Source/tasks.c ****  * global, rather than file scope.
 131:..\..\..\Source/tasks.c ****  */
 132:..\..\..\Source/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 133:..\..\..\Source/tasks.c **** 	#define static
 134:..\..\..\Source/tasks.c **** #endif
 135:..\..\..\Source/tasks.c **** 
 136:..\..\..\Source/tasks.c **** #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
 137:..\..\..\Source/tasks.c **** 
 138:..\..\..\Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
 139:..\..\..\Source/tasks.c **** 	performed in a generic way that is not optimised to any particular
 140:..\..\..\Source/tasks.c **** 	microcontroller architecture. */
 141:..\..\..\Source/tasks.c **** 
 142:..\..\..\Source/tasks.c **** 	/* uxTopReadyPriority holds the priority of the highest priority ready
 143:..\..\..\Source/tasks.c **** 	state task. */
 144:..\..\..\Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )														\
 145:..\..\..\Source/tasks.c **** 	{																									\
 146:..\..\..\Source/tasks.c **** 		if( ( uxPriority ) > uxTopReadyPriority )														\
 147:..\..\..\Source/tasks.c **** 		{																								\
 148:..\..\..\Source/tasks.c **** 			uxTopReadyPriority = ( uxPriority );														\
 149:..\..\..\Source/tasks.c **** 		}																								\
 150:..\..\..\Source/tasks.c **** 	} /* taskRECORD_READY_PRIORITY */
 151:..\..\..\Source/tasks.c **** 
 152:..\..\..\Source/tasks.c **** 	/*-----------------------------------------------------------*/
 153:..\..\..\Source/tasks.c **** 
 154:..\..\..\Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
 155:..\..\..\Source/tasks.c **** 	{																									\
 156:..\..\..\Source/tasks.c **** 	UBaseType_t uxTopPriority = uxTopReadyPriority;														\
 157:..\..\..\Source/tasks.c **** 																										\
 158:..\..\..\Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */								\
 159:..\..\..\Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) )							\
 160:..\..\..\Source/tasks.c **** 		{																								\
 161:..\..\..\Source/tasks.c **** 			configASSERT( uxTopPriority );																\
 162:..\..\..\Source/tasks.c **** 			--uxTopPriority;																			\
 163:..\..\..\Source/tasks.c **** 		}																								\
 164:..\..\..\Source/tasks.c **** 																										\
 165:..\..\..\Source/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
 166:..\..\..\Source/tasks.c **** 		the	same priority get an equal share of the processor time. */									\
 167:..\..\..\Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );			\
 168:..\..\..\Source/tasks.c **** 		uxTopReadyPriority = uxTopPriority;																\
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 6


 169:..\..\..\Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
 170:..\..\..\Source/tasks.c **** 
 171:..\..\..\Source/tasks.c **** 	/*-----------------------------------------------------------*/
 172:..\..\..\Source/tasks.c **** 
 173:..\..\..\Source/tasks.c **** 	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
 174:..\..\..\Source/tasks.c **** 	they are only required when a port optimised method of task selection is
 175:..\..\..\Source/tasks.c **** 	being used. */
 176:..\..\..\Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )
 177:..\..\..\Source/tasks.c **** 	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
 178:..\..\..\Source/tasks.c **** 
 179:..\..\..\Source/tasks.c **** #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 180:..\..\..\Source/tasks.c **** 
 181:..\..\..\Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 182:..\..\..\Source/tasks.c **** 	performed in a way that is tailored to the particular microcontroller
 183:..\..\..\Source/tasks.c **** 	architecture being used. */
 184:..\..\..\Source/tasks.c **** 
 185:..\..\..\Source/tasks.c **** 	/* A port optimised version is provided.  Call the port defined macros. */
 186:..\..\..\Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyP
 187:..\..\..\Source/tasks.c **** 
 188:..\..\..\Source/tasks.c **** 	/*-----------------------------------------------------------*/
 189:..\..\..\Source/tasks.c **** 
 190:..\..\..\Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
 191:..\..\..\Source/tasks.c **** 	{																								\
 192:..\..\..\Source/tasks.c **** 	UBaseType_t uxTopPriority;																		\
 193:..\..\..\Source/tasks.c **** 																									\
 194:..\..\..\Source/tasks.c **** 		/* Find the highest priority list that contains ready tasks. */								\
 195:..\..\..\Source/tasks.c **** 		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
 196:..\..\..\Source/tasks.c **** 		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
 197:..\..\..\Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
 198:..\..\..\Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
 199:..\..\..\Source/tasks.c **** 
 200:..\..\..\Source/tasks.c **** 	/*-----------------------------------------------------------*/
 201:..\..\..\Source/tasks.c **** 
 202:..\..\..\Source/tasks.c **** 	/* A port optimised version is provided, call it only if the TCB being reset
 203:..\..\..\Source/tasks.c **** 	is being referenced from a ready list.  If it is referenced from a delayed
 204:..\..\..\Source/tasks.c **** 	or suspended list then it won't be in a ready list. */
 205:..\..\..\Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )														\
 206:..\..\..\Source/tasks.c **** 	{																									\
 207:..\..\..\Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
 208:..\..\..\Source/tasks.c **** 		{																								\
 209:..\..\..\Source/tasks.c **** 			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
 210:..\..\..\Source/tasks.c **** 		}																								\
 211:..\..\..\Source/tasks.c **** 	}
 212:..\..\..\Source/tasks.c **** 
 213:..\..\..\Source/tasks.c **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 214:..\..\..\Source/tasks.c **** 
 215:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
 216:..\..\..\Source/tasks.c **** 
 217:..\..\..\Source/tasks.c **** /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
 218:..\..\..\Source/tasks.c **** count overflows. */
 219:..\..\..\Source/tasks.c **** #define taskSWITCH_DELAYED_LISTS()																	\
 220:..\..\..\Source/tasks.c **** {																									\
 221:..\..\..\Source/tasks.c **** 	List_t *pxTemp;																					\
 222:..\..\..\Source/tasks.c **** 																									\
 223:..\..\..\Source/tasks.c **** 	/* The delayed tasks list should be empty when the lists are switched. */						\
 224:..\..\..\Source/tasks.c **** 	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
 225:..\..\..\Source/tasks.c **** 																									\
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 7


 226:..\..\..\Source/tasks.c **** 	pxTemp = pxDelayedTaskList;																		\
 227:..\..\..\Source/tasks.c **** 	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
 228:..\..\..\Source/tasks.c **** 	pxOverflowDelayedTaskList = pxTemp;																\
 229:..\..\..\Source/tasks.c **** 	xNumOfOverflows++;																				\
 230:..\..\..\Source/tasks.c **** 	prvResetNextTaskUnblockTime();																	\
 231:..\..\..\Source/tasks.c **** }
 232:..\..\..\Source/tasks.c **** 
 233:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
 234:..\..\..\Source/tasks.c **** 
 235:..\..\..\Source/tasks.c **** /*
 236:..\..\..\Source/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready list for
 237:..\..\..\Source/tasks.c ****  * the task.  It is inserted at the end of the list.
 238:..\..\..\Source/tasks.c ****  */
 239:..\..\..\Source/tasks.c **** #define prvAddTaskToReadyList( pxTCB )																\
 240:..\..\..\Source/tasks.c **** 	traceMOVED_TASK_TO_READY_STATE( pxTCB );														\
 241:..\..\..\Source/tasks.c **** 	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
 242:..\..\..\Source/tasks.c **** 	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) );
 243:..\..\..\Source/tasks.c **** 	tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
 244:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
 245:..\..\..\Source/tasks.c **** 
 246:..\..\..\Source/tasks.c **** /*
 247:..\..\..\Source/tasks.c ****  * Several functions take an TaskHandle_t parameter that can optionally be NULL,
 248:..\..\..\Source/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 249:..\..\..\Source/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 250:..\..\..\Source/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 251:..\..\..\Source/tasks.c ****  */
 252:..\..\..\Source/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( TCB_t * ) pxCurrentTCB : ( T
 253:..\..\..\Source/tasks.c **** 
 254:..\..\..\Source/tasks.c **** /* The item value of the event list item is normally used to hold the priority
 255:..\..\..\Source/tasks.c **** of the task to which it belongs (coded to allow it to be held in reverse
 256:..\..\..\Source/tasks.c **** priority order).  However, it is occasionally borrowed for other purposes.  It
 257:..\..\..\Source/tasks.c **** is important its value is not updated due to a task priority change while it is
 258:..\..\..\Source/tasks.c **** being used for another purpose.  The following bit definition is used to inform
 259:..\..\..\Source/tasks.c **** the scheduler that the value should not be changed - in which case it is the
 260:..\..\..\Source/tasks.c **** responsibility of whichever module is using the value to ensure it gets set back
 261:..\..\..\Source/tasks.c **** to its original value when it is released. */
 262:..\..\..\Source/tasks.c **** #if( configUSE_16_BIT_TICKS == 1 )
 263:..\..\..\Source/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
 264:..\..\..\Source/tasks.c **** #else
 265:..\..\..\Source/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
 266:..\..\..\Source/tasks.c **** #endif
 267:..\..\..\Source/tasks.c **** 
 268:..\..\..\Source/tasks.c **** /*
 269:..\..\..\Source/tasks.c ****  * Task control block.  A task control block (TCB) is allocated for each task,
 270:..\..\..\Source/tasks.c ****  * and stores task state information, including a pointer to the task's context
 271:..\..\..\Source/tasks.c ****  * (the task's run time environment, including register values)
 272:..\..\..\Source/tasks.c ****  */
 273:..\..\..\Source/tasks.c **** typedef struct tskTaskControlBlock
 274:..\..\..\Source/tasks.c **** {
 275:..\..\..\Source/tasks.c **** 	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the task
 276:..\..\..\Source/tasks.c **** 
 277:..\..\..\Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 278:..\..\..\Source/tasks.c **** 		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MU
 279:..\..\..\Source/tasks.c **** 	#endif
 280:..\..\..\Source/tasks.c **** 
 281:..\..\..\Source/tasks.c **** 	ListItem_t			xStateListItem;	/*< The list that the state list item of a task is reference from den
 282:..\..\..\Source/tasks.c **** 	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 8


 283:..\..\..\Source/tasks.c **** 	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
 284:..\..\..\Source/tasks.c **** 	StackType_t			*pxStack;			/*< Points to the start of the stack. */
 285:..\..\..\Source/tasks.c **** 	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.
 286:..\..\..\Source/tasks.c **** 
 287:..\..\..\Source/tasks.c **** 	#if ( portSTACK_GROWTH > 0 )
 288:..\..\..\Source/tasks.c **** 		StackType_t		*pxEndOfStack;		/*< Points to the end of the stack on architectures where the stack 
 289:..\..\..\Source/tasks.c **** 	#endif
 290:..\..\..\Source/tasks.c **** 
 291:..\..\..\Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 292:..\..\..\Source/tasks.c **** 		UBaseType_t		uxCriticalNesting;	/*< Holds the critical section nesting depth for ports that do no
 293:..\..\..\Source/tasks.c **** 	#endif
 294:..\..\..\Source/tasks.c **** 
 295:..\..\..\Source/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 296:..\..\..\Source/tasks.c **** 		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It al
 297:..\..\..\Source/tasks.c **** 		UBaseType_t		uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. *
 298:..\..\..\Source/tasks.c **** 	#endif
 299:..\..\..\Source/tasks.c **** 
 300:..\..\..\Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 301:..\..\..\Source/tasks.c **** 		UBaseType_t		uxBasePriority;		/*< The priority last assigned to the task - used by the priority i
 302:..\..\..\Source/tasks.c **** 		UBaseType_t		uxMutexesHeld;
 303:..\..\..\Source/tasks.c **** 	#endif
 304:..\..\..\Source/tasks.c **** 
 305:..\..\..\Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 306:..\..\..\Source/tasks.c **** 		TaskHookFunction_t pxTaskTag;
 307:..\..\..\Source/tasks.c **** 	#endif
 308:..\..\..\Source/tasks.c **** 
 309:..\..\..\Source/tasks.c **** 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
 310:..\..\..\Source/tasks.c **** 		void *pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
 311:..\..\..\Source/tasks.c **** 	#endif
 312:..\..\..\Source/tasks.c **** 
 313:..\..\..\Source/tasks.c **** 	#if( configGENERATE_RUN_TIME_STATS == 1 )
 314:..\..\..\Source/tasks.c **** 		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state
 315:..\..\..\Source/tasks.c **** 	#endif
 316:..\..\..\Source/tasks.c **** 
 317:..\..\..\Source/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
 318:..\..\..\Source/tasks.c **** 		/* Allocate a Newlib reent structure that is specific to this task.
 319:..\..\..\Source/tasks.c **** 		Note Newlib support has been included by popular demand, but is not
 320:..\..\..\Source/tasks.c **** 		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
 321:..\..\..\Source/tasks.c **** 		responsible for resulting newlib operation.  User must be familiar with
 322:..\..\..\Source/tasks.c **** 		newlib and must provide system-wide implementations of the necessary
 323:..\..\..\Source/tasks.c **** 		stubs. Be warned that (at the time of writing) the current newlib design
 324:..\..\..\Source/tasks.c **** 		implements a system-wide malloc() that must be provided with locks. */
 325:..\..\..\Source/tasks.c **** 		struct	_reent xNewLib_reent;
 326:..\..\..\Source/tasks.c **** 	#endif
 327:..\..\..\Source/tasks.c **** 
 328:..\..\..\Source/tasks.c **** 	#if( configUSE_TASK_NOTIFICATIONS == 1 )
 329:..\..\..\Source/tasks.c **** 		volatile uint32_t ulNotifiedValue;
 330:..\..\..\Source/tasks.c **** 		volatile uint8_t ucNotifyState;
 331:..\..\..\Source/tasks.c **** 	#endif
 332:..\..\..\Source/tasks.c **** 
 333:..\..\..\Source/tasks.c **** 	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 334:..\..\..\Source/tasks.c **** 		uint8_t	ucStaticallyAllocated; /* Set to pdTRUE if the task is a statically allocated to ensure n
 335:..\..\..\Source/tasks.c **** 	#endif
 336:..\..\..\Source/tasks.c **** 
 337:..\..\..\Source/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
 338:..\..\..\Source/tasks.c **** 		uint8_t ucDelayAborted;
 339:..\..\..\Source/tasks.c **** 	#endif
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 9


 340:..\..\..\Source/tasks.c **** 
 341:..\..\..\Source/tasks.c **** } tskTCB;
 342:..\..\..\Source/tasks.c **** 
 343:..\..\..\Source/tasks.c **** /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
 344:..\..\..\Source/tasks.c **** below to enable the use of older kernel aware debuggers. */
 345:..\..\..\Source/tasks.c **** typedef tskTCB TCB_t;
 346:..\..\..\Source/tasks.c **** 
 347:..\..\..\Source/tasks.c **** /*lint -e956 A manual analysis and inspection has been used to determine which
 348:..\..\..\Source/tasks.c **** static variables must be declared volatile. */
 349:..\..\..\Source/tasks.c **** 
 350:..\..\..\Source/tasks.c **** PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
 351:..\..\..\Source/tasks.c **** 
 352:..\..\..\Source/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 353:..\..\..\Source/tasks.c **** PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks
 354:..\..\..\Source/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
 355:..\..\..\Source/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one f
 356:..\..\..\Source/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list 
 357:..\..\..\Source/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task
 358:..\..\..\Source/tasks.c **** PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the sc
 359:..\..\..\Source/tasks.c **** 
 360:..\..\..\Source/tasks.c **** #if( INCLUDE_vTaskDelete == 1 )
 361:..\..\..\Source/tasks.c **** 
 362:..\..\..\Source/tasks.c **** 	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but 
 363:..\..\..\Source/tasks.c **** 	PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
 364:..\..\..\Source/tasks.c **** 
 365:..\..\..\Source/tasks.c **** #endif
 366:..\..\..\Source/tasks.c **** 
 367:..\..\..\Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 368:..\..\..\Source/tasks.c **** 
 369:..\..\..\Source/tasks.c **** 	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 370:..\..\..\Source/tasks.c **** 
 371:..\..\..\Source/tasks.c **** #endif
 372:..\..\..\Source/tasks.c **** 
 373:..\..\..\Source/tasks.c **** /* Other file private variables. --------------------------------*/
 374:..\..\..\Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
 375:..\..\..\Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) 0U;
 376:..\..\..\Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
 377:..\..\..\Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
 378:..\..\..\Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
 379:..\..\..\Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
 380:..\..\..\Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
 381:..\..\..\Source/tasks.c **** PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
 382:..\..\..\Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= ( TickType_t ) 0U; /* Initialise
 383:..\..\..\Source/tasks.c **** PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle					= NULL;			/*< Holds the handle of the idle 
 384:..\..\..\Source/tasks.c **** 
 385:..\..\..\Source/tasks.c **** /* Context switches are held pending while the scheduler is suspended.  Also,
 386:..\..\..\Source/tasks.c **** interrupts must not manipulate the xStateListItem of a TCB, or any of the
 387:..\..\..\Source/tasks.c **** lists the xStateListItem can be referenced from, if the scheduler is suspended.
 388:..\..\..\Source/tasks.c **** If an interrupt needs to unblock a task while the scheduler is suspended then it
 389:..\..\..\Source/tasks.c **** moves the task's event list item into the xPendingReadyList, ready for the
 390:..\..\..\Source/tasks.c **** kernel to move the task from the pending ready list into the real ready list
 391:..\..\..\Source/tasks.c **** when the scheduler is unsuspended.  The pending ready list itself can only be
 392:..\..\..\Source/tasks.c **** accessed from a critical section. */
 393:..\..\..\Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
 394:..\..\..\Source/tasks.c **** 
 395:..\..\..\Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 396:..\..\..\Source/tasks.c **** 
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 10


 397:..\..\..\Source/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter
 398:..\..\..\Source/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution tim
 399:..\..\..\Source/tasks.c **** 
 400:..\..\..\Source/tasks.c **** #endif
 401:..\..\..\Source/tasks.c **** 
 402:..\..\..\Source/tasks.c **** /*lint +e956 */
 403:..\..\..\Source/tasks.c **** 
 404:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
 405:..\..\..\Source/tasks.c **** 
 406:..\..\..\Source/tasks.c **** /* Callback function prototypes. --------------------------*/
 407:..\..\..\Source/tasks.c **** #if(  configCHECK_FOR_STACK_OVERFLOW > 0 )
 408:..\..\..\Source/tasks.c **** 	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
 409:..\..\..\Source/tasks.c **** #endif
 410:..\..\..\Source/tasks.c **** 
 411:..\..\..\Source/tasks.c **** #if( configUSE_TICK_HOOK > 0 )
 412:..\..\..\Source/tasks.c **** 	extern void vApplicationTickHook( void );
 413:..\..\..\Source/tasks.c **** #endif
 414:..\..\..\Source/tasks.c **** 
 415:..\..\..\Source/tasks.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 416:..\..\..\Source/tasks.c **** 	extern void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxI
 417:..\..\..\Source/tasks.c **** #endif
 418:..\..\..\Source/tasks.c **** 
 419:..\..\..\Source/tasks.c **** /* File private functions. --------------------------------*/
 420:..\..\..\Source/tasks.c **** 
 421:..\..\..\Source/tasks.c **** /**
 422:..\..\..\Source/tasks.c ****  * Utility task that simply returns pdTRUE if the task referenced by xTask is
 423:..\..\..\Source/tasks.c ****  * currently in the Suspended state, or pdFALSE if the task referenced by xTask
 424:..\..\..\Source/tasks.c ****  * is in any other state.
 425:..\..\..\Source/tasks.c ****  */
 426:..\..\..\Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 427:..\..\..\Source/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
 428:..\..\..\Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
 429:..\..\..\Source/tasks.c **** 
 430:..\..\..\Source/tasks.c **** /*
 431:..\..\..\Source/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 432:..\..\..\Source/tasks.c ****  * automatically upon the creation of the first task.
 433:..\..\..\Source/tasks.c ****  */
 434:..\..\..\Source/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 435:..\..\..\Source/tasks.c **** 
 436:..\..\..\Source/tasks.c **** /*
 437:..\..\..\Source/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 438:..\..\..\Source/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 439:..\..\..\Source/tasks.c ****  * creation of the first user task.
 440:..\..\..\Source/tasks.c ****  *
 441:..\..\..\Source/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 442:..\..\..\Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 443:..\..\..\Source/tasks.c ****  *
 444:..\..\..\Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
 445:..\..\..\Source/tasks.c ****  *
 446:..\..\..\Source/tasks.c ****  */
 447:..\..\..\Source/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 448:..\..\..\Source/tasks.c **** 
 449:..\..\..\Source/tasks.c **** /*
 450:..\..\..\Source/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 451:..\..\..\Source/tasks.c ****  * including the stack pointed to by the TCB.
 452:..\..\..\Source/tasks.c ****  *
 453:..\..\..\Source/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 11


 454:..\..\..\Source/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 455:..\..\..\Source/tasks.c ****  */
 456:..\..\..\Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 457:..\..\..\Source/tasks.c **** 
 458:..\..\..\Source/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
 459:..\..\..\Source/tasks.c **** 
 460:..\..\..\Source/tasks.c **** #endif
 461:..\..\..\Source/tasks.c **** 
 462:..\..\..\Source/tasks.c **** /*
 463:..\..\..\Source/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 464:..\..\..\Source/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 465:..\..\..\Source/tasks.c ****  * and its TCB deleted.
 466:..\..\..\Source/tasks.c ****  */
 467:..\..\..\Source/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 468:..\..\..\Source/tasks.c **** 
 469:..\..\..\Source/tasks.c **** /*
 470:..\..\..\Source/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 471:..\..\..\Source/tasks.c ****  * either the current or the overflow delayed task list.
 472:..\..\..\Source/tasks.c ****  */
 473:..\..\..\Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockInde
 474:..\..\..\Source/tasks.c **** 
 475:..\..\..\Source/tasks.c **** /*
 476:..\..\..\Source/tasks.c ****  * Fills an TaskStatus_t structure with information on each task that is
 477:..\..\..\Source/tasks.c ****  * referenced from the pxList list (which may be a ready list, a delayed list,
 478:..\..\..\Source/tasks.c ****  * a suspended list, etc.).
 479:..\..\..\Source/tasks.c ****  *
 480:..\..\..\Source/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 481:..\..\..\Source/tasks.c ****  * NORMAL APPLICATION CODE.
 482:..\..\..\Source/tasks.c ****  */
 483:..\..\..\Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 484:..\..\..\Source/tasks.c **** 
 485:..\..\..\Source/tasks.c **** 	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, 
 486:..\..\..\Source/tasks.c **** 
 487:..\..\..\Source/tasks.c **** #endif
 488:..\..\..\Source/tasks.c **** 
 489:..\..\..\Source/tasks.c **** /*
 490:..\..\..\Source/tasks.c ****  * Searches pxList for a task with name pcNameToQuery - returning a handle to
 491:..\..\..\Source/tasks.c ****  * the task if it is found, or NULL if the task is not found.
 492:..\..\..\Source/tasks.c ****  */
 493:..\..\..\Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
 494:..\..\..\Source/tasks.c **** 
 495:..\..\..\Source/tasks.c **** 	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] ) PRIVI
 496:..\..\..\Source/tasks.c **** 
 497:..\..\..\Source/tasks.c **** #endif
 498:..\..\..\Source/tasks.c **** 
 499:..\..\..\Source/tasks.c **** /*
 500:..\..\..\Source/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 501:..\..\..\Source/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 502:..\..\..\Source/tasks.c ****  * determining how much of the stack remains at the original preset value.
 503:..\..\..\Source/tasks.c ****  */
 504:..\..\..\Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 505:..\..\..\Source/tasks.c **** 
 506:..\..\..\Source/tasks.c **** 	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;
 507:..\..\..\Source/tasks.c **** 
 508:..\..\..\Source/tasks.c **** #endif
 509:..\..\..\Source/tasks.c **** 
 510:..\..\..\Source/tasks.c **** /*
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 12


 511:..\..\..\Source/tasks.c ****  * Return the amount of time, in ticks, that will pass before the kernel will
 512:..\..\..\Source/tasks.c ****  * next move a task from the Blocked state to the Running state.
 513:..\..\..\Source/tasks.c ****  *
 514:..\..\..\Source/tasks.c ****  * This conditional compilation should use inequality to 0, not equality to 1.
 515:..\..\..\Source/tasks.c ****  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 516:..\..\..\Source/tasks.c ****  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 517:..\..\..\Source/tasks.c ****  * set to a value other than 1.
 518:..\..\..\Source/tasks.c ****  */
 519:..\..\..\Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
 520:..\..\..\Source/tasks.c **** 
 521:..\..\..\Source/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
 522:..\..\..\Source/tasks.c **** 
 523:..\..\..\Source/tasks.c **** #endif
 524:..\..\..\Source/tasks.c **** 
 525:..\..\..\Source/tasks.c **** /*
 526:..\..\..\Source/tasks.c ****  * Set xNextTaskUnblockTime to the time at which the next Blocked state task
 527:..\..\..\Source/tasks.c ****  * will exit the Blocked state.
 528:..\..\..\Source/tasks.c ****  */
 529:..\..\..\Source/tasks.c **** static void prvResetNextTaskUnblockTime( void );
 530:..\..\..\Source/tasks.c **** 
 531:..\..\..\Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
 532:..\..\..\Source/tasks.c **** 
 533:..\..\..\Source/tasks.c **** 	/*
 534:..\..\..\Source/tasks.c **** 	 * Helper function used to pad task names with spaces when printing out
 535:..\..\..\Source/tasks.c **** 	 * human readable tables of task information.
 536:..\..\..\Source/tasks.c **** 	 */
 537:..\..\..\Source/tasks.c **** 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName ) PRIVILEGED_FUNCTION;
 538:..\..\..\Source/tasks.c **** 
 539:..\..\..\Source/tasks.c **** #endif
 540:..\..\..\Source/tasks.c **** 
 541:..\..\..\Source/tasks.c **** /*
 542:..\..\..\Source/tasks.c ****  * Called after a Task_t structure has been allocated either statically or
 543:..\..\..\Source/tasks.c ****  * dynamically to fill in the structure's members.
 544:..\..\..\Source/tasks.c ****  */
 545:..\..\..\Source/tasks.c **** static void prvInitialiseNewTask( TaskFunction_t pxTaskCode, const char * const pcName, const uint3
 546:..\..\..\Source/tasks.c **** 
 547:..\..\..\Source/tasks.c **** /*
 548:..\..\..\Source/tasks.c ****  * Called after a new task has been created and initialised to place the task
 549:..\..\..\Source/tasks.c ****  * under the control of the scheduler.
 550:..\..\..\Source/tasks.c ****  */
 551:..\..\..\Source/tasks.c **** static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB ) PRIVILEGED_FUNCTION;
 552:..\..\..\Source/tasks.c **** 
 553:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
 554:..\..\..\Source/tasks.c **** 
 555:..\..\..\Source/tasks.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 556:..\..\..\Source/tasks.c **** 
 557:..\..\..\Source/tasks.c **** 	TaskHandle_t xTaskCreateStatic( TaskFunction_t pxTaskCode, const char * const pcName, const uint32
 558:..\..\..\Source/tasks.c **** 	{
 559:..\..\..\Source/tasks.c **** 	TCB_t *pxNewTCB;
 560:..\..\..\Source/tasks.c **** 	TaskHandle_t xReturn;
 561:..\..\..\Source/tasks.c **** 
 562:..\..\..\Source/tasks.c **** 		configASSERT( puxStackBuffer != NULL );
 563:..\..\..\Source/tasks.c **** 		configASSERT( pxTaskBuffer != NULL );
 564:..\..\..\Source/tasks.c **** 
 565:..\..\..\Source/tasks.c **** 		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
 566:..\..\..\Source/tasks.c **** 		{
 567:..\..\..\Source/tasks.c **** 			/* The memory used for the task's TCB and stack are passed into this
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 13


 568:..\..\..\Source/tasks.c **** 			function - use them. */
 569:..\..\..\Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 Unusual cast is ok as the structures are desig
 570:..\..\..\Source/tasks.c **** 			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 571:..\..\..\Source/tasks.c **** 
 572:..\..\..\Source/tasks.c **** 			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 573:..\..\..\Source/tasks.c **** 			{
 574:..\..\..\Source/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 575:..\..\..\Source/tasks.c **** 				task was created statically in case the task is later deleted. */
 576:..\..\..\Source/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = pdTRUE;
 577:..\..\..\Source/tasks.c **** 			}
 578:..\..\..\Source/tasks.c **** 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 579:..\..\..\Source/tasks.c **** 
 580:..\..\..\Source/tasks.c **** 			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNe
 581:..\..\..\Source/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 582:..\..\..\Source/tasks.c **** 		}
 583:..\..\..\Source/tasks.c **** 		else
 584:..\..\..\Source/tasks.c **** 		{
 585:..\..\..\Source/tasks.c **** 			xReturn = NULL;
 586:..\..\..\Source/tasks.c **** 		}
 587:..\..\..\Source/tasks.c **** 
 588:..\..\..\Source/tasks.c **** 		return xReturn;
 589:..\..\..\Source/tasks.c **** 	}
 590:..\..\..\Source/tasks.c **** 
 591:..\..\..\Source/tasks.c **** #endif /* SUPPORT_STATIC_ALLOCATION */
 592:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
 593:..\..\..\Source/tasks.c **** 
 594:..\..\..\Source/tasks.c **** #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 595:..\..\..\Source/tasks.c **** 
 596:..\..\..\Source/tasks.c **** 	BaseType_t xTaskCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usSta
 597:..\..\..\Source/tasks.c **** 	{
  94              		.loc 1 597 0
  95              		.cfi_startproc
  96              		@ args = 8, pretend = 0, frame = 32
  97              		@ frame_needed = 1, uses_anonymous_args = 0
  98 0000 80B5     		push	{r7, lr}
  99              		.cfi_def_cfa_offset 8
 100              		.cfi_offset 7, -8
 101              		.cfi_offset 14, -4
 102 0002 8CB0     		sub	sp, sp, #48
 103              		.cfi_def_cfa_offset 56
 104 0004 04AF     		add	r7, sp, #16
 105              		.cfi_def_cfa 7, 40
 106 0006 F860     		str	r0, [r7, #12]
 107 0008 B960     		str	r1, [r7, #8]
 108 000a 3B60     		str	r3, [r7]
 109 000c 1346     		mov	r3, r2	@ movhi
 110 000e FB80     		strh	r3, [r7, #6]	@ movhi
 111              	.LBB27:
 598:..\..\..\Source/tasks.c **** 	TCB_t *pxNewTCB;
 599:..\..\..\Source/tasks.c **** 	BaseType_t xReturn;
 600:..\..\..\Source/tasks.c **** 
 601:..\..\..\Source/tasks.c **** 		/* If the stack grows down then allocate the stack then the TCB so the stack
 602:..\..\..\Source/tasks.c **** 		does not grow into the TCB.  Likewise if the stack grows up then allocate
 603:..\..\..\Source/tasks.c **** 		the TCB then the stack. */
 604:..\..\..\Source/tasks.c **** 		#if( portSTACK_GROWTH > 0 )
 605:..\..\..\Source/tasks.c **** 		{
 606:..\..\..\Source/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends on
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 14


 607:..\..\..\Source/tasks.c **** 			the implementation of the port malloc function and whether or not static
 608:..\..\..\Source/tasks.c **** 			allocation is being used. */
 609:..\..\..\Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 610:..\..\..\Source/tasks.c **** 
 611:..\..\..\Source/tasks.c **** 			if( pxNewTCB != NULL )
 612:..\..\..\Source/tasks.c **** 			{
 613:..\..\..\Source/tasks.c **** 				/* Allocate space for the stack used by the task being created.
 614:..\..\..\Source/tasks.c **** 				The base of the stack memory stored in the TCB so the task can
 615:..\..\..\Source/tasks.c **** 				be deleted later if required. */
 616:..\..\..\Source/tasks.c **** 				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( Sta
 617:..\..\..\Source/tasks.c **** 
 618:..\..\..\Source/tasks.c **** 				if( pxNewTCB->pxStack == NULL )
 619:..\..\..\Source/tasks.c **** 				{
 620:..\..\..\Source/tasks.c **** 					/* Could not allocate the stack.  Delete the allocated TCB. */
 621:..\..\..\Source/tasks.c **** 					vPortFree( pxNewTCB );
 622:..\..\..\Source/tasks.c **** 					pxNewTCB = NULL;
 623:..\..\..\Source/tasks.c **** 				}
 624:..\..\..\Source/tasks.c **** 			}
 625:..\..\..\Source/tasks.c **** 		}
 626:..\..\..\Source/tasks.c **** 		#else /* portSTACK_GROWTH */
 627:..\..\..\Source/tasks.c **** 		{
 628:..\..\..\Source/tasks.c **** 		StackType_t *pxStack;
 629:..\..\..\Source/tasks.c **** 
 630:..\..\..\Source/tasks.c **** 			/* Allocate space for the stack used by the task being created. */
 631:..\..\..\Source/tasks.c **** 			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) 
 112              		.loc 1 631 0
 113 0010 FB88     		ldrh	r3, [r7, #6]
 114 0012 9B00     		lsls	r3, r3, #2
 115 0014 1846     		mov	r0, r3
 116 0016 FFF7FEFF 		bl	pvPortMalloc
 117 001a 7861     		str	r0, [r7, #20]
 632:..\..\..\Source/tasks.c **** 
 633:..\..\..\Source/tasks.c **** 			if( pxStack != NULL )
 118              		.loc 1 633 0
 119 001c 7B69     		ldr	r3, [r7, #20]
 120 001e 002B     		cmp	r3, #0
 121 0020 0ED0     		beq	.L2
 634:..\..\..\Source/tasks.c **** 			{
 635:..\..\..\Source/tasks.c **** 				/* Allocate space for the TCB. */
 636:..\..\..\Source/tasks.c **** 				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the cas
 122              		.loc 1 636 0
 123 0022 5020     		movs	r0, #80
 124 0024 FFF7FEFF 		bl	pvPortMalloc
 125 0028 F861     		str	r0, [r7, #28]
 637:..\..\..\Source/tasks.c **** 
 638:..\..\..\Source/tasks.c **** 				if( pxNewTCB != NULL )
 126              		.loc 1 638 0
 127 002a FB69     		ldr	r3, [r7, #28]
 128 002c 002B     		cmp	r3, #0
 129 002e 03D0     		beq	.L3
 639:..\..\..\Source/tasks.c **** 				{
 640:..\..\..\Source/tasks.c **** 					/* Store the stack location in the TCB. */
 641:..\..\..\Source/tasks.c **** 					pxNewTCB->pxStack = pxStack;
 130              		.loc 1 641 0
 131 0030 FB69     		ldr	r3, [r7, #28]
 132 0032 7A69     		ldr	r2, [r7, #20]
 133 0034 1A63     		str	r2, [r3, #48]
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 15


 134 0036 05E0     		b	.L5
 135              	.L3:
 642:..\..\..\Source/tasks.c **** 				}
 643:..\..\..\Source/tasks.c **** 				else
 644:..\..\..\Source/tasks.c **** 				{
 645:..\..\..\Source/tasks.c **** 					/* The stack cannot be used as the TCB was not created.  Free
 646:..\..\..\Source/tasks.c **** 					it again. */
 647:..\..\..\Source/tasks.c **** 					vPortFree( pxStack );
 136              		.loc 1 647 0
 137 0038 7869     		ldr	r0, [r7, #20]
 138 003a FFF7FEFF 		bl	vPortFree
 139 003e 01E0     		b	.L5
 140              	.L2:
 648:..\..\..\Source/tasks.c **** 				}
 649:..\..\..\Source/tasks.c **** 			}
 650:..\..\..\Source/tasks.c **** 			else
 651:..\..\..\Source/tasks.c **** 			{
 652:..\..\..\Source/tasks.c **** 				pxNewTCB = NULL;
 141              		.loc 1 652 0
 142 0040 0023     		movs	r3, #0
 143 0042 FB61     		str	r3, [r7, #28]
 144              	.L5:
 145              	.LBE27:
 653:..\..\..\Source/tasks.c **** 			}
 654:..\..\..\Source/tasks.c **** 		}
 655:..\..\..\Source/tasks.c **** 		#endif /* portSTACK_GROWTH */
 656:..\..\..\Source/tasks.c **** 
 657:..\..\..\Source/tasks.c **** 		if( pxNewTCB != NULL )
 146              		.loc 1 657 0
 147 0044 FB69     		ldr	r3, [r7, #28]
 148 0046 002B     		cmp	r3, #0
 149 0048 11D0     		beq	.L6
 658:..\..\..\Source/tasks.c **** 		{
 659:..\..\..\Source/tasks.c **** 			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
 660:..\..\..\Source/tasks.c **** 			{
 661:..\..\..\Source/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 662:..\..\..\Source/tasks.c **** 				task was created dynamically in case it is later deleted. */
 663:..\..\..\Source/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = pdFALSE;
 664:..\..\..\Source/tasks.c **** 			}
 665:..\..\..\Source/tasks.c **** 			#endif /* configSUPPORT_STATIC_ALLOCATION */
 666:..\..\..\Source/tasks.c **** 
 667:..\..\..\Source/tasks.c **** 			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, p
 150              		.loc 1 667 0
 151 004a FA88     		ldrh	r2, [r7, #6]
 152 004c BB6A     		ldr	r3, [r7, #40]
 153 004e 0093     		str	r3, [sp]
 154 0050 FB6A     		ldr	r3, [r7, #44]
 155 0052 0193     		str	r3, [sp, #4]
 156 0054 FB69     		ldr	r3, [r7, #28]
 157 0056 0293     		str	r3, [sp, #8]
 158 0058 F868     		ldr	r0, [r7, #12]
 159 005a B968     		ldr	r1, [r7, #8]
 160 005c 3B68     		ldr	r3, [r7]
 161 005e FFF7FEFF 		bl	prvInitialiseNewTask
 668:..\..\..\Source/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 162              		.loc 1 668 0
 163 0062 F869     		ldr	r0, [r7, #28]
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 16


 164 0064 FFF7FEFF 		bl	prvAddNewTaskToReadyList
 669:..\..\..\Source/tasks.c **** 			xReturn = pdPASS;
 165              		.loc 1 669 0
 166 0068 0123     		movs	r3, #1
 167 006a BB61     		str	r3, [r7, #24]
 168 006c 02E0     		b	.L7
 169              	.L6:
 670:..\..\..\Source/tasks.c **** 		}
 671:..\..\..\Source/tasks.c **** 		else
 672:..\..\..\Source/tasks.c **** 		{
 673:..\..\..\Source/tasks.c **** 			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 170              		.loc 1 673 0
 171 006e 4FF0FF33 		mov	r3, #-1
 172 0072 BB61     		str	r3, [r7, #24]
 173              	.L7:
 674:..\..\..\Source/tasks.c **** 		}
 675:..\..\..\Source/tasks.c **** 
 676:..\..\..\Source/tasks.c **** 		return xReturn;
 174              		.loc 1 676 0
 175 0074 BB69     		ldr	r3, [r7, #24]
 677:..\..\..\Source/tasks.c **** 	}
 176              		.loc 1 677 0
 177 0076 1846     		mov	r0, r3
 178 0078 2037     		adds	r7, r7, #32
 179              		.cfi_def_cfa_offset 8
 180 007a BD46     		mov	sp, r7
 181              		.cfi_def_cfa_register 13
 182              		@ sp needed
 183 007c 80BD     		pop	{r7, pc}
 184              		.cfi_endproc
 185              	.LFE68:
 186              		.size	xTaskCreate, .-xTaskCreate
 187 007e 00BF     		.section	.text.prvInitialiseNewTask,"ax",%progbits
 188              		.align	2
 189              		.thumb
 190              		.thumb_func
 191              		.type	prvInitialiseNewTask, %function
 192              	prvInitialiseNewTask:
 193              	.LFB69:
 678:..\..\..\Source/tasks.c **** 
 679:..\..\..\Source/tasks.c **** #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 680:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
 681:..\..\..\Source/tasks.c **** 
 682:..\..\..\Source/tasks.c **** static void prvInitialiseNewTask( TaskFunction_t pxTaskCode, const char * const pcName, const uint3
 683:..\..\..\Source/tasks.c **** {
 194              		.loc 1 683 0
 195              		.cfi_startproc
 196              		@ args = 12, pretend = 0, frame = 24
 197              		@ frame_needed = 1, uses_anonymous_args = 0
 198 0000 80B5     		push	{r7, lr}
 199              		.cfi_def_cfa_offset 8
 200              		.cfi_offset 7, -8
 201              		.cfi_offset 14, -4
 202 0002 86B0     		sub	sp, sp, #24
 203              		.cfi_def_cfa_offset 32
 204 0004 00AF     		add	r7, sp, #0
 205              		.cfi_def_cfa_register 7
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 17


 206 0006 F860     		str	r0, [r7, #12]
 207 0008 B960     		str	r1, [r7, #8]
 208 000a 7A60     		str	r2, [r7, #4]
 209 000c 3B60     		str	r3, [r7]
 684:..\..\..\Source/tasks.c **** StackType_t *pxTopOfStack;
 685:..\..\..\Source/tasks.c **** UBaseType_t x;
 686:..\..\..\Source/tasks.c **** 
 687:..\..\..\Source/tasks.c **** 	#if( portUSING_MPU_WRAPPERS == 1 )
 688:..\..\..\Source/tasks.c **** 		/* Should the task be created in privileged mode? */
 689:..\..\..\Source/tasks.c **** 		BaseType_t xRunPrivileged;
 690:..\..\..\Source/tasks.c **** 		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 691:..\..\..\Source/tasks.c **** 		{
 692:..\..\..\Source/tasks.c **** 			xRunPrivileged = pdTRUE;
 693:..\..\..\Source/tasks.c **** 		}
 694:..\..\..\Source/tasks.c **** 		else
 695:..\..\..\Source/tasks.c **** 		{
 696:..\..\..\Source/tasks.c **** 			xRunPrivileged = pdFALSE;
 697:..\..\..\Source/tasks.c **** 		}
 698:..\..\..\Source/tasks.c **** 		uxPriority &= ~portPRIVILEGE_BIT;
 699:..\..\..\Source/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS == 1 */
 700:..\..\..\Source/tasks.c **** 
 701:..\..\..\Source/tasks.c **** 	/* Avoid dependency on memset() if it is not required. */
 702:..\..\..\Source/tasks.c **** 	#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTa
 703:..\..\..\Source/tasks.c **** 	{
 704:..\..\..\Source/tasks.c **** 		/* Fill the stack with a known value to assist debugging. */
 705:..\..\..\Source/tasks.c **** 		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof(
 210              		.loc 1 705 0
 211 000e BB6A     		ldr	r3, [r7, #40]
 212 0010 1A6B     		ldr	r2, [r3, #48]
 213 0012 7B68     		ldr	r3, [r7, #4]
 214 0014 9B00     		lsls	r3, r3, #2
 215 0016 1046     		mov	r0, r2
 216 0018 A521     		movs	r1, #165
 217 001a 1A46     		mov	r2, r3
 218 001c FFF7FEFF 		bl	memset
 706:..\..\..\Source/tasks.c **** 	}
 707:..\..\..\Source/tasks.c **** 	#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INC
 708:..\..\..\Source/tasks.c **** 
 709:..\..\..\Source/tasks.c **** 	/* Calculate the top of stack address.  This depends on whether the stack
 710:..\..\..\Source/tasks.c **** 	grows from high memory to low (as per the 80x86) or vice versa.
 711:..\..\..\Source/tasks.c **** 	portSTACK_GROWTH is used to make the result positive or negative as required
 712:..\..\..\Source/tasks.c **** 	by the port. */
 713:..\..\..\Source/tasks.c **** 	#if( portSTACK_GROWTH < 0 )
 714:..\..\..\Source/tasks.c **** 	{
 715:..\..\..\Source/tasks.c **** 		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 219              		.loc 1 715 0
 220 0020 BB6A     		ldr	r3, [r7, #40]
 221 0022 1A6B     		ldr	r2, [r3, #48]
 222 0024 7B68     		ldr	r3, [r7, #4]
 223 0026 03F18043 		add	r3, r3, #1073741824
 224 002a 013B     		subs	r3, r3, #1
 225 002c 9B00     		lsls	r3, r3, #2
 226 002e 1344     		add	r3, r3, r2
 227 0030 3B61     		str	r3, [r7, #16]
 716:..\..\..\Source/tasks.c **** 		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTE
 228              		.loc 1 716 0
 229 0032 3B69     		ldr	r3, [r7, #16]
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 18


 230 0034 23F00703 		bic	r3, r3, #7
 231 0038 3B61     		str	r3, [r7, #16]
 717:..\..\..\Source/tasks.c **** 
 718:..\..\..\Source/tasks.c **** 		/* Check the alignment of the calculated top of stack is correct. */
 719:..\..\..\Source/tasks.c **** 		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALI
 720:..\..\..\Source/tasks.c **** 	}
 721:..\..\..\Source/tasks.c **** 	#else /* portSTACK_GROWTH */
 722:..\..\..\Source/tasks.c **** 	{
 723:..\..\..\Source/tasks.c **** 		pxTopOfStack = pxNewTCB->pxStack;
 724:..\..\..\Source/tasks.c **** 
 725:..\..\..\Source/tasks.c **** 		/* Check the alignment of the stack buffer is correct. */
 726:..\..\..\Source/tasks.c **** 		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYT
 727:..\..\..\Source/tasks.c **** 
 728:..\..\..\Source/tasks.c **** 		/* The other extreme of the stack space is required if stack checking is
 729:..\..\..\Source/tasks.c **** 		performed. */
 730:..\..\..\Source/tasks.c **** 		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 731:..\..\..\Source/tasks.c **** 	}
 732:..\..\..\Source/tasks.c **** 	#endif /* portSTACK_GROWTH */
 733:..\..\..\Source/tasks.c **** 
 734:..\..\..\Source/tasks.c **** 	/* Store the task name in the TCB. */
 735:..\..\..\Source/tasks.c **** 	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 232              		.loc 1 735 0
 233 003a 0023     		movs	r3, #0
 234 003c 7B61     		str	r3, [r7, #20]
 235 003e 13E0     		b	.L10
 236              	.L13:
 736:..\..\..\Source/tasks.c **** 	{
 737:..\..\..\Source/tasks.c **** 		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 237              		.loc 1 737 0
 238 0040 BA68     		ldr	r2, [r7, #8]
 239 0042 7B69     		ldr	r3, [r7, #20]
 240 0044 1344     		add	r3, r3, r2
 241 0046 1978     		ldrb	r1, [r3]	@ zero_extendqisi2
 242 0048 BA6A     		ldr	r2, [r7, #40]
 243 004a 7B69     		ldr	r3, [r7, #20]
 244 004c 1344     		add	r3, r3, r2
 245 004e 3033     		adds	r3, r3, #48
 246 0050 0A46     		mov	r2, r1
 247 0052 1A71     		strb	r2, [r3, #4]
 738:..\..\..\Source/tasks.c **** 
 739:..\..\..\Source/tasks.c **** 		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
 740:..\..\..\Source/tasks.c **** 		configMAX_TASK_NAME_LEN characters just in case the memory after the
 741:..\..\..\Source/tasks.c **** 		string is not accessible (extremely unlikely). */
 742:..\..\..\Source/tasks.c **** 		if( pcName[ x ] == 0x00 )
 248              		.loc 1 742 0
 249 0054 BA68     		ldr	r2, [r7, #8]
 250 0056 7B69     		ldr	r3, [r7, #20]
 251 0058 1344     		add	r3, r3, r2
 252 005a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 253 005c 002B     		cmp	r3, #0
 254 005e 00D1     		bne	.L11
 743:..\..\..\Source/tasks.c **** 		{
 744:..\..\..\Source/tasks.c **** 			break;
 255              		.loc 1 744 0
 256 0060 05E0     		b	.L12
 257              	.L11:
 735:..\..\..\Source/tasks.c **** 	{
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 19


 258              		.loc 1 735 0 discriminator 2
 259 0062 7B69     		ldr	r3, [r7, #20]
 260 0064 0133     		adds	r3, r3, #1
 261 0066 7B61     		str	r3, [r7, #20]
 262              	.L10:
 735:..\..\..\Source/tasks.c **** 	{
 263              		.loc 1 735 0 is_stmt 0 discriminator 1
 264 0068 7B69     		ldr	r3, [r7, #20]
 265 006a 0B2B     		cmp	r3, #11
 266 006c E8D9     		bls	.L13
 267              	.L12:
 745:..\..\..\Source/tasks.c **** 		}
 746:..\..\..\Source/tasks.c **** 		else
 747:..\..\..\Source/tasks.c **** 		{
 748:..\..\..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 749:..\..\..\Source/tasks.c **** 		}
 750:..\..\..\Source/tasks.c **** 	}
 751:..\..\..\Source/tasks.c **** 
 752:..\..\..\Source/tasks.c **** 	/* Ensure the name string is terminated in the case that the string length
 753:..\..\..\Source/tasks.c **** 	was greater or equal to configMAX_TASK_NAME_LEN. */
 754:..\..\..\Source/tasks.c **** 	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 268              		.loc 1 754 0 is_stmt 1
 269 006e BB6A     		ldr	r3, [r7, #40]
 270 0070 0022     		movs	r2, #0
 271 0072 83F83F20 		strb	r2, [r3, #63]
 755:..\..\..\Source/tasks.c **** 
 756:..\..\..\Source/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
 757:..\..\..\Source/tasks.c **** 	remove the privilege bit if one is present. */
 758:..\..\..\Source/tasks.c **** 	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 272              		.loc 1 758 0
 273 0076 3B6A     		ldr	r3, [r7, #32]
 274 0078 042B     		cmp	r3, #4
 275 007a 01D9     		bls	.L14
 759:..\..\..\Source/tasks.c **** 	{
 760:..\..\..\Source/tasks.c **** 		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 276              		.loc 1 760 0
 277 007c 0423     		movs	r3, #4
 278 007e 3B62     		str	r3, [r7, #32]
 279              	.L14:
 761:..\..\..\Source/tasks.c **** 	}
 762:..\..\..\Source/tasks.c **** 	else
 763:..\..\..\Source/tasks.c **** 	{
 764:..\..\..\Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
 765:..\..\..\Source/tasks.c **** 	}
 766:..\..\..\Source/tasks.c **** 
 767:..\..\..\Source/tasks.c **** 	pxNewTCB->uxPriority = uxPriority;
 280              		.loc 1 767 0
 281 0080 BB6A     		ldr	r3, [r7, #40]
 282 0082 3A6A     		ldr	r2, [r7, #32]
 283 0084 DA62     		str	r2, [r3, #44]
 768:..\..\..\Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 769:..\..\..\Source/tasks.c **** 	{
 770:..\..\..\Source/tasks.c **** 		pxNewTCB->uxBasePriority = uxPriority;
 284              		.loc 1 770 0
 285 0086 BB6A     		ldr	r3, [r7, #40]
 286 0088 3A6A     		ldr	r2, [r7, #32]
 287 008a 1A64     		str	r2, [r3, #64]
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 20


 771:..\..\..\Source/tasks.c **** 		pxNewTCB->uxMutexesHeld = 0;
 288              		.loc 1 771 0
 289 008c BB6A     		ldr	r3, [r7, #40]
 290 008e 0022     		movs	r2, #0
 291 0090 5A64     		str	r2, [r3, #68]
 772:..\..\..\Source/tasks.c **** 	}
 773:..\..\..\Source/tasks.c **** 	#endif /* configUSE_MUTEXES */
 774:..\..\..\Source/tasks.c **** 
 775:..\..\..\Source/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 292              		.loc 1 775 0
 293 0092 BB6A     		ldr	r3, [r7, #40]
 294 0094 0433     		adds	r3, r3, #4
 295 0096 1846     		mov	r0, r3
 296 0098 FFF7FEFF 		bl	vListInitialiseItem
 776:..\..\..\Source/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 297              		.loc 1 776 0
 298 009c BB6A     		ldr	r3, [r7, #40]
 299 009e 1833     		adds	r3, r3, #24
 300 00a0 1846     		mov	r0, r3
 301 00a2 FFF7FEFF 		bl	vListInitialiseItem
 777:..\..\..\Source/tasks.c **** 
 778:..\..\..\Source/tasks.c **** 	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
 779:..\..\..\Source/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
 780:..\..\..\Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 302              		.loc 1 780 0
 303 00a6 BB6A     		ldr	r3, [r7, #40]
 304 00a8 BA6A     		ldr	r2, [r7, #40]
 305 00aa 1A61     		str	r2, [r3, #16]
 781:..\..\..\Source/tasks.c **** 
 782:..\..\..\Source/tasks.c **** 	/* Event lists are always in priority order. */
 783:..\..\..\Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( Ti
 306              		.loc 1 783 0
 307 00ac 3B6A     		ldr	r3, [r7, #32]
 308 00ae C3F10502 		rsb	r2, r3, #5
 309 00b2 BB6A     		ldr	r3, [r7, #40]
 310 00b4 9A61     		str	r2, [r3, #24]
 784:..\..\..\Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 311              		.loc 1 784 0
 312 00b6 BB6A     		ldr	r3, [r7, #40]
 313 00b8 BA6A     		ldr	r2, [r7, #40]
 314 00ba 5A62     		str	r2, [r3, #36]
 785:..\..\..\Source/tasks.c **** 
 786:..\..\..\Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 787:..\..\..\Source/tasks.c **** 	{
 788:..\..\..\Source/tasks.c **** 		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
 789:..\..\..\Source/tasks.c **** 	}
 790:..\..\..\Source/tasks.c **** 	#endif /* portCRITICAL_NESTING_IN_TCB */
 791:..\..\..\Source/tasks.c **** 
 792:..\..\..\Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 793:..\..\..\Source/tasks.c **** 	{
 794:..\..\..\Source/tasks.c **** 		pxNewTCB->pxTaskTag = NULL;
 795:..\..\..\Source/tasks.c **** 	}
 796:..\..\..\Source/tasks.c **** 	#endif /* configUSE_APPLICATION_TASK_TAG */
 797:..\..\..\Source/tasks.c **** 
 798:..\..\..\Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 799:..\..\..\Source/tasks.c **** 	{
 800:..\..\..\Source/tasks.c **** 		pxNewTCB->ulRunTimeCounter = 0UL;
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 21


 801:..\..\..\Source/tasks.c **** 	}
 802:..\..\..\Source/tasks.c **** 	#endif /* configGENERATE_RUN_TIME_STATS */
 803:..\..\..\Source/tasks.c **** 
 804:..\..\..\Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 805:..\..\..\Source/tasks.c **** 	{
 806:..\..\..\Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth
 807:..\..\..\Source/tasks.c **** 	}
 808:..\..\..\Source/tasks.c **** 	#endif
 809:..\..\..\Source/tasks.c **** 
 810:..\..\..\Source/tasks.c **** 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
 811:..\..\..\Source/tasks.c **** 	{
 812:..\..\..\Source/tasks.c **** 		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
 813:..\..\..\Source/tasks.c **** 		{
 814:..\..\..\Source/tasks.c **** 			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
 815:..\..\..\Source/tasks.c **** 		}
 816:..\..\..\Source/tasks.c **** 	}
 817:..\..\..\Source/tasks.c **** 	#endif
 818:..\..\..\Source/tasks.c **** 
 819:..\..\..\Source/tasks.c **** 	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
 820:..\..\..\Source/tasks.c **** 	{
 821:..\..\..\Source/tasks.c **** 		pxNewTCB->ulNotifiedValue = 0;
 315              		.loc 1 821 0
 316 00bc BB6A     		ldr	r3, [r7, #40]
 317 00be 0022     		movs	r2, #0
 318 00c0 9A64     		str	r2, [r3, #72]
 822:..\..\..\Source/tasks.c **** 		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 319              		.loc 1 822 0
 320 00c2 BB6A     		ldr	r3, [r7, #40]
 321 00c4 0022     		movs	r2, #0
 322 00c6 83F84C20 		strb	r2, [r3, #76]
 823:..\..\..\Source/tasks.c **** 	}
 824:..\..\..\Source/tasks.c **** 	#endif
 825:..\..\..\Source/tasks.c **** 
 826:..\..\..\Source/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
 827:..\..\..\Source/tasks.c **** 	{
 828:..\..\..\Source/tasks.c **** 		/* Initialise this task's Newlib reent structure. */
 829:..\..\..\Source/tasks.c **** 		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
 830:..\..\..\Source/tasks.c **** 	}
 831:..\..\..\Source/tasks.c **** 	#endif
 832:..\..\..\Source/tasks.c **** 
 833:..\..\..\Source/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
 834:..\..\..\Source/tasks.c **** 	{
 835:..\..\..\Source/tasks.c **** 		pxNewTCB->ucDelayAborted = pdFALSE;
 836:..\..\..\Source/tasks.c **** 	}
 837:..\..\..\Source/tasks.c **** 	#endif
 838:..\..\..\Source/tasks.c **** 
 839:..\..\..\Source/tasks.c **** 	/* Initialize the TCB stack to look as if the task was already running,
 840:..\..\..\Source/tasks.c **** 	but had been interrupted by the scheduler.  The return address is set
 841:..\..\..\Source/tasks.c **** 	to the start of the task function. Once the stack has been initialised
 842:..\..\..\Source/tasks.c **** 	the	top of stack variable is updated. */
 843:..\..\..\Source/tasks.c **** 	#if( portUSING_MPU_WRAPPERS == 1 )
 844:..\..\..\Source/tasks.c **** 	{
 845:..\..\..\Source/tasks.c **** 		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivi
 846:..\..\..\Source/tasks.c **** 	}
 847:..\..\..\Source/tasks.c **** 	#else /* portUSING_MPU_WRAPPERS */
 848:..\..\..\Source/tasks.c **** 	{
 849:..\..\..\Source/tasks.c **** 		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 22


 323              		.loc 1 849 0
 324 00ca 3869     		ldr	r0, [r7, #16]
 325 00cc F968     		ldr	r1, [r7, #12]
 326 00ce 3A68     		ldr	r2, [r7]
 327 00d0 FFF7FEFF 		bl	pxPortInitialiseStack
 328 00d4 0246     		mov	r2, r0
 329 00d6 BB6A     		ldr	r3, [r7, #40]
 330 00d8 1A60     		str	r2, [r3]
 850:..\..\..\Source/tasks.c **** 	}
 851:..\..\..\Source/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS */
 852:..\..\..\Source/tasks.c **** 
 853:..\..\..\Source/tasks.c **** 	if( ( void * ) pxCreatedTask != NULL )
 331              		.loc 1 853 0
 332 00da 7B6A     		ldr	r3, [r7, #36]
 333 00dc 002B     		cmp	r3, #0
 334 00de 02D0     		beq	.L9
 854:..\..\..\Source/tasks.c **** 	{
 855:..\..\..\Source/tasks.c **** 		/* Pass the handle out in an anonymous way.  The handle can be used to
 856:..\..\..\Source/tasks.c **** 		change the created task's priority, delete the created task, etc.*/
 857:..\..\..\Source/tasks.c **** 		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 335              		.loc 1 857 0
 336 00e0 7B6A     		ldr	r3, [r7, #36]
 337 00e2 BA6A     		ldr	r2, [r7, #40]
 338 00e4 1A60     		str	r2, [r3]
 339              	.L9:
 858:..\..\..\Source/tasks.c **** 	}
 859:..\..\..\Source/tasks.c **** 	else
 860:..\..\..\Source/tasks.c **** 	{
 861:..\..\..\Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
 862:..\..\..\Source/tasks.c **** 	}
 863:..\..\..\Source/tasks.c **** }
 340              		.loc 1 863 0
 341 00e6 1837     		adds	r7, r7, #24
 342              		.cfi_def_cfa_offset 8
 343 00e8 BD46     		mov	sp, r7
 344              		.cfi_def_cfa_register 13
 345              		@ sp needed
 346 00ea 80BD     		pop	{r7, pc}
 347              		.cfi_endproc
 348              	.LFE69:
 349              		.size	prvInitialiseNewTask, .-prvInitialiseNewTask
 350              		.section	.text.prvAddNewTaskToReadyList,"ax",%progbits
 351              		.align	2
 352              		.thumb
 353              		.thumb_func
 354              		.type	prvAddNewTaskToReadyList, %function
 355              	prvAddNewTaskToReadyList:
 356              	.LFB70:
 864:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
 865:..\..\..\Source/tasks.c **** 
 866:..\..\..\Source/tasks.c **** static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
 867:..\..\..\Source/tasks.c **** {
 357              		.loc 1 867 0
 358              		.cfi_startproc
 359              		@ args = 0, pretend = 0, frame = 8
 360              		@ frame_needed = 1, uses_anonymous_args = 0
 361 0000 80B5     		push	{r7, lr}
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 23


 362              		.cfi_def_cfa_offset 8
 363              		.cfi_offset 7, -8
 364              		.cfi_offset 14, -4
 365 0002 82B0     		sub	sp, sp, #8
 366              		.cfi_def_cfa_offset 16
 367 0004 00AF     		add	r7, sp, #0
 368              		.cfi_def_cfa_register 7
 369 0006 7860     		str	r0, [r7, #4]
 868:..\..\..\Source/tasks.c **** 	/* Ensure interrupts don't access the task lists while the lists are being
 869:..\..\..\Source/tasks.c **** 	updated. */
 870:..\..\..\Source/tasks.c **** 	taskENTER_CRITICAL();
 370              		.loc 1 870 0
 371 0008 FFF7FEFF 		bl	vPortEnterCritical
 871:..\..\..\Source/tasks.c **** 	{
 872:..\..\..\Source/tasks.c **** 		uxCurrentNumberOfTasks++;
 372              		.loc 1 872 0
 373 000c 2B4B     		ldr	r3, .L20
 374 000e 1B68     		ldr	r3, [r3]
 375 0010 0133     		adds	r3, r3, #1
 376 0012 2A4A     		ldr	r2, .L20
 377 0014 1360     		str	r3, [r2]
 873:..\..\..\Source/tasks.c **** 		if( pxCurrentTCB == NULL )
 378              		.loc 1 873 0
 379 0016 2A4B     		ldr	r3, .L20+4
 380 0018 1B68     		ldr	r3, [r3]
 381 001a 002B     		cmp	r3, #0
 382 001c 09D1     		bne	.L17
 874:..\..\..\Source/tasks.c **** 		{
 875:..\..\..\Source/tasks.c **** 			/* There are no other tasks, or all the other tasks are in
 876:..\..\..\Source/tasks.c **** 			the suspended state - make this the current task. */
 877:..\..\..\Source/tasks.c **** 			pxCurrentTCB = pxNewTCB;
 383              		.loc 1 877 0
 384 001e 284A     		ldr	r2, .L20+4
 385 0020 7B68     		ldr	r3, [r7, #4]
 386 0022 1360     		str	r3, [r2]
 878:..\..\..\Source/tasks.c **** 
 879:..\..\..\Source/tasks.c **** 			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 387              		.loc 1 879 0
 388 0024 254B     		ldr	r3, .L20
 389 0026 1B68     		ldr	r3, [r3]
 390 0028 012B     		cmp	r3, #1
 391 002a 10D1     		bne	.L18
 880:..\..\..\Source/tasks.c **** 			{
 881:..\..\..\Source/tasks.c **** 				/* This is the first task to be created so do the preliminary
 882:..\..\..\Source/tasks.c **** 				initialisation required.  We will not recover if this call
 883:..\..\..\Source/tasks.c **** 				fails, but we will report the failure. */
 884:..\..\..\Source/tasks.c **** 				prvInitialiseTaskLists();
 392              		.loc 1 884 0
 393 002c FFF7FEFF 		bl	prvInitialiseTaskLists
 394 0030 0DE0     		b	.L18
 395              	.L17:
 885:..\..\..\Source/tasks.c **** 			}
 886:..\..\..\Source/tasks.c **** 			else
 887:..\..\..\Source/tasks.c **** 			{
 888:..\..\..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 889:..\..\..\Source/tasks.c **** 			}
 890:..\..\..\Source/tasks.c **** 		}
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 24


 891:..\..\..\Source/tasks.c **** 		else
 892:..\..\..\Source/tasks.c **** 		{
 893:..\..\..\Source/tasks.c **** 			/* If the scheduler is not already running, make this task the
 894:..\..\..\Source/tasks.c **** 			current task if it is the highest priority task to be created
 895:..\..\..\Source/tasks.c **** 			so far. */
 896:..\..\..\Source/tasks.c **** 			if( xSchedulerRunning == pdFALSE )
 396              		.loc 1 896 0
 397 0032 244B     		ldr	r3, .L20+8
 398 0034 1B68     		ldr	r3, [r3]
 399 0036 002B     		cmp	r3, #0
 400 0038 09D1     		bne	.L18
 897:..\..\..\Source/tasks.c **** 			{
 898:..\..\..\Source/tasks.c **** 				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 401              		.loc 1 898 0
 402 003a 214B     		ldr	r3, .L20+4
 403 003c 1B68     		ldr	r3, [r3]
 404 003e DA6A     		ldr	r2, [r3, #44]
 405 0040 7B68     		ldr	r3, [r7, #4]
 406 0042 DB6A     		ldr	r3, [r3, #44]
 407 0044 9A42     		cmp	r2, r3
 408 0046 02D8     		bhi	.L18
 899:..\..\..\Source/tasks.c **** 				{
 900:..\..\..\Source/tasks.c **** 					pxCurrentTCB = pxNewTCB;
 409              		.loc 1 900 0
 410 0048 1D4A     		ldr	r2, .L20+4
 411 004a 7B68     		ldr	r3, [r7, #4]
 412 004c 1360     		str	r3, [r2]
 413              	.L18:
 901:..\..\..\Source/tasks.c **** 				}
 902:..\..\..\Source/tasks.c **** 				else
 903:..\..\..\Source/tasks.c **** 				{
 904:..\..\..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 905:..\..\..\Source/tasks.c **** 				}
 906:..\..\..\Source/tasks.c **** 			}
 907:..\..\..\Source/tasks.c **** 			else
 908:..\..\..\Source/tasks.c **** 			{
 909:..\..\..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 910:..\..\..\Source/tasks.c **** 			}
 911:..\..\..\Source/tasks.c **** 		}
 912:..\..\..\Source/tasks.c **** 
 913:..\..\..\Source/tasks.c **** 		uxTaskNumber++;
 414              		.loc 1 913 0
 415 004e 1E4B     		ldr	r3, .L20+12
 416 0050 1B68     		ldr	r3, [r3]
 417 0052 0133     		adds	r3, r3, #1
 418 0054 1C4A     		ldr	r2, .L20+12
 419 0056 1360     		str	r3, [r2]
 914:..\..\..\Source/tasks.c **** 
 915:..\..\..\Source/tasks.c **** 		#if ( configUSE_TRACE_FACILITY == 1 )
 916:..\..\..\Source/tasks.c **** 		{
 917:..\..\..\Source/tasks.c **** 			/* Add a counter into the TCB for tracing only. */
 918:..\..\..\Source/tasks.c **** 			pxNewTCB->uxTCBNumber = uxTaskNumber;
 919:..\..\..\Source/tasks.c **** 		}
 920:..\..\..\Source/tasks.c **** 		#endif /* configUSE_TRACE_FACILITY */
 921:..\..\..\Source/tasks.c **** 		traceTASK_CREATE( pxNewTCB );
 922:..\..\..\Source/tasks.c **** 
 923:..\..\..\Source/tasks.c **** 		prvAddTaskToReadyList( pxNewTCB );
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 25


 420              		.loc 1 923 0
 421 0058 7B68     		ldr	r3, [r7, #4]
 422 005a DB6A     		ldr	r3, [r3, #44]
 423 005c 1A46     		mov	r2, r3
 424 005e 0123     		movs	r3, #1
 425 0060 03FA02F2 		lsl	r2, r3, r2
 426 0064 194B     		ldr	r3, .L20+16
 427 0066 1B68     		ldr	r3, [r3]
 428 0068 1343     		orrs	r3, r3, r2
 429 006a 184A     		ldr	r2, .L20+16
 430 006c 1360     		str	r3, [r2]
 431 006e 7B68     		ldr	r3, [r7, #4]
 432 0070 DA6A     		ldr	r2, [r3, #44]
 433 0072 1346     		mov	r3, r2
 434 0074 9B00     		lsls	r3, r3, #2
 435 0076 1344     		add	r3, r3, r2
 436 0078 9B00     		lsls	r3, r3, #2
 437 007a 154A     		ldr	r2, .L20+20
 438 007c 1A44     		add	r2, r2, r3
 439 007e 7B68     		ldr	r3, [r7, #4]
 440 0080 0433     		adds	r3, r3, #4
 441 0082 1046     		mov	r0, r2
 442 0084 1946     		mov	r1, r3
 443 0086 FFF7FEFF 		bl	vListInsertEnd
 924:..\..\..\Source/tasks.c **** 
 925:..\..\..\Source/tasks.c **** 		portSETUP_TCB( pxNewTCB );
 926:..\..\..\Source/tasks.c **** 	}
 927:..\..\..\Source/tasks.c **** 	taskEXIT_CRITICAL();
 444              		.loc 1 927 0
 445 008a FFF7FEFF 		bl	vPortExitCritical
 928:..\..\..\Source/tasks.c **** 
 929:..\..\..\Source/tasks.c **** 	if( xSchedulerRunning != pdFALSE )
 446              		.loc 1 929 0
 447 008e 0D4B     		ldr	r3, .L20+8
 448 0090 1B68     		ldr	r3, [r3]
 449 0092 002B     		cmp	r3, #0
 450 0094 0ED0     		beq	.L16
 930:..\..\..\Source/tasks.c **** 	{
 931:..\..\..\Source/tasks.c **** 		/* If the created task is of a higher priority than the current task
 932:..\..\..\Source/tasks.c **** 		then it should run now. */
 933:..\..\..\Source/tasks.c **** 		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 451              		.loc 1 933 0
 452 0096 0A4B     		ldr	r3, .L20+4
 453 0098 1B68     		ldr	r3, [r3]
 454 009a DA6A     		ldr	r2, [r3, #44]
 455 009c 7B68     		ldr	r3, [r7, #4]
 456 009e DB6A     		ldr	r3, [r3, #44]
 457 00a0 9A42     		cmp	r2, r3
 458 00a2 07D2     		bcs	.L16
 934:..\..\..\Source/tasks.c **** 		{
 935:..\..\..\Source/tasks.c **** 			taskYIELD_IF_USING_PREEMPTION();
 459              		.loc 1 935 0
 460 00a4 0B4B     		ldr	r3, .L20+24
 461 00a6 4FF08052 		mov	r2, #268435456
 462 00aa 1A60     		str	r2, [r3]
 463              	@ 935 "..\..\..\Source\tasks.c" 1
 464 00ac BFF34F8F 		dsb
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 26


 465              	@ 0 "" 2
 466              	@ 935 "..\..\..\Source\tasks.c" 1
 467 00b0 BFF36F8F 		isb
 468              	@ 0 "" 2
 469              		.thumb
 470              	.L16:
 936:..\..\..\Source/tasks.c **** 		}
 937:..\..\..\Source/tasks.c **** 		else
 938:..\..\..\Source/tasks.c **** 		{
 939:..\..\..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 940:..\..\..\Source/tasks.c **** 		}
 941:..\..\..\Source/tasks.c **** 	}
 942:..\..\..\Source/tasks.c **** 	else
 943:..\..\..\Source/tasks.c **** 	{
 944:..\..\..\Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
 945:..\..\..\Source/tasks.c **** 	}
 946:..\..\..\Source/tasks.c **** }
 471              		.loc 1 946 0
 472 00b4 0837     		adds	r7, r7, #8
 473              		.cfi_def_cfa_offset 8
 474 00b6 BD46     		mov	sp, r7
 475              		.cfi_def_cfa_register 13
 476              		@ sp needed
 477 00b8 80BD     		pop	{r7, pc}
 478              	.L21:
 479 00ba 00BF     		.align	2
 480              	.L20:
 481 00bc D8000000 		.word	uxCurrentNumberOfTasks
 482 00c0 00000000 		.word	pxCurrentTCB
 483 00c4 E4000000 		.word	xSchedulerRunning
 484 00c8 F4000000 		.word	uxTaskNumber
 485 00cc E0000000 		.word	uxTopReadyPriority
 486 00d0 04000000 		.word	pxReadyTasksLists
 487 00d4 04ED00E0 		.word	-536810236
 488              		.cfi_endproc
 489              	.LFE70:
 490              		.size	prvAddNewTaskToReadyList, .-prvAddNewTaskToReadyList
 491              		.section	.text.vTaskDelete,"ax",%progbits
 492              		.align	2
 493              		.global	vTaskDelete
 494              		.thumb
 495              		.thumb_func
 496              		.type	vTaskDelete, %function
 497              	vTaskDelete:
 498              	.LFB71:
 947:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
 948:..\..\..\Source/tasks.c **** 
 949:..\..\..\Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 950:..\..\..\Source/tasks.c **** 
 951:..\..\..\Source/tasks.c **** 	void vTaskDelete( TaskHandle_t xTaskToDelete )
 952:..\..\..\Source/tasks.c **** 	{
 499              		.loc 1 952 0
 500              		.cfi_startproc
 501              		@ args = 0, pretend = 0, frame = 16
 502              		@ frame_needed = 1, uses_anonymous_args = 0
 503 0000 80B5     		push	{r7, lr}
 504              		.cfi_def_cfa_offset 8
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 27


 505              		.cfi_offset 7, -8
 506              		.cfi_offset 14, -4
 507 0002 84B0     		sub	sp, sp, #16
 508              		.cfi_def_cfa_offset 24
 509 0004 00AF     		add	r7, sp, #0
 510              		.cfi_def_cfa_register 7
 511 0006 7860     		str	r0, [r7, #4]
 953:..\..\..\Source/tasks.c **** 	TCB_t *pxTCB;
 954:..\..\..\Source/tasks.c **** 
 955:..\..\..\Source/tasks.c **** 		taskENTER_CRITICAL();
 512              		.loc 1 955 0
 513 0008 FFF7FEFF 		bl	vPortEnterCritical
 956:..\..\..\Source/tasks.c **** 		{
 957:..\..\..\Source/tasks.c **** 			/* If null is passed in here then it is the calling task that is
 958:..\..\..\Source/tasks.c **** 			being deleted. */
 959:..\..\..\Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 514              		.loc 1 959 0
 515 000c 7B68     		ldr	r3, [r7, #4]
 516 000e 002B     		cmp	r3, #0
 517 0010 02D1     		bne	.L23
 518              		.loc 1 959 0 is_stmt 0 discriminator 1
 519 0012 314B     		ldr	r3, .L31
 520 0014 1B68     		ldr	r3, [r3]
 521 0016 00E0     		b	.L24
 522              	.L23:
 523              		.loc 1 959 0 discriminator 2
 524 0018 7B68     		ldr	r3, [r7, #4]
 525              	.L24:
 526              		.loc 1 959 0 discriminator 4
 527 001a FB60     		str	r3, [r7, #12]
 960:..\..\..\Source/tasks.c **** 
 961:..\..\..\Source/tasks.c **** 			/* Remove task from the ready list. */
 962:..\..\..\Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 528              		.loc 1 962 0 is_stmt 1 discriminator 4
 529 001c FB68     		ldr	r3, [r7, #12]
 530 001e 0433     		adds	r3, r3, #4
 531 0020 1846     		mov	r0, r3
 532 0022 FFF7FEFF 		bl	uxListRemove
 533 0026 0346     		mov	r3, r0
 534 0028 002B     		cmp	r3, #0
 535 002a 15D1     		bne	.L25
 963:..\..\..\Source/tasks.c **** 			{
 964:..\..\..\Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 536              		.loc 1 964 0
 537 002c FB68     		ldr	r3, [r7, #12]
 538 002e DA6A     		ldr	r2, [r3, #44]
 539 0030 2A49     		ldr	r1, .L31+4
 540 0032 1346     		mov	r3, r2
 541 0034 9B00     		lsls	r3, r3, #2
 542 0036 1344     		add	r3, r3, r2
 543 0038 9B00     		lsls	r3, r3, #2
 544 003a 0B44     		add	r3, r3, r1
 545 003c 1B68     		ldr	r3, [r3]
 546 003e 002B     		cmp	r3, #0
 547 0040 0AD1     		bne	.L25
 548              		.loc 1 964 0 is_stmt 0 discriminator 1
 549 0042 FB68     		ldr	r3, [r7, #12]
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 28


 550 0044 DB6A     		ldr	r3, [r3, #44]
 551 0046 1A46     		mov	r2, r3
 552 0048 0123     		movs	r3, #1
 553 004a 9340     		lsls	r3, r3, r2
 554 004c DA43     		mvns	r2, r3
 555 004e 244B     		ldr	r3, .L31+8
 556 0050 1B68     		ldr	r3, [r3]
 557 0052 1340     		ands	r3, r3, r2
 558 0054 224A     		ldr	r2, .L31+8
 559 0056 1360     		str	r3, [r2]
 560              	.L25:
 965:..\..\..\Source/tasks.c **** 			}
 966:..\..\..\Source/tasks.c **** 			else
 967:..\..\..\Source/tasks.c **** 			{
 968:..\..\..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 969:..\..\..\Source/tasks.c **** 			}
 970:..\..\..\Source/tasks.c **** 
 971:..\..\..\Source/tasks.c **** 			/* Is the task waiting on an event also? */
 972:..\..\..\Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 561              		.loc 1 972 0 is_stmt 1
 562 0058 FB68     		ldr	r3, [r7, #12]
 563 005a 9B6A     		ldr	r3, [r3, #40]
 564 005c 002B     		cmp	r3, #0
 565 005e 04D0     		beq	.L27
 973:..\..\..\Source/tasks.c **** 			{
 974:..\..\..\Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 566              		.loc 1 974 0
 567 0060 FB68     		ldr	r3, [r7, #12]
 568 0062 1833     		adds	r3, r3, #24
 569 0064 1846     		mov	r0, r3
 570 0066 FFF7FEFF 		bl	uxListRemove
 571              	.L27:
 975:..\..\..\Source/tasks.c **** 			}
 976:..\..\..\Source/tasks.c **** 			else
 977:..\..\..\Source/tasks.c **** 			{
 978:..\..\..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 979:..\..\..\Source/tasks.c **** 			}
 980:..\..\..\Source/tasks.c **** 
 981:..\..\..\Source/tasks.c **** 			/* Increment the uxTaskNumber also so kernel aware debuggers can
 982:..\..\..\Source/tasks.c **** 			detect that the task lists need re-generating.  This is done before
 983:..\..\..\Source/tasks.c **** 			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
 984:..\..\..\Source/tasks.c **** 			not return. */
 985:..\..\..\Source/tasks.c **** 			uxTaskNumber++;
 572              		.loc 1 985 0
 573 006a 1E4B     		ldr	r3, .L31+12
 574 006c 1B68     		ldr	r3, [r3]
 575 006e 0133     		adds	r3, r3, #1
 576 0070 1C4A     		ldr	r2, .L31+12
 577 0072 1360     		str	r3, [r2]
 986:..\..\..\Source/tasks.c **** 
 987:..\..\..\Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
 578              		.loc 1 987 0
 579 0074 184B     		ldr	r3, .L31
 580 0076 1B68     		ldr	r3, [r3]
 581 0078 FA68     		ldr	r2, [r7, #12]
 582 007a 9A42     		cmp	r2, r3
 583 007c 0BD1     		bne	.L28
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 29


 988:..\..\..\Source/tasks.c **** 			{
 989:..\..\..\Source/tasks.c **** 				/* A task is deleting itself.  This cannot complete within the
 990:..\..\..\Source/tasks.c **** 				task itself, as a context switch to another task is required.
 991:..\..\..\Source/tasks.c **** 				Place the task in the termination list.  The idle task will
 992:..\..\..\Source/tasks.c **** 				check the termination list and free up any memory allocated by
 993:..\..\..\Source/tasks.c **** 				the scheduler for the TCB and stack of the deleted task. */
 994:..\..\..\Source/tasks.c **** 				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 584              		.loc 1 994 0
 585 007e FB68     		ldr	r3, [r7, #12]
 586 0080 0433     		adds	r3, r3, #4
 587 0082 1948     		ldr	r0, .L31+16
 588 0084 1946     		mov	r1, r3
 589 0086 FFF7FEFF 		bl	vListInsertEnd
 995:..\..\..\Source/tasks.c **** 
 996:..\..\..\Source/tasks.c **** 				/* Increment the ucTasksDeleted variable so the idle task knows
 997:..\..\..\Source/tasks.c **** 				there is a task that has been deleted and that it should therefore
 998:..\..\..\Source/tasks.c **** 				check the xTasksWaitingTermination list. */
 999:..\..\..\Source/tasks.c **** 				++uxDeletedTasksWaitingCleanUp;
 590              		.loc 1 999 0
 591 008a 184B     		ldr	r3, .L31+20
 592 008c 1B68     		ldr	r3, [r3]
 593 008e 0133     		adds	r3, r3, #1
 594 0090 164A     		ldr	r2, .L31+20
 595 0092 1360     		str	r3, [r2]
 596 0094 09E0     		b	.L29
 597              	.L28:
1000:..\..\..\Source/tasks.c **** 
1001:..\..\..\Source/tasks.c **** 				/* The pre-delete hook is primarily for the Windows simulator,
1002:..\..\..\Source/tasks.c **** 				in which Windows specific clean up operations are performed,
1003:..\..\..\Source/tasks.c **** 				after which it is not possible to yield away from this task -
1004:..\..\..\Source/tasks.c **** 				hence xYieldPending is used to latch that a context switch is
1005:..\..\..\Source/tasks.c **** 				required. */
1006:..\..\..\Source/tasks.c **** 				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
1007:..\..\..\Source/tasks.c **** 			}
1008:..\..\..\Source/tasks.c **** 			else
1009:..\..\..\Source/tasks.c **** 			{
1010:..\..\..\Source/tasks.c **** 				--uxCurrentNumberOfTasks;
 598              		.loc 1 1010 0
 599 0096 164B     		ldr	r3, .L31+24
 600 0098 1B68     		ldr	r3, [r3]
 601 009a 013B     		subs	r3, r3, #1
 602 009c 144A     		ldr	r2, .L31+24
 603 009e 1360     		str	r3, [r2]
1011:..\..\..\Source/tasks.c **** 				prvDeleteTCB( pxTCB );
 604              		.loc 1 1011 0
 605 00a0 F868     		ldr	r0, [r7, #12]
 606 00a2 FFF7FEFF 		bl	prvDeleteTCB
1012:..\..\..\Source/tasks.c **** 
1013:..\..\..\Source/tasks.c **** 				/* Reset the next expected unblock time in case it referred to
1014:..\..\..\Source/tasks.c **** 				the task that has just been deleted. */
1015:..\..\..\Source/tasks.c **** 				prvResetNextTaskUnblockTime();
 607              		.loc 1 1015 0
 608 00a6 FFF7FEFF 		bl	prvResetNextTaskUnblockTime
 609              	.L29:
1016:..\..\..\Source/tasks.c **** 			}
1017:..\..\..\Source/tasks.c **** 
1018:..\..\..\Source/tasks.c **** 			traceTASK_DELETE( pxTCB );
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 30


1019:..\..\..\Source/tasks.c **** 		}
1020:..\..\..\Source/tasks.c **** 		taskEXIT_CRITICAL();
 610              		.loc 1 1020 0
 611 00aa FFF7FEFF 		bl	vPortExitCritical
1021:..\..\..\Source/tasks.c **** 
1022:..\..\..\Source/tasks.c **** 		/* Force a reschedule if it is the currently running task that has just
1023:..\..\..\Source/tasks.c **** 		been deleted. */
1024:..\..\..\Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 612              		.loc 1 1024 0
 613 00ae 114B     		ldr	r3, .L31+28
 614 00b0 1B68     		ldr	r3, [r3]
 615 00b2 002B     		cmp	r3, #0
 616 00b4 0CD0     		beq	.L22
1025:..\..\..\Source/tasks.c **** 		{
1026:..\..\..\Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
 617              		.loc 1 1026 0
 618 00b6 084B     		ldr	r3, .L31
 619 00b8 1B68     		ldr	r3, [r3]
 620 00ba FA68     		ldr	r2, [r7, #12]
 621 00bc 9A42     		cmp	r2, r3
 622 00be 07D1     		bne	.L22
1027:..\..\..\Source/tasks.c **** 			{
1028:..\..\..\Source/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
1029:..\..\..\Source/tasks.c **** 				portYIELD_WITHIN_API();
 623              		.loc 1 1029 0
 624 00c0 0D4B     		ldr	r3, .L31+32
 625 00c2 4FF08052 		mov	r2, #268435456
 626 00c6 1A60     		str	r2, [r3]
 627              	@ 1029 "..\..\..\Source\tasks.c" 1
 628 00c8 BFF34F8F 		dsb
 629              	@ 0 "" 2
 630              	@ 1029 "..\..\..\Source\tasks.c" 1
 631 00cc BFF36F8F 		isb
 632              	@ 0 "" 2
 633              		.thumb
 634              	.L22:
1030:..\..\..\Source/tasks.c **** 			}
1031:..\..\..\Source/tasks.c **** 			else
1032:..\..\..\Source/tasks.c **** 			{
1033:..\..\..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1034:..\..\..\Source/tasks.c **** 			}
1035:..\..\..\Source/tasks.c **** 		}
1036:..\..\..\Source/tasks.c **** 	}
 635              		.loc 1 1036 0
 636 00d0 1037     		adds	r7, r7, #16
 637              		.cfi_def_cfa_offset 8
 638 00d2 BD46     		mov	sp, r7
 639              		.cfi_def_cfa_register 13
 640              		@ sp needed
 641 00d4 80BD     		pop	{r7, pc}
 642              	.L32:
 643 00d6 00BF     		.align	2
 644              	.L31:
 645 00d8 00000000 		.word	pxCurrentTCB
 646 00dc 04000000 		.word	pxReadyTasksLists
 647 00e0 E0000000 		.word	uxTopReadyPriority
 648 00e4 F4000000 		.word	uxTaskNumber
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 31


 649 00e8 AC000000 		.word	xTasksWaitingTermination
 650 00ec C0000000 		.word	uxDeletedTasksWaitingCleanUp
 651 00f0 D8000000 		.word	uxCurrentNumberOfTasks
 652 00f4 E4000000 		.word	xSchedulerRunning
 653 00f8 04ED00E0 		.word	-536810236
 654              		.cfi_endproc
 655              	.LFE71:
 656              		.size	vTaskDelete, .-vTaskDelete
 657              		.section	.text.vTaskDelayUntil,"ax",%progbits
 658              		.align	2
 659              		.global	vTaskDelayUntil
 660              		.thumb
 661              		.thumb_func
 662              		.type	vTaskDelayUntil, %function
 663              	vTaskDelayUntil:
 664              	.LFB72:
1037:..\..\..\Source/tasks.c **** 
1038:..\..\..\Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
1039:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
1040:..\..\..\Source/tasks.c **** 
1041:..\..\..\Source/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
1042:..\..\..\Source/tasks.c **** 
1043:..\..\..\Source/tasks.c **** 	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
1044:..\..\..\Source/tasks.c **** 	{
 665              		.loc 1 1044 0
 666              		.cfi_startproc
 667              		@ args = 0, pretend = 0, frame = 24
 668              		@ frame_needed = 1, uses_anonymous_args = 0
 669 0000 80B5     		push	{r7, lr}
 670              		.cfi_def_cfa_offset 8
 671              		.cfi_offset 7, -8
 672              		.cfi_offset 14, -4
 673 0002 86B0     		sub	sp, sp, #24
 674              		.cfi_def_cfa_offset 32
 675 0004 00AF     		add	r7, sp, #0
 676              		.cfi_def_cfa_register 7
 677 0006 7860     		str	r0, [r7, #4]
 678 0008 3960     		str	r1, [r7]
1045:..\..\..\Source/tasks.c **** 	TickType_t xTimeToWake;
1046:..\..\..\Source/tasks.c **** 	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 679              		.loc 1 1046 0
 680 000a 0023     		movs	r3, #0
 681 000c 7B61     		str	r3, [r7, #20]
1047:..\..\..\Source/tasks.c **** 
1048:..\..\..\Source/tasks.c **** 		configASSERT( pxPreviousWakeTime );
1049:..\..\..\Source/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
1050:..\..\..\Source/tasks.c **** 		configASSERT( uxSchedulerSuspended == 0 );
1051:..\..\..\Source/tasks.c **** 
1052:..\..\..\Source/tasks.c **** 		vTaskSuspendAll();
 682              		.loc 1 1052 0
 683 000e FFF7FEFF 		bl	vTaskSuspendAll
 684              	.LBB28:
1053:..\..\..\Source/tasks.c **** 		{
1054:..\..\..\Source/tasks.c **** 			/* Minor optimisation.  The tick count cannot change in this
1055:..\..\..\Source/tasks.c **** 			block. */
1056:..\..\..\Source/tasks.c **** 			const TickType_t xConstTickCount = xTickCount;
 685              		.loc 1 1056 0
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 32


 686 0012 214B     		ldr	r3, .L39
 687 0014 1B68     		ldr	r3, [r3]
 688 0016 3B61     		str	r3, [r7, #16]
1057:..\..\..\Source/tasks.c **** 
1058:..\..\..\Source/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
1059:..\..\..\Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 689              		.loc 1 1059 0
 690 0018 7B68     		ldr	r3, [r7, #4]
 691 001a 1A68     		ldr	r2, [r3]
 692 001c 3B68     		ldr	r3, [r7]
 693 001e 1344     		add	r3, r3, r2
 694 0020 FB60     		str	r3, [r7, #12]
1060:..\..\..\Source/tasks.c **** 
1061:..\..\..\Source/tasks.c **** 			if( xConstTickCount < *pxPreviousWakeTime )
 695              		.loc 1 1061 0
 696 0022 7B68     		ldr	r3, [r7, #4]
 697 0024 1A68     		ldr	r2, [r3]
 698 0026 3B69     		ldr	r3, [r7, #16]
 699 0028 9A42     		cmp	r2, r3
 700 002a 0BD9     		bls	.L34
1062:..\..\..\Source/tasks.c **** 			{
1063:..\..\..\Source/tasks.c **** 				/* The tick count has overflowed since this function was
1064:..\..\..\Source/tasks.c **** 				lasted called.  In this case the only time we should ever
1065:..\..\..\Source/tasks.c **** 				actually delay is if the wake time has also	overflowed,
1066:..\..\..\Source/tasks.c **** 				and the wake time is greater than the tick time.  When this
1067:..\..\..\Source/tasks.c **** 				is the case it is as if neither time had overflowed. */
1068:..\..\..\Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 701              		.loc 1 1068 0
 702 002c 7B68     		ldr	r3, [r7, #4]
 703 002e 1A68     		ldr	r2, [r3]
 704 0030 FB68     		ldr	r3, [r7, #12]
 705 0032 9A42     		cmp	r2, r3
 706 0034 11D9     		bls	.L35
 707              		.loc 1 1068 0 is_stmt 0 discriminator 1
 708 0036 FA68     		ldr	r2, [r7, #12]
 709 0038 3B69     		ldr	r3, [r7, #16]
 710 003a 9A42     		cmp	r2, r3
 711 003c 0DD9     		bls	.L35
1069:..\..\..\Source/tasks.c **** 				{
1070:..\..\..\Source/tasks.c **** 					xShouldDelay = pdTRUE;
 712              		.loc 1 1070 0 is_stmt 1
 713 003e 0123     		movs	r3, #1
 714 0040 7B61     		str	r3, [r7, #20]
 715 0042 0AE0     		b	.L35
 716              	.L34:
1071:..\..\..\Source/tasks.c **** 				}
1072:..\..\..\Source/tasks.c **** 				else
1073:..\..\..\Source/tasks.c **** 				{
1074:..\..\..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1075:..\..\..\Source/tasks.c **** 				}
1076:..\..\..\Source/tasks.c **** 			}
1077:..\..\..\Source/tasks.c **** 			else
1078:..\..\..\Source/tasks.c **** 			{
1079:..\..\..\Source/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
1080:..\..\..\Source/tasks.c **** 				delay if either the wake time has overflowed, and/or the
1081:..\..\..\Source/tasks.c **** 				tick time is less than the wake time. */
1082:..\..\..\Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 33


 717              		.loc 1 1082 0
 718 0044 7B68     		ldr	r3, [r7, #4]
 719 0046 1A68     		ldr	r2, [r3]
 720 0048 FB68     		ldr	r3, [r7, #12]
 721 004a 9A42     		cmp	r2, r3
 722 004c 03D8     		bhi	.L36
 723              		.loc 1 1082 0 is_stmt 0 discriminator 1
 724 004e FA68     		ldr	r2, [r7, #12]
 725 0050 3B69     		ldr	r3, [r7, #16]
 726 0052 9A42     		cmp	r2, r3
 727 0054 01D9     		bls	.L35
 728              	.L36:
1083:..\..\..\Source/tasks.c **** 				{
1084:..\..\..\Source/tasks.c **** 					xShouldDelay = pdTRUE;
 729              		.loc 1 1084 0 is_stmt 1
 730 0056 0123     		movs	r3, #1
 731 0058 7B61     		str	r3, [r7, #20]
 732              	.L35:
1085:..\..\..\Source/tasks.c **** 				}
1086:..\..\..\Source/tasks.c **** 				else
1087:..\..\..\Source/tasks.c **** 				{
1088:..\..\..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1089:..\..\..\Source/tasks.c **** 				}
1090:..\..\..\Source/tasks.c **** 			}
1091:..\..\..\Source/tasks.c **** 
1092:..\..\..\Source/tasks.c **** 			/* Update the wake time ready for the next call. */
1093:..\..\..\Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 733              		.loc 1 1093 0
 734 005a 7B68     		ldr	r3, [r7, #4]
 735 005c FA68     		ldr	r2, [r7, #12]
 736 005e 1A60     		str	r2, [r3]
1094:..\..\..\Source/tasks.c **** 
1095:..\..\..\Source/tasks.c **** 			if( xShouldDelay != pdFALSE )
 737              		.loc 1 1095 0
 738 0060 7B69     		ldr	r3, [r7, #20]
 739 0062 002B     		cmp	r3, #0
 740 0064 06D0     		beq	.L37
1096:..\..\..\Source/tasks.c **** 			{
1097:..\..\..\Source/tasks.c **** 				traceTASK_DELAY_UNTIL( xTimeToWake );
1098:..\..\..\Source/tasks.c **** 
1099:..\..\..\Source/tasks.c **** 				/* prvAddCurrentTaskToDelayedList() needs the block time, not
1100:..\..\..\Source/tasks.c **** 				the time to wake, so subtract the current tick count. */
1101:..\..\..\Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
 741              		.loc 1 1101 0
 742 0066 FA68     		ldr	r2, [r7, #12]
 743 0068 3B69     		ldr	r3, [r7, #16]
 744 006a D31A     		subs	r3, r2, r3
 745 006c 1846     		mov	r0, r3
 746 006e 0021     		movs	r1, #0
 747 0070 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 748              	.L37:
 749              	.LBE28:
1102:..\..\..\Source/tasks.c **** 			}
1103:..\..\..\Source/tasks.c **** 			else
1104:..\..\..\Source/tasks.c **** 			{
1105:..\..\..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1106:..\..\..\Source/tasks.c **** 			}
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 34


1107:..\..\..\Source/tasks.c **** 		}
1108:..\..\..\Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 750              		.loc 1 1108 0
 751 0074 FFF7FEFF 		bl	xTaskResumeAll
 752 0078 B860     		str	r0, [r7, #8]
1109:..\..\..\Source/tasks.c **** 
1110:..\..\..\Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1111:..\..\..\Source/tasks.c **** 		have put ourselves to sleep. */
1112:..\..\..\Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 753              		.loc 1 1112 0
 754 007a BB68     		ldr	r3, [r7, #8]
 755 007c 002B     		cmp	r3, #0
 756 007e 07D1     		bne	.L33
1113:..\..\..\Source/tasks.c **** 		{
1114:..\..\..\Source/tasks.c **** 			portYIELD_WITHIN_API();
 757              		.loc 1 1114 0
 758 0080 064B     		ldr	r3, .L39+4
 759 0082 4FF08052 		mov	r2, #268435456
 760 0086 1A60     		str	r2, [r3]
 761              	@ 1114 "..\..\..\Source\tasks.c" 1
 762 0088 BFF34F8F 		dsb
 763              	@ 0 "" 2
 764              	@ 1114 "..\..\..\Source\tasks.c" 1
 765 008c BFF36F8F 		isb
 766              	@ 0 "" 2
 767              		.thumb
 768              	.L33:
1115:..\..\..\Source/tasks.c **** 		}
1116:..\..\..\Source/tasks.c **** 		else
1117:..\..\..\Source/tasks.c **** 		{
1118:..\..\..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1119:..\..\..\Source/tasks.c **** 		}
1120:..\..\..\Source/tasks.c **** 	}
 769              		.loc 1 1120 0
 770 0090 1837     		adds	r7, r7, #24
 771              		.cfi_def_cfa_offset 8
 772 0092 BD46     		mov	sp, r7
 773              		.cfi_def_cfa_register 13
 774              		@ sp needed
 775 0094 80BD     		pop	{r7, pc}
 776              	.L40:
 777 0096 00BF     		.align	2
 778              	.L39:
 779 0098 DC000000 		.word	xTickCount
 780 009c 04ED00E0 		.word	-536810236
 781              		.cfi_endproc
 782              	.LFE72:
 783              		.size	vTaskDelayUntil, .-vTaskDelayUntil
 784              		.section	.text.vTaskDelay,"ax",%progbits
 785              		.align	2
 786              		.global	vTaskDelay
 787              		.thumb
 788              		.thumb_func
 789              		.type	vTaskDelay, %function
 790              	vTaskDelay:
 791              	.LFB73:
1121:..\..\..\Source/tasks.c **** 
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 35


1122:..\..\..\Source/tasks.c **** #endif /* INCLUDE_vTaskDelayUntil */
1123:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
1124:..\..\..\Source/tasks.c **** 
1125:..\..\..\Source/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
1126:..\..\..\Source/tasks.c **** 
1127:..\..\..\Source/tasks.c **** 	void vTaskDelay( const TickType_t xTicksToDelay )
1128:..\..\..\Source/tasks.c **** 	{
 792              		.loc 1 1128 0
 793              		.cfi_startproc
 794              		@ args = 0, pretend = 0, frame = 16
 795              		@ frame_needed = 1, uses_anonymous_args = 0
 796 0000 80B5     		push	{r7, lr}
 797              		.cfi_def_cfa_offset 8
 798              		.cfi_offset 7, -8
 799              		.cfi_offset 14, -4
 800 0002 84B0     		sub	sp, sp, #16
 801              		.cfi_def_cfa_offset 24
 802 0004 00AF     		add	r7, sp, #0
 803              		.cfi_def_cfa_register 7
 804 0006 7860     		str	r0, [r7, #4]
1129:..\..\..\Source/tasks.c **** 	BaseType_t xAlreadyYielded = pdFALSE;
 805              		.loc 1 1129 0
 806 0008 0023     		movs	r3, #0
 807 000a FB60     		str	r3, [r7, #12]
1130:..\..\..\Source/tasks.c **** 
1131:..\..\..\Source/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
1132:..\..\..\Source/tasks.c **** 		if( xTicksToDelay > ( TickType_t ) 0U )
 808              		.loc 1 1132 0
 809 000c 7B68     		ldr	r3, [r7, #4]
 810 000e 002B     		cmp	r3, #0
 811 0010 08D0     		beq	.L42
1133:..\..\..\Source/tasks.c **** 		{
1134:..\..\..\Source/tasks.c **** 			configASSERT( uxSchedulerSuspended == 0 );
1135:..\..\..\Source/tasks.c **** 			vTaskSuspendAll();
 812              		.loc 1 1135 0
 813 0012 FFF7FEFF 		bl	vTaskSuspendAll
1136:..\..\..\Source/tasks.c **** 			{
1137:..\..\..\Source/tasks.c **** 				traceTASK_DELAY();
1138:..\..\..\Source/tasks.c **** 
1139:..\..\..\Source/tasks.c **** 				/* A task that is removed from the event list while the
1140:..\..\..\Source/tasks.c **** 				scheduler is suspended will not get placed in the ready
1141:..\..\..\Source/tasks.c **** 				list or removed from the blocked list until the scheduler
1142:..\..\..\Source/tasks.c **** 				is resumed.
1143:..\..\..\Source/tasks.c **** 
1144:..\..\..\Source/tasks.c **** 				This task cannot be in an event list as it is the currently
1145:..\..\..\Source/tasks.c **** 				executing task. */
1146:..\..\..\Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 814              		.loc 1 1146 0
 815 0016 7868     		ldr	r0, [r7, #4]
 816 0018 0021     		movs	r1, #0
 817 001a FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
1147:..\..\..\Source/tasks.c **** 			}
1148:..\..\..\Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 818              		.loc 1 1148 0
 819 001e FFF7FEFF 		bl	xTaskResumeAll
 820 0022 F860     		str	r0, [r7, #12]
 821              	.L42:
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 36


1149:..\..\..\Source/tasks.c **** 		}
1150:..\..\..\Source/tasks.c **** 		else
1151:..\..\..\Source/tasks.c **** 		{
1152:..\..\..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1153:..\..\..\Source/tasks.c **** 		}
1154:..\..\..\Source/tasks.c **** 
1155:..\..\..\Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1156:..\..\..\Source/tasks.c **** 		have put ourselves to sleep. */
1157:..\..\..\Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 822              		.loc 1 1157 0
 823 0024 FB68     		ldr	r3, [r7, #12]
 824 0026 002B     		cmp	r3, #0
 825 0028 07D1     		bne	.L41
1158:..\..\..\Source/tasks.c **** 		{
1159:..\..\..\Source/tasks.c **** 			portYIELD_WITHIN_API();
 826              		.loc 1 1159 0
 827 002a 054B     		ldr	r3, .L44
 828 002c 4FF08052 		mov	r2, #268435456
 829 0030 1A60     		str	r2, [r3]
 830              	@ 1159 "..\..\..\Source\tasks.c" 1
 831 0032 BFF34F8F 		dsb
 832              	@ 0 "" 2
 833              	@ 1159 "..\..\..\Source\tasks.c" 1
 834 0036 BFF36F8F 		isb
 835              	@ 0 "" 2
 836              		.thumb
 837              	.L41:
1160:..\..\..\Source/tasks.c **** 		}
1161:..\..\..\Source/tasks.c **** 		else
1162:..\..\..\Source/tasks.c **** 		{
1163:..\..\..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1164:..\..\..\Source/tasks.c **** 		}
1165:..\..\..\Source/tasks.c **** 	}
 838              		.loc 1 1165 0
 839 003a 1037     		adds	r7, r7, #16
 840              		.cfi_def_cfa_offset 8
 841 003c BD46     		mov	sp, r7
 842              		.cfi_def_cfa_register 13
 843              		@ sp needed
 844 003e 80BD     		pop	{r7, pc}
 845              	.L45:
 846              		.align	2
 847              	.L44:
 848 0040 04ED00E0 		.word	-536810236
 849              		.cfi_endproc
 850              	.LFE73:
 851              		.size	vTaskDelay, .-vTaskDelay
 852              		.section	.text.eTaskGetState,"ax",%progbits
 853              		.align	2
 854              		.global	eTaskGetState
 855              		.thumb
 856              		.thumb_func
 857              		.type	eTaskGetState, %function
 858              	eTaskGetState:
 859              	.LFB74:
1166:..\..\..\Source/tasks.c **** 
1167:..\..\..\Source/tasks.c **** #endif /* INCLUDE_vTaskDelay */
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 37


1168:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
1169:..\..\..\Source/tasks.c **** 
1170:..\..\..\Source/tasks.c **** #if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) )
1171:..\..\..\Source/tasks.c **** 
1172:..\..\..\Source/tasks.c **** 	eTaskState eTaskGetState( TaskHandle_t xTask )
1173:..\..\..\Source/tasks.c **** 	{
 860              		.loc 1 1173 0
 861              		.cfi_startproc
 862              		@ args = 0, pretend = 0, frame = 24
 863              		@ frame_needed = 1, uses_anonymous_args = 0
 864 0000 80B5     		push	{r7, lr}
 865              		.cfi_def_cfa_offset 8
 866              		.cfi_offset 7, -8
 867              		.cfi_offset 14, -4
 868 0002 86B0     		sub	sp, sp, #24
 869              		.cfi_def_cfa_offset 32
 870 0004 00AF     		add	r7, sp, #0
 871              		.cfi_def_cfa_register 7
 872 0006 7860     		str	r0, [r7, #4]
1174:..\..\..\Source/tasks.c **** 	eTaskState eReturn;
1175:..\..\..\Source/tasks.c **** 	List_t *pxStateList;
1176:..\..\..\Source/tasks.c **** 	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
 873              		.loc 1 1176 0
 874 0008 7B68     		ldr	r3, [r7, #4]
 875 000a 3B61     		str	r3, [r7, #16]
1177:..\..\..\Source/tasks.c **** 
1178:..\..\..\Source/tasks.c **** 		configASSERT( pxTCB );
1179:..\..\..\Source/tasks.c **** 
1180:..\..\..\Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
 876              		.loc 1 1180 0
 877 000c 1D4B     		ldr	r3, .L57
 878 000e 1B68     		ldr	r3, [r3]
 879 0010 3A69     		ldr	r2, [r7, #16]
 880 0012 9A42     		cmp	r2, r3
 881 0014 02D1     		bne	.L47
1181:..\..\..\Source/tasks.c **** 		{
1182:..\..\..\Source/tasks.c **** 			/* The task calling this function is querying its own state. */
1183:..\..\..\Source/tasks.c **** 			eReturn = eRunning;
 882              		.loc 1 1183 0
 883 0016 0023     		movs	r3, #0
 884 0018 FB75     		strb	r3, [r7, #23]
 885 001a 2DE0     		b	.L48
 886              	.L47:
1184:..\..\..\Source/tasks.c **** 		}
1185:..\..\..\Source/tasks.c **** 		else
1186:..\..\..\Source/tasks.c **** 		{
1187:..\..\..\Source/tasks.c **** 			taskENTER_CRITICAL();
 887              		.loc 1 1187 0
 888 001c FFF7FEFF 		bl	vPortEnterCritical
1188:..\..\..\Source/tasks.c **** 			{
1189:..\..\..\Source/tasks.c **** 				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
 889              		.loc 1 1189 0
 890 0020 3B69     		ldr	r3, [r7, #16]
 891 0022 5B69     		ldr	r3, [r3, #20]
 892 0024 FB60     		str	r3, [r7, #12]
1190:..\..\..\Source/tasks.c **** 			}
1191:..\..\..\Source/tasks.c **** 			taskEXIT_CRITICAL();
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 38


 893              		.loc 1 1191 0
 894 0026 FFF7FEFF 		bl	vPortExitCritical
1192:..\..\..\Source/tasks.c **** 
1193:..\..\..\Source/tasks.c **** 			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
 895              		.loc 1 1193 0
 896 002a 174B     		ldr	r3, .L57+4
 897 002c 1B68     		ldr	r3, [r3]
 898 002e FA68     		ldr	r2, [r7, #12]
 899 0030 9A42     		cmp	r2, r3
 900 0032 04D0     		beq	.L49
 901              		.loc 1 1193 0 is_stmt 0 discriminator 1
 902 0034 154B     		ldr	r3, .L57+8
 903 0036 1B68     		ldr	r3, [r3]
 904 0038 FA68     		ldr	r2, [r7, #12]
 905 003a 9A42     		cmp	r2, r3
 906 003c 02D1     		bne	.L50
 907              	.L49:
1194:..\..\..\Source/tasks.c **** 			{
1195:..\..\..\Source/tasks.c **** 				/* The task being queried is referenced from one of the Blocked
1196:..\..\..\Source/tasks.c **** 				lists. */
1197:..\..\..\Source/tasks.c **** 				eReturn = eBlocked;
 908              		.loc 1 1197 0 is_stmt 1
 909 003e 0223     		movs	r3, #2
 910 0040 FB75     		strb	r3, [r7, #23]
 911 0042 19E0     		b	.L48
 912              	.L50:
1198:..\..\..\Source/tasks.c **** 			}
1199:..\..\..\Source/tasks.c **** 
1200:..\..\..\Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1201:..\..\..\Source/tasks.c **** 				else if( pxStateList == &xSuspendedTaskList )
 913              		.loc 1 1201 0
 914 0044 FB68     		ldr	r3, [r7, #12]
 915 0046 124A     		ldr	r2, .L57+12
 916 0048 9342     		cmp	r3, r2
 917 004a 09D1     		bne	.L51
1202:..\..\..\Source/tasks.c **** 				{
1203:..\..\..\Source/tasks.c **** 					/* The task being queried is referenced from the suspended
1204:..\..\..\Source/tasks.c **** 					list.  Is it genuinely suspended or is it block
1205:..\..\..\Source/tasks.c **** 					indefinitely? */
1206:..\..\..\Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
 918              		.loc 1 1206 0
 919 004c 3B69     		ldr	r3, [r7, #16]
 920 004e 9B6A     		ldr	r3, [r3, #40]
 921 0050 002B     		cmp	r3, #0
 922 0052 02D1     		bne	.L52
1207:..\..\..\Source/tasks.c **** 					{
1208:..\..\..\Source/tasks.c **** 						eReturn = eSuspended;
 923              		.loc 1 1208 0
 924 0054 0323     		movs	r3, #3
 925 0056 FB75     		strb	r3, [r7, #23]
 926 0058 0EE0     		b	.L48
 927              	.L52:
1209:..\..\..\Source/tasks.c **** 					}
1210:..\..\..\Source/tasks.c **** 					else
1211:..\..\..\Source/tasks.c **** 					{
1212:..\..\..\Source/tasks.c **** 						eReturn = eBlocked;
 928              		.loc 1 1212 0
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 39


 929 005a 0223     		movs	r3, #2
 930 005c FB75     		strb	r3, [r7, #23]
 931 005e 0BE0     		b	.L48
 932              	.L51:
1213:..\..\..\Source/tasks.c **** 					}
1214:..\..\..\Source/tasks.c **** 				}
1215:..\..\..\Source/tasks.c **** 			#endif
1216:..\..\..\Source/tasks.c **** 
1217:..\..\..\Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1218:..\..\..\Source/tasks.c **** 				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
 933              		.loc 1 1218 0
 934 0060 FB68     		ldr	r3, [r7, #12]
 935 0062 0C4A     		ldr	r2, .L57+16
 936 0064 9342     		cmp	r3, r2
 937 0066 02D0     		beq	.L54
 938              		.loc 1 1218 0 is_stmt 0 discriminator 1
 939 0068 FB68     		ldr	r3, [r7, #12]
 940 006a 002B     		cmp	r3, #0
 941 006c 02D1     		bne	.L55
 942              	.L54:
1219:..\..\..\Source/tasks.c **** 				{
1220:..\..\..\Source/tasks.c **** 					/* The task being queried is referenced from the deleted
1221:..\..\..\Source/tasks.c **** 					tasks list, or it is not referenced from any lists at
1222:..\..\..\Source/tasks.c **** 					all. */
1223:..\..\..\Source/tasks.c **** 					eReturn = eDeleted;
 943              		.loc 1 1223 0 is_stmt 1
 944 006e 0423     		movs	r3, #4
 945 0070 FB75     		strb	r3, [r7, #23]
 946 0072 01E0     		b	.L48
 947              	.L55:
1224:..\..\..\Source/tasks.c **** 				}
1225:..\..\..\Source/tasks.c **** 			#endif
1226:..\..\..\Source/tasks.c **** 
1227:..\..\..\Source/tasks.c **** 			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
1228:..\..\..\Source/tasks.c **** 			{
1229:..\..\..\Source/tasks.c **** 				/* If the task is not in any other state, it must be in the
1230:..\..\..\Source/tasks.c **** 				Ready (including pending ready) state. */
1231:..\..\..\Source/tasks.c **** 				eReturn = eReady;
 948              		.loc 1 1231 0
 949 0074 0123     		movs	r3, #1
 950 0076 FB75     		strb	r3, [r7, #23]
 951              	.L48:
1232:..\..\..\Source/tasks.c **** 			}
1233:..\..\..\Source/tasks.c **** 		}
1234:..\..\..\Source/tasks.c **** 
1235:..\..\..\Source/tasks.c **** 		return eReturn;
 952              		.loc 1 1235 0
 953 0078 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
1236:..\..\..\Source/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 954              		.loc 1 1236 0
 955 007a 1846     		mov	r0, r3
 956 007c 1837     		adds	r7, r7, #24
 957              		.cfi_def_cfa_offset 8
 958 007e BD46     		mov	sp, r7
 959              		.cfi_def_cfa_register 13
 960              		@ sp needed
 961 0080 80BD     		pop	{r7, pc}
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 40


 962              	.L58:
 963 0082 00BF     		.align	2
 964              	.L57:
 965 0084 00000000 		.word	pxCurrentTCB
 966 0088 90000000 		.word	pxDelayedTaskList
 967 008c 94000000 		.word	pxOverflowDelayedTaskList
 968 0090 C4000000 		.word	xSuspendedTaskList
 969 0094 AC000000 		.word	xTasksWaitingTermination
 970              		.cfi_endproc
 971              	.LFE74:
 972              		.size	eTaskGetState, .-eTaskGetState
 973              		.section	.text.uxTaskPriorityGet,"ax",%progbits
 974              		.align	2
 975              		.global	uxTaskPriorityGet
 976              		.thumb
 977              		.thumb_func
 978              		.type	uxTaskPriorityGet, %function
 979              	uxTaskPriorityGet:
 980              	.LFB75:
1237:..\..\..\Source/tasks.c **** 
1238:..\..\..\Source/tasks.c **** #endif /* INCLUDE_eTaskGetState */
1239:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
1240:..\..\..\Source/tasks.c **** 
1241:..\..\..\Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1242:..\..\..\Source/tasks.c **** 
1243:..\..\..\Source/tasks.c **** 	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
1244:..\..\..\Source/tasks.c **** 	{
 981              		.loc 1 1244 0
 982              		.cfi_startproc
 983              		@ args = 0, pretend = 0, frame = 16
 984              		@ frame_needed = 1, uses_anonymous_args = 0
 985 0000 80B5     		push	{r7, lr}
 986              		.cfi_def_cfa_offset 8
 987              		.cfi_offset 7, -8
 988              		.cfi_offset 14, -4
 989 0002 84B0     		sub	sp, sp, #16
 990              		.cfi_def_cfa_offset 24
 991 0004 00AF     		add	r7, sp, #0
 992              		.cfi_def_cfa_register 7
 993 0006 7860     		str	r0, [r7, #4]
1245:..\..\..\Source/tasks.c **** 	TCB_t *pxTCB;
1246:..\..\..\Source/tasks.c **** 	UBaseType_t uxReturn;
1247:..\..\..\Source/tasks.c **** 
1248:..\..\..\Source/tasks.c **** 		taskENTER_CRITICAL();
 994              		.loc 1 1248 0
 995 0008 FFF7FEFF 		bl	vPortEnterCritical
1249:..\..\..\Source/tasks.c **** 		{
1250:..\..\..\Source/tasks.c **** 			/* If null is passed in here then it is the priority of the that
1251:..\..\..\Source/tasks.c **** 			called uxTaskPriorityGet() that is being queried. */
1252:..\..\..\Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
 996              		.loc 1 1252 0
 997 000c 7B68     		ldr	r3, [r7, #4]
 998 000e 002B     		cmp	r3, #0
 999 0010 02D1     		bne	.L60
 1000              		.loc 1 1252 0 is_stmt 0 discriminator 1
 1001 0012 074B     		ldr	r3, .L63
 1002 0014 1B68     		ldr	r3, [r3]
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 41


 1003 0016 00E0     		b	.L61
 1004              	.L60:
 1005              		.loc 1 1252 0 discriminator 2
 1006 0018 7B68     		ldr	r3, [r7, #4]
 1007              	.L61:
 1008              		.loc 1 1252 0 discriminator 4
 1009 001a FB60     		str	r3, [r7, #12]
1253:..\..\..\Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 1010              		.loc 1 1253 0 is_stmt 1 discriminator 4
 1011 001c FB68     		ldr	r3, [r7, #12]
 1012 001e DB6A     		ldr	r3, [r3, #44]
 1013 0020 BB60     		str	r3, [r7, #8]
1254:..\..\..\Source/tasks.c **** 		}
1255:..\..\..\Source/tasks.c **** 		taskEXIT_CRITICAL();
 1014              		.loc 1 1255 0 discriminator 4
 1015 0022 FFF7FEFF 		bl	vPortExitCritical
1256:..\..\..\Source/tasks.c **** 
1257:..\..\..\Source/tasks.c **** 		return uxReturn;
 1016              		.loc 1 1257 0 discriminator 4
 1017 0026 BB68     		ldr	r3, [r7, #8]
1258:..\..\..\Source/tasks.c **** 	}
 1018              		.loc 1 1258 0 discriminator 4
 1019 0028 1846     		mov	r0, r3
 1020 002a 1037     		adds	r7, r7, #16
 1021              		.cfi_def_cfa_offset 8
 1022 002c BD46     		mov	sp, r7
 1023              		.cfi_def_cfa_register 13
 1024              		@ sp needed
 1025 002e 80BD     		pop	{r7, pc}
 1026              	.L64:
 1027              		.align	2
 1028              	.L63:
 1029 0030 00000000 		.word	pxCurrentTCB
 1030              		.cfi_endproc
 1031              	.LFE75:
 1032              		.size	uxTaskPriorityGet, .-uxTaskPriorityGet
 1033              		.section	.text.uxTaskPriorityGetFromISR,"ax",%progbits
 1034              		.align	2
 1035              		.global	uxTaskPriorityGetFromISR
 1036              		.thumb
 1037              		.thumb_func
 1038              		.type	uxTaskPriorityGetFromISR, %function
 1039              	uxTaskPriorityGetFromISR:
 1040              	.LFB76:
1259:..\..\..\Source/tasks.c **** 
1260:..\..\..\Source/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1261:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
1262:..\..\..\Source/tasks.c **** 
1263:..\..\..\Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1264:..\..\..\Source/tasks.c **** 
1265:..\..\..\Source/tasks.c **** 	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
1266:..\..\..\Source/tasks.c **** 	{
 1041              		.loc 1 1266 0
 1042              		.cfi_startproc
 1043              		@ args = 0, pretend = 0, frame = 32
 1044              		@ frame_needed = 1, uses_anonymous_args = 0
 1045              		@ link register save eliminated.
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 42


 1046 0000 80B4     		push	{r7}
 1047              		.cfi_def_cfa_offset 4
 1048              		.cfi_offset 7, -4
 1049 0002 89B0     		sub	sp, sp, #36
 1050              		.cfi_def_cfa_offset 40
 1051 0004 00AF     		add	r7, sp, #0
 1052              		.cfi_def_cfa_register 7
 1053 0006 7860     		str	r0, [r7, #4]
 1054              	.LBB29:
 1055              	.LBB30:
 1056              		.file 2 "../../../Source/portable/GCC/ARM_CM3/portmacro.h"
   1:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** /*
   2:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     FreeRTOS V9.0.0rc2 - Copyright (C) 2016 Real Time Engineers Ltd.
   3:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     All rights reserved
   4:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
   5:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
   7:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     This file is part of the FreeRTOS distribution.
   8:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
   9:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  10:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     the terms of the GNU General Public License (version 2) as published by the
  11:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
  12:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
  13:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     ***************************************************************************
  14:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     >>!   NOTE: The modification to the GPL is included to allow you to     !<<
  15:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     >>!   distribute a combined work that includes FreeRTOS without being   !<<
  16:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     >>!   obliged to provide the source code for proprietary components     !<<
  17:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     >>!   outside of the FreeRTOS kernel.                                   !<<
  18:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     ***************************************************************************
  19:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
  20:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  21:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  22:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     FOR A PARTICULAR PURPOSE.  Full license text is available on the following
  23:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     link: http://www.freertos.org/a00114.html
  24:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
  25:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     ***************************************************************************
  26:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****      *                                                                       *
  27:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****      *    FreeRTOS provides completely free yet professionally developed,    *
  28:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****      *    robust, strictly quality controlled, supported, and cross          *
  29:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****      *    platform software that is more than just the market leader, it     *
  30:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****      *    is the industry's de facto standard.                               *
  31:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****      *                                                                       *
  32:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****      *    Help yourself get started quickly while simultaneously helping     *
  33:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****      *    to support the FreeRTOS project by purchasing a FreeRTOS           *
  34:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****      *    tutorial book, reference manual, or both:                          *
  35:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****      *    http://www.FreeRTOS.org/Documentation                              *
  36:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****      *                                                                       *
  37:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     ***************************************************************************
  38:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
  39:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
  40:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     the FAQ page "My application does not run, what could be wrong?".  Have you
  41:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     defined configASSERT()?
  42:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
  43:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     http://www.FreeRTOS.org/support - In return for receiving this top quality
  44:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     embedded software for free we request you assist our global community by
  45:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     participating in the support forum.
  46:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 43


  47:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     http://www.FreeRTOS.org/training - Investing in training allows your team to
  48:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     be as productive as possible as early as possible.  Now you can receive
  49:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
  50:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     Ltd, and the world's leading authority on the world's leading RTOS.
  51:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
  52:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  53:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  54:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  55:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
  56:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
  57:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
  58:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
  59:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
  60:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
  61:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     licenses offer ticketed support, indemnification and commercial middleware.
  62:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
  63:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  64:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     engineered and independently SIL3 certified version for use in safety and
  65:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     mission critical applications that require provable dependability.
  66:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
  67:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****     1 tab == 4 spaces!
  68:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** */
  69:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
  70:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
  71:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #ifndef PORTMACRO_H
  72:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #define PORTMACRO_H
  73:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
  74:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #ifdef __cplusplus
  75:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** extern "C" {
  76:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #endif
  77:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
  78:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------
  79:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****  * Port specific definitions.
  80:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****  *
  81:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****  * The settings in this file configure FreeRTOS correctly for the
  82:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****  * given hardware and compiler.
  83:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****  *
  84:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****  * These settings should not be altered.
  85:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****  *-----------------------------------------------------------
  86:../../../Source/portable/GCC/ARM_CM3/portmacro.h ****  */
  87:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
  88:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** /* Type definitions. */
  89:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #define portCHAR		char
  90:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #define portFLOAT		float
  91:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #define portDOUBLE		double
  92:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #define portLONG		long
  93:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #define portSHORT		short
  94:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #define portSTACK_TYPE	uint32_t
  95:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #define portBASE_TYPE	long
  96:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
  97:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** typedef portSTACK_TYPE StackType_t;
  98:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** typedef long BaseType_t;
  99:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** typedef unsigned long UBaseType_t;
 100:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
 101:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #if( configUSE_16_BIT_TICKS == 1 )
 102:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	typedef uint16_t TickType_t;
 103:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	#define portMAX_DELAY ( TickType_t ) 0xffff
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 44


 104:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #else
 105:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	typedef uint32_t TickType_t;
 106:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
 107:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
 108:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
 109:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	not need to be guarded with a critical section. */
 110:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	#define portTICK_TYPE_IS_ATOMIC 1
 111:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #endif
 112:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 113:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
 114:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** /* Architecture specifics. */
 115:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #define portSTACK_GROWTH			( -1 )
 116:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
 117:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #define portBYTE_ALIGNMENT			8
 118:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 119:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
 120:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** /* Scheduler utilities. */
 121:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #define portYIELD() 															\
 122:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** {																				\
 123:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	/* Set a PendSV to request a context switch. */								\
 124:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;								\
 125:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 																				\
 126:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	/* Barriers are normally not required but do ensure the code is completely	\
 127:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	within the specified behaviour for the architecture. */						\
 128:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	__asm volatile( "dsb" );													\
 129:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	__asm volatile( "isb" );													\
 130:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** }
 131:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
 132:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
 133:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
 134:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired != pdFALSE ) portYIELD()
 135:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
 136:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 137:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
 138:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** /* Critical section management. */
 139:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** extern void vPortEnterCritical( void );
 140:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** extern void vPortExitCritical( void );
 141:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortRaiseBASEPRI()
 142:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortSetBASEPRI(x)
 143:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #define portDISABLE_INTERRUPTS()				vPortRaiseBASEPRI()
 144:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #define portENABLE_INTERRUPTS()					vPortSetBASEPRI(0)
 145:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #define portENTER_CRITICAL()					vPortEnterCritical()
 146:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #define portEXIT_CRITICAL()						vPortExitCritical()
 147:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
 148:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 149:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
 150:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** /* Task function macros as described on the FreeRTOS.org WEB site.  These are
 151:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** not necessary for to use this port.  They are defined so the common demo files
 152:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** (which build with all the ports) will build. */
 153:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
 154:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
 155:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 156:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
 157:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** /* Tickless idle/low power functionality. */
 158:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #ifndef portSUPPRESS_TICKS_AND_SLEEP
 159:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
 160:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdl
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 45


 161:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #endif
 162:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 163:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
 164:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** /* Architecture specific optimisations. */
 165:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
 166:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
 167:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #endif
 168:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
 169:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
 170:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
 171:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	/* Generic helper function. */
 172:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitma
 173:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	{
 174:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	uint8_t ucReturn;
 175:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
 176:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
 177:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 		return ucReturn;
 178:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	}
 179:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
 180:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	/* Check the configuration. */
 181:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	#if( configMAX_PRIORITIES > 32 )
 182:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is 
 183:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	#endif
 184:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
 185:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	/* Store/clear the ready priorities in a bit map. */
 186:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL 
 187:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL 
 188:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
 189:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	/*-----------------------------------------------------------*/
 190:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
 191:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( ui
 192:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
 193:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 194:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
 195:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 196:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
 197:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #ifdef configASSERT
 198:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	void vPortValidateInterruptPriority( void );
 199:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
 200:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #endif
 201:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
 202:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** /* portNOP() is not required by this port. */
 203:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #define portNOP()
 204:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
 205:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #define portINLINE	__inline
 206:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
 207:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #ifndef portFORCE_INLINE
 208:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	#define portFORCE_INLINE inline __attribute__(( always_inline))
 209:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** #endif
 210:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
 211:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
 212:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** {
 213:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** uint32_t ulCurrentInterrupt;
 214:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** BaseType_t xReturn;
 215:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
 216:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	/* Obtain the number of the currently executing interrupt. */
 217:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 46


 218:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
 219:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	if( ulCurrentInterrupt == 0 )
 220:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	{
 221:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 		xReturn = pdFALSE;
 222:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	}
 223:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	else
 224:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	{
 225:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 		xReturn = pdTRUE;
 226:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	}
 227:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
 228:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	return xReturn;
 229:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** }
 230:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
 231:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 232:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
 233:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** portFORCE_INLINE static void vPortRaiseBASEPRI( void )
 234:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** {
 235:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** uint32_t ulNewBASEPRI;
 236:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
 237:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	__asm volatile
 238:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	(
 239:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 		"	mov %0, %1												\n"	\
 240:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 		"	msr basepri, %0											\n" \
 241:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 		"	isb														\n" \
 242:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 		"	dsb														\n" \
 243:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 		:"=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY )
 244:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	);
 245:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** }
 246:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
 247:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 248:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
 249:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
 250:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** {
 251:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** uint32_t ulOriginalBASEPRI, ulNewBASEPRI;
 252:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
 253:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	__asm volatile
 1057              		.loc 2 253 0
 1058              	@ 253 "../../../Source/portable/GCC/ARM_CM3/portmacro.h" 1
 1059 0008 EFF31182 			mrs r2, basepri											
 1060 000c 4FF0A003 		mov r3, #160												
 1061 0010 83F31188 		msr basepri, r3											
 1062 0014 BFF36F8F 		isb														
 1063 0018 BFF34F8F 		dsb														
 1064              	
 1065              	@ 0 "" 2
 1066              		.thumb
 1067 001c 3A61     		str	r2, [r7, #16]
 1068 001e FB60     		str	r3, [r7, #12]
 254:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	(
 255:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 		"	mrs %0, basepri											\n" \
 256:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 		"	mov %1, %2												\n"	\
 257:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 		"	msr basepri, %1											\n" \
 258:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 		"	isb														\n" \
 259:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 		"	dsb														\n" \
 260:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY )
 261:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	);
 262:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 47


 263:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	/* This return will not be reached but is necessary to prevent compiler
 264:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	warnings. */
 265:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	return ulOriginalBASEPRI;
 1069              		.loc 2 265 0
 1070 0020 3B69     		ldr	r3, [r7, #16]
 1071              	.LBE30:
 1072              	.LBE29:
1267:..\..\..\Source/tasks.c **** 	TCB_t *pxTCB;
1268:..\..\..\Source/tasks.c **** 	UBaseType_t uxReturn, uxSavedInterruptState;
1269:..\..\..\Source/tasks.c **** 
1270:..\..\..\Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1271:..\..\..\Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1272:..\..\..\Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1273:..\..\..\Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1274:..\..\..\Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1275:..\..\..\Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
1276:..\..\..\Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1277:..\..\..\Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1278:..\..\..\Source/tasks.c **** 		been assigned a priority above the configured maximum system call
1279:..\..\..\Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1280:..\..\..\Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1281:..\..\..\Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1282:..\..\..\Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1283:..\..\..\Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1284:..\..\..\Source/tasks.c **** 		provided on the following link:
1285:..\..\..\Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1286:..\..\..\Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1287:..\..\..\Source/tasks.c **** 
1288:..\..\..\Source/tasks.c **** 		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
 1073              		.loc 1 1288 0
 1074 0022 FB61     		str	r3, [r7, #28]
1289:..\..\..\Source/tasks.c **** 		{
1290:..\..\..\Source/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1291:..\..\..\Source/tasks.c **** 			task that is being queried. */
1292:..\..\..\Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
 1075              		.loc 1 1292 0
 1076 0024 7B68     		ldr	r3, [r7, #4]
 1077 0026 002B     		cmp	r3, #0
 1078 0028 02D1     		bne	.L67
 1079              		.loc 1 1292 0 is_stmt 0 discriminator 1
 1080 002a 0A4B     		ldr	r3, .L70
 1081 002c 1B68     		ldr	r3, [r3]
 1082 002e 00E0     		b	.L68
 1083              	.L67:
 1084              		.loc 1 1292 0 discriminator 2
 1085 0030 7B68     		ldr	r3, [r7, #4]
 1086              	.L68:
 1087              		.loc 1 1292 0 discriminator 4
 1088 0032 BB61     		str	r3, [r7, #24]
1293:..\..\..\Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 1089              		.loc 1 1293 0 is_stmt 1 discriminator 4
 1090 0034 BB69     		ldr	r3, [r7, #24]
 1091 0036 DB6A     		ldr	r3, [r3, #44]
 1092 0038 7B61     		str	r3, [r7, #20]
 1093 003a FB69     		ldr	r3, [r7, #28]
 1094 003c BB60     		str	r3, [r7, #8]
 1095              	.LBB31:
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 48


 1096              	.LBB32:
 266:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** }
 267:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 268:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 
 269:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
 270:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** {
 271:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	__asm volatile
 1097              		.loc 2 271 0 discriminator 4
 1098 003e BB68     		ldr	r3, [r7, #8]
 1099              	@ 271 "../../../Source/portable/GCC/ARM_CM3/portmacro.h" 1
 1100 0040 83F31188 			msr basepri, r3	
 1101              	@ 0 "" 2
 1102              		.thumb
 1103              	.LBE32:
 1104              	.LBE31:
1294:..\..\..\Source/tasks.c **** 		}
1295:..\..\..\Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
1296:..\..\..\Source/tasks.c **** 
1297:..\..\..\Source/tasks.c **** 		return uxReturn;
 1105              		.loc 1 1297 0 discriminator 4
 1106 0044 7B69     		ldr	r3, [r7, #20]
1298:..\..\..\Source/tasks.c **** 	}
 1107              		.loc 1 1298 0 discriminator 4
 1108 0046 1846     		mov	r0, r3
 1109 0048 2437     		adds	r7, r7, #36
 1110              		.cfi_def_cfa_offset 4
 1111 004a BD46     		mov	sp, r7
 1112              		.cfi_def_cfa_register 13
 1113              		@ sp needed
 1114 004c 5DF8047B 		ldr	r7, [sp], #4
 1115              		.cfi_restore 7
 1116              		.cfi_def_cfa_offset 0
 1117 0050 7047     		bx	lr
 1118              	.L71:
 1119 0052 00BF     		.align	2
 1120              	.L70:
 1121 0054 00000000 		.word	pxCurrentTCB
 1122              		.cfi_endproc
 1123              	.LFE76:
 1124              		.size	uxTaskPriorityGetFromISR, .-uxTaskPriorityGetFromISR
 1125              		.section	.text.vTaskPrioritySet,"ax",%progbits
 1126              		.align	2
 1127              		.global	vTaskPrioritySet
 1128              		.thumb
 1129              		.thumb_func
 1130              		.type	vTaskPrioritySet, %function
 1131              	vTaskPrioritySet:
 1132              	.LFB77:
1299:..\..\..\Source/tasks.c **** 
1300:..\..\..\Source/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1301:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
1302:..\..\..\Source/tasks.c **** 
1303:..\..\..\Source/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
1304:..\..\..\Source/tasks.c **** 
1305:..\..\..\Source/tasks.c **** 	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
1306:..\..\..\Source/tasks.c **** 	{
 1133              		.loc 1 1306 0
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 49


 1134              		.cfi_startproc
 1135              		@ args = 0, pretend = 0, frame = 24
 1136              		@ frame_needed = 1, uses_anonymous_args = 0
 1137 0000 80B5     		push	{r7, lr}
 1138              		.cfi_def_cfa_offset 8
 1139              		.cfi_offset 7, -8
 1140              		.cfi_offset 14, -4
 1141 0002 86B0     		sub	sp, sp, #24
 1142              		.cfi_def_cfa_offset 32
 1143 0004 00AF     		add	r7, sp, #0
 1144              		.cfi_def_cfa_register 7
 1145 0006 7860     		str	r0, [r7, #4]
 1146 0008 3960     		str	r1, [r7]
1307:..\..\..\Source/tasks.c **** 	TCB_t *pxTCB;
1308:..\..\..\Source/tasks.c **** 	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
1309:..\..\..\Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
 1147              		.loc 1 1309 0
 1148 000a 0023     		movs	r3, #0
 1149 000c 7B61     		str	r3, [r7, #20]
1310:..\..\..\Source/tasks.c **** 
1311:..\..\..\Source/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
1312:..\..\..\Source/tasks.c **** 
1313:..\..\..\Source/tasks.c **** 		/* Ensure the new priority is valid. */
1314:..\..\..\Source/tasks.c **** 		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 1150              		.loc 1 1314 0
 1151 000e 3B68     		ldr	r3, [r7]
 1152 0010 042B     		cmp	r3, #4
 1153 0012 01D9     		bls	.L73
1315:..\..\..\Source/tasks.c **** 		{
1316:..\..\..\Source/tasks.c **** 			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 1154              		.loc 1 1316 0
 1155 0014 0423     		movs	r3, #4
 1156 0016 3B60     		str	r3, [r7]
 1157              	.L73:
1317:..\..\..\Source/tasks.c **** 		}
1318:..\..\..\Source/tasks.c **** 		else
1319:..\..\..\Source/tasks.c **** 		{
1320:..\..\..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1321:..\..\..\Source/tasks.c **** 		}
1322:..\..\..\Source/tasks.c **** 
1323:..\..\..\Source/tasks.c **** 		taskENTER_CRITICAL();
 1158              		.loc 1 1323 0
 1159 0018 FFF7FEFF 		bl	vPortEnterCritical
1324:..\..\..\Source/tasks.c **** 		{
1325:..\..\..\Source/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1326:..\..\..\Source/tasks.c **** 			task that is being changed. */
1327:..\..\..\Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
 1160              		.loc 1 1327 0
 1161 001c 7B68     		ldr	r3, [r7, #4]
 1162 001e 002B     		cmp	r3, #0
 1163 0020 02D1     		bne	.L74
 1164              		.loc 1 1327 0 is_stmt 0 discriminator 1
 1165 0022 444B     		ldr	r3, .L85
 1166 0024 1B68     		ldr	r3, [r3]
 1167 0026 00E0     		b	.L75
 1168              	.L74:
 1169              		.loc 1 1327 0 discriminator 2
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 50


 1170 0028 7B68     		ldr	r3, [r7, #4]
 1171              	.L75:
 1172              		.loc 1 1327 0 discriminator 4
 1173 002a 3B61     		str	r3, [r7, #16]
1328:..\..\..\Source/tasks.c **** 
1329:..\..\..\Source/tasks.c **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
1330:..\..\..\Source/tasks.c **** 
1331:..\..\..\Source/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
1332:..\..\..\Source/tasks.c **** 			{
1333:..\..\..\Source/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxBasePriority;
 1174              		.loc 1 1333 0 is_stmt 1 discriminator 4
 1175 002c 3B69     		ldr	r3, [r7, #16]
 1176 002e 1B6C     		ldr	r3, [r3, #64]
 1177 0030 FB60     		str	r3, [r7, #12]
1334:..\..\..\Source/tasks.c **** 			}
1335:..\..\..\Source/tasks.c **** 			#else
1336:..\..\..\Source/tasks.c **** 			{
1337:..\..\..\Source/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxPriority;
1338:..\..\..\Source/tasks.c **** 			}
1339:..\..\..\Source/tasks.c **** 			#endif
1340:..\..\..\Source/tasks.c **** 
1341:..\..\..\Source/tasks.c **** 			if( uxCurrentBasePriority != uxNewPriority )
 1178              		.loc 1 1341 0 discriminator 4
 1179 0032 FA68     		ldr	r2, [r7, #12]
 1180 0034 3B68     		ldr	r3, [r7]
 1181 0036 9A42     		cmp	r2, r3
 1182 0038 76D0     		beq	.L76
1342:..\..\..\Source/tasks.c **** 			{
1343:..\..\..\Source/tasks.c **** 				/* The priority change may have readied a task of higher
1344:..\..\..\Source/tasks.c **** 				priority than the calling task. */
1345:..\..\..\Source/tasks.c **** 				if( uxNewPriority > uxCurrentBasePriority )
 1183              		.loc 1 1345 0
 1184 003a 3A68     		ldr	r2, [r7]
 1185 003c FB68     		ldr	r3, [r7, #12]
 1186 003e 9A42     		cmp	r2, r3
 1187 0040 0DD9     		bls	.L77
1346:..\..\..\Source/tasks.c **** 				{
1347:..\..\..\Source/tasks.c **** 					if( pxTCB != pxCurrentTCB )
 1188              		.loc 1 1347 0
 1189 0042 3C4B     		ldr	r3, .L85
 1190 0044 1B68     		ldr	r3, [r3]
 1191 0046 3A69     		ldr	r2, [r7, #16]
 1192 0048 9A42     		cmp	r2, r3
 1193 004a 0FD0     		beq	.L78
1348:..\..\..\Source/tasks.c **** 					{
1349:..\..\..\Source/tasks.c **** 						/* The priority of a task other than the currently
1350:..\..\..\Source/tasks.c **** 						running task is being raised.  Is the priority being
1351:..\..\..\Source/tasks.c **** 						raised above that of the running task? */
1352:..\..\..\Source/tasks.c **** 						if( uxNewPriority >= pxCurrentTCB->uxPriority )
 1194              		.loc 1 1352 0
 1195 004c 394B     		ldr	r3, .L85
 1196 004e 1B68     		ldr	r3, [r3]
 1197 0050 DA6A     		ldr	r2, [r3, #44]
 1198 0052 3B68     		ldr	r3, [r7]
 1199 0054 9A42     		cmp	r2, r3
 1200 0056 09D8     		bhi	.L78
1353:..\..\..\Source/tasks.c **** 						{
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 51


1354:..\..\..\Source/tasks.c **** 							xYieldRequired = pdTRUE;
 1201              		.loc 1 1354 0
 1202 0058 0123     		movs	r3, #1
 1203 005a 7B61     		str	r3, [r7, #20]
 1204 005c 06E0     		b	.L78
 1205              	.L77:
1355:..\..\..\Source/tasks.c **** 						}
1356:..\..\..\Source/tasks.c **** 						else
1357:..\..\..\Source/tasks.c **** 						{
1358:..\..\..\Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
1359:..\..\..\Source/tasks.c **** 						}
1360:..\..\..\Source/tasks.c **** 					}
1361:..\..\..\Source/tasks.c **** 					else
1362:..\..\..\Source/tasks.c **** 					{
1363:..\..\..\Source/tasks.c **** 						/* The priority of the running task is being raised,
1364:..\..\..\Source/tasks.c **** 						but the running task must already be the highest
1365:..\..\..\Source/tasks.c **** 						priority task able to run so no yield is required. */
1366:..\..\..\Source/tasks.c **** 					}
1367:..\..\..\Source/tasks.c **** 				}
1368:..\..\..\Source/tasks.c **** 				else if( pxTCB == pxCurrentTCB )
 1206              		.loc 1 1368 0
 1207 005e 354B     		ldr	r3, .L85
 1208 0060 1B68     		ldr	r3, [r3]
 1209 0062 3A69     		ldr	r2, [r7, #16]
 1210 0064 9A42     		cmp	r2, r3
 1211 0066 01D1     		bne	.L78
1369:..\..\..\Source/tasks.c **** 				{
1370:..\..\..\Source/tasks.c **** 					/* Setting the priority of the running task down means
1371:..\..\..\Source/tasks.c **** 					there may now be another task of higher priority that
1372:..\..\..\Source/tasks.c **** 					is ready to execute. */
1373:..\..\..\Source/tasks.c **** 					xYieldRequired = pdTRUE;
 1212              		.loc 1 1373 0
 1213 0068 0123     		movs	r3, #1
 1214 006a 7B61     		str	r3, [r7, #20]
 1215              	.L78:
1374:..\..\..\Source/tasks.c **** 				}
1375:..\..\..\Source/tasks.c **** 				else
1376:..\..\..\Source/tasks.c **** 				{
1377:..\..\..\Source/tasks.c **** 					/* Setting the priority of any other task down does not
1378:..\..\..\Source/tasks.c **** 					require a yield as the running task must be above the
1379:..\..\..\Source/tasks.c **** 					new priority of the task being modified. */
1380:..\..\..\Source/tasks.c **** 				}
1381:..\..\..\Source/tasks.c **** 
1382:..\..\..\Source/tasks.c **** 				/* Remember the ready list the task might be referenced from
1383:..\..\..\Source/tasks.c **** 				before its uxPriority member is changed so the
1384:..\..\..\Source/tasks.c **** 				taskRESET_READY_PRIORITY() macro can function correctly. */
1385:..\..\..\Source/tasks.c **** 				uxPriorityUsedOnEntry = pxTCB->uxPriority;
 1216              		.loc 1 1385 0
 1217 006c 3B69     		ldr	r3, [r7, #16]
 1218 006e DB6A     		ldr	r3, [r3, #44]
 1219 0070 BB60     		str	r3, [r7, #8]
1386:..\..\..\Source/tasks.c **** 
1387:..\..\..\Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
1388:..\..\..\Source/tasks.c **** 				{
1389:..\..\..\Source/tasks.c **** 					/* Only change the priority being used if the task is not
1390:..\..\..\Source/tasks.c **** 					currently using an inherited priority. */
1391:..\..\..\Source/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 52


 1220              		.loc 1 1391 0
 1221 0072 3B69     		ldr	r3, [r7, #16]
 1222 0074 1A6C     		ldr	r2, [r3, #64]
 1223 0076 3B69     		ldr	r3, [r7, #16]
 1224 0078 DB6A     		ldr	r3, [r3, #44]
 1225 007a 9A42     		cmp	r2, r3
 1226 007c 02D1     		bne	.L79
1392:..\..\..\Source/tasks.c **** 					{
1393:..\..\..\Source/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
 1227              		.loc 1 1393 0
 1228 007e 3B69     		ldr	r3, [r7, #16]
 1229 0080 3A68     		ldr	r2, [r7]
 1230 0082 DA62     		str	r2, [r3, #44]
 1231              	.L79:
1394:..\..\..\Source/tasks.c **** 					}
1395:..\..\..\Source/tasks.c **** 					else
1396:..\..\..\Source/tasks.c **** 					{
1397:..\..\..\Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1398:..\..\..\Source/tasks.c **** 					}
1399:..\..\..\Source/tasks.c **** 
1400:..\..\..\Source/tasks.c **** 					/* The base priority gets set whatever. */
1401:..\..\..\Source/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
 1232              		.loc 1 1401 0
 1233 0084 3B69     		ldr	r3, [r7, #16]
 1234 0086 3A68     		ldr	r2, [r7]
 1235 0088 1A64     		str	r2, [r3, #64]
1402:..\..\..\Source/tasks.c **** 				}
1403:..\..\..\Source/tasks.c **** 				#else
1404:..\..\..\Source/tasks.c **** 				{
1405:..\..\..\Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
1406:..\..\..\Source/tasks.c **** 				}
1407:..\..\..\Source/tasks.c **** 				#endif
1408:..\..\..\Source/tasks.c **** 
1409:..\..\..\Source/tasks.c **** 				/* Only reset the event list item value if the value is not
1410:..\..\..\Source/tasks.c **** 				being used for anything else. */
1411:..\..\..\Source/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE 
 1236              		.loc 1 1411 0
 1237 008a 3B69     		ldr	r3, [r7, #16]
 1238 008c 9B69     		ldr	r3, [r3, #24]
 1239 008e 002B     		cmp	r3, #0
 1240 0090 04DB     		blt	.L80
1412:..\..\..\Source/tasks.c **** 				{
1413:..\..\..\Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - (
 1241              		.loc 1 1413 0
 1242 0092 3B68     		ldr	r3, [r7]
 1243 0094 C3F10502 		rsb	r2, r3, #5
 1244 0098 3B69     		ldr	r3, [r7, #16]
 1245 009a 9A61     		str	r2, [r3, #24]
 1246              	.L80:
1414:..\..\..\Source/tasks.c **** 				}
1415:..\..\..\Source/tasks.c **** 				else
1416:..\..\..\Source/tasks.c **** 				{
1417:..\..\..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1418:..\..\..\Source/tasks.c **** 				}
1419:..\..\..\Source/tasks.c **** 
1420:..\..\..\Source/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
1421:..\..\..\Source/tasks.c **** 				nothing more than change it's priority variable. However, if
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 53


1422:..\..\..\Source/tasks.c **** 				the task is in a ready list it needs to be removed and placed
1423:..\..\..\Source/tasks.c **** 				in the list appropriate to its new priority. */
1424:..\..\..\Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateL
 1247              		.loc 1 1424 0
 1248 009c 3B69     		ldr	r3, [r7, #16]
 1249 009e 5969     		ldr	r1, [r3, #20]
 1250 00a0 BA68     		ldr	r2, [r7, #8]
 1251 00a2 1346     		mov	r3, r2
 1252 00a4 9B00     		lsls	r3, r3, #2
 1253 00a6 1344     		add	r3, r3, r2
 1254 00a8 9B00     		lsls	r3, r3, #2
 1255 00aa 234A     		ldr	r2, .L85+4
 1256 00ac 1344     		add	r3, r3, r2
 1257 00ae 9942     		cmp	r1, r3
 1258 00b0 01D1     		bne	.L81
 1259              		.loc 1 1424 0 is_stmt 0 discriminator 1
 1260 00b2 0123     		movs	r3, #1
 1261 00b4 00E0     		b	.L82
 1262              	.L81:
 1263              		.loc 1 1424 0 discriminator 2
 1264 00b6 0023     		movs	r3, #0
 1265              	.L82:
 1266              		.loc 1 1424 0 discriminator 4
 1267 00b8 002B     		cmp	r3, #0
 1268 00ba 2AD0     		beq	.L83
1425:..\..\..\Source/tasks.c **** 				{
1426:..\..\..\Source/tasks.c **** 					/* The task is currently in its ready list - remove before adding
1427:..\..\..\Source/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
1428:..\..\..\Source/tasks.c **** 					can do this even if the scheduler is suspended. */
1429:..\..\..\Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 1269              		.loc 1 1429 0 is_stmt 1
 1270 00bc 3B69     		ldr	r3, [r7, #16]
 1271 00be 0433     		adds	r3, r3, #4
 1272 00c0 1846     		mov	r0, r3
 1273 00c2 FFF7FEFF 		bl	uxListRemove
 1274 00c6 0346     		mov	r3, r0
 1275 00c8 002B     		cmp	r3, #0
 1276 00ca 09D1     		bne	.L84
1430:..\..\..\Source/tasks.c **** 					{
1431:..\..\..\Source/tasks.c **** 						/* It is known that the task is in its ready list so
1432:..\..\..\Source/tasks.c **** 						there is no need to check again and the port level
1433:..\..\..\Source/tasks.c **** 						reset macro can be called directly. */
1434:..\..\..\Source/tasks.c **** 						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
 1277              		.loc 1 1434 0
 1278 00cc BB68     		ldr	r3, [r7, #8]
 1279 00ce 0122     		movs	r2, #1
 1280 00d0 02FA03F3 		lsl	r3, r2, r3
 1281 00d4 DA43     		mvns	r2, r3
 1282 00d6 194B     		ldr	r3, .L85+8
 1283 00d8 1B68     		ldr	r3, [r3]
 1284 00da 1340     		ands	r3, r3, r2
 1285 00dc 174A     		ldr	r2, .L85+8
 1286 00de 1360     		str	r3, [r2]
 1287              	.L84:
1435:..\..\..\Source/tasks.c **** 					}
1436:..\..\..\Source/tasks.c **** 					else
1437:..\..\..\Source/tasks.c **** 					{
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 54


1438:..\..\..\Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1439:..\..\..\Source/tasks.c **** 					}
1440:..\..\..\Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1288              		.loc 1 1440 0
 1289 00e0 3B69     		ldr	r3, [r7, #16]
 1290 00e2 DB6A     		ldr	r3, [r3, #44]
 1291 00e4 1A46     		mov	r2, r3
 1292 00e6 0123     		movs	r3, #1
 1293 00e8 03FA02F2 		lsl	r2, r3, r2
 1294 00ec 134B     		ldr	r3, .L85+8
 1295 00ee 1B68     		ldr	r3, [r3]
 1296 00f0 1343     		orrs	r3, r3, r2
 1297 00f2 124A     		ldr	r2, .L85+8
 1298 00f4 1360     		str	r3, [r2]
 1299 00f6 3B69     		ldr	r3, [r7, #16]
 1300 00f8 DA6A     		ldr	r2, [r3, #44]
 1301 00fa 1346     		mov	r3, r2
 1302 00fc 9B00     		lsls	r3, r3, #2
 1303 00fe 1344     		add	r3, r3, r2
 1304 0100 9B00     		lsls	r3, r3, #2
 1305 0102 0D4A     		ldr	r2, .L85+4
 1306 0104 1A44     		add	r2, r2, r3
 1307 0106 3B69     		ldr	r3, [r7, #16]
 1308 0108 0433     		adds	r3, r3, #4
 1309 010a 1046     		mov	r0, r2
 1310 010c 1946     		mov	r1, r3
 1311 010e FFF7FEFF 		bl	vListInsertEnd
 1312              	.L83:
1441:..\..\..\Source/tasks.c **** 				}
1442:..\..\..\Source/tasks.c **** 				else
1443:..\..\..\Source/tasks.c **** 				{
1444:..\..\..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1445:..\..\..\Source/tasks.c **** 				}
1446:..\..\..\Source/tasks.c **** 
1447:..\..\..\Source/tasks.c **** 				if( xYieldRequired != pdFALSE )
 1313              		.loc 1 1447 0
 1314 0112 7B69     		ldr	r3, [r7, #20]
 1315 0114 002B     		cmp	r3, #0
 1316 0116 07D0     		beq	.L76
1448:..\..\..\Source/tasks.c **** 				{
1449:..\..\..\Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
 1317              		.loc 1 1449 0
 1318 0118 094B     		ldr	r3, .L85+12
 1319 011a 4FF08052 		mov	r2, #268435456
 1320 011e 1A60     		str	r2, [r3]
 1321              	@ 1449 "..\..\..\Source\tasks.c" 1
 1322 0120 BFF34F8F 		dsb
 1323              	@ 0 "" 2
 1324              	@ 1449 "..\..\..\Source\tasks.c" 1
 1325 0124 BFF36F8F 		isb
 1326              	@ 0 "" 2
 1327              		.thumb
 1328              	.L76:
1450:..\..\..\Source/tasks.c **** 				}
1451:..\..\..\Source/tasks.c **** 				else
1452:..\..\..\Source/tasks.c **** 				{
1453:..\..\..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 55


1454:..\..\..\Source/tasks.c **** 				}
1455:..\..\..\Source/tasks.c **** 
1456:..\..\..\Source/tasks.c **** 				/* Remove compiler warning about unused variables when the port
1457:..\..\..\Source/tasks.c **** 				optimised task selection is not being used. */
1458:..\..\..\Source/tasks.c **** 				( void ) uxPriorityUsedOnEntry;
1459:..\..\..\Source/tasks.c **** 			}
1460:..\..\..\Source/tasks.c **** 		}
1461:..\..\..\Source/tasks.c **** 		taskEXIT_CRITICAL();
 1329              		.loc 1 1461 0
 1330 0128 FFF7FEFF 		bl	vPortExitCritical
1462:..\..\..\Source/tasks.c **** 	}
 1331              		.loc 1 1462 0
 1332 012c 1837     		adds	r7, r7, #24
 1333              		.cfi_def_cfa_offset 8
 1334 012e BD46     		mov	sp, r7
 1335              		.cfi_def_cfa_register 13
 1336              		@ sp needed
 1337 0130 80BD     		pop	{r7, pc}
 1338              	.L86:
 1339 0132 00BF     		.align	2
 1340              	.L85:
 1341 0134 00000000 		.word	pxCurrentTCB
 1342 0138 04000000 		.word	pxReadyTasksLists
 1343 013c E0000000 		.word	uxTopReadyPriority
 1344 0140 04ED00E0 		.word	-536810236
 1345              		.cfi_endproc
 1346              	.LFE77:
 1347              		.size	vTaskPrioritySet, .-vTaskPrioritySet
 1348              		.section	.text.vTaskSuspend,"ax",%progbits
 1349              		.align	2
 1350              		.global	vTaskSuspend
 1351              		.thumb
 1352              		.thumb_func
 1353              		.type	vTaskSuspend, %function
 1354              	vTaskSuspend:
 1355              	.LFB78:
1463:..\..\..\Source/tasks.c **** 
1464:..\..\..\Source/tasks.c **** #endif /* INCLUDE_vTaskPrioritySet */
1465:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
1466:..\..\..\Source/tasks.c **** 
1467:..\..\..\Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1468:..\..\..\Source/tasks.c **** 
1469:..\..\..\Source/tasks.c **** 	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
1470:..\..\..\Source/tasks.c **** 	{
 1356              		.loc 1 1470 0
 1357              		.cfi_startproc
 1358              		@ args = 0, pretend = 0, frame = 16
 1359              		@ frame_needed = 1, uses_anonymous_args = 0
 1360 0000 80B5     		push	{r7, lr}
 1361              		.cfi_def_cfa_offset 8
 1362              		.cfi_offset 7, -8
 1363              		.cfi_offset 14, -4
 1364 0002 84B0     		sub	sp, sp, #16
 1365              		.cfi_def_cfa_offset 24
 1366 0004 00AF     		add	r7, sp, #0
 1367              		.cfi_def_cfa_register 7
 1368 0006 7860     		str	r0, [r7, #4]
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 56


1471:..\..\..\Source/tasks.c **** 	TCB_t *pxTCB;
1472:..\..\..\Source/tasks.c **** 
1473:..\..\..\Source/tasks.c **** 		taskENTER_CRITICAL();
 1369              		.loc 1 1473 0
 1370 0008 FFF7FEFF 		bl	vPortEnterCritical
1474:..\..\..\Source/tasks.c **** 		{
1475:..\..\..\Source/tasks.c **** 			/* If null is passed in here then it is the running task that is
1476:..\..\..\Source/tasks.c **** 			being suspended. */
1477:..\..\..\Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 1371              		.loc 1 1477 0
 1372 000c 7B68     		ldr	r3, [r7, #4]
 1373 000e 002B     		cmp	r3, #0
 1374 0010 02D1     		bne	.L88
 1375              		.loc 1 1477 0 is_stmt 0 discriminator 1
 1376 0012 2F4B     		ldr	r3, .L98
 1377 0014 1B68     		ldr	r3, [r3]
 1378 0016 00E0     		b	.L89
 1379              	.L88:
 1380              		.loc 1 1477 0 discriminator 2
 1381 0018 7B68     		ldr	r3, [r7, #4]
 1382              	.L89:
 1383              		.loc 1 1477 0 discriminator 4
 1384 001a FB60     		str	r3, [r7, #12]
1478:..\..\..\Source/tasks.c **** 
1479:..\..\..\Source/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
1480:..\..\..\Source/tasks.c **** 
1481:..\..\..\Source/tasks.c **** 			/* Remove task from the ready/delayed list and place in the
1482:..\..\..\Source/tasks.c **** 			suspended list. */
1483:..\..\..\Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 1385              		.loc 1 1483 0 is_stmt 1 discriminator 4
 1386 001c FB68     		ldr	r3, [r7, #12]
 1387 001e 0433     		adds	r3, r3, #4
 1388 0020 1846     		mov	r0, r3
 1389 0022 FFF7FEFF 		bl	uxListRemove
 1390 0026 0346     		mov	r3, r0
 1391 0028 002B     		cmp	r3, #0
 1392 002a 15D1     		bne	.L90
1484:..\..\..\Source/tasks.c **** 			{
1485:..\..\..\Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 1393              		.loc 1 1485 0
 1394 002c FB68     		ldr	r3, [r7, #12]
 1395 002e DA6A     		ldr	r2, [r3, #44]
 1396 0030 2849     		ldr	r1, .L98+4
 1397 0032 1346     		mov	r3, r2
 1398 0034 9B00     		lsls	r3, r3, #2
 1399 0036 1344     		add	r3, r3, r2
 1400 0038 9B00     		lsls	r3, r3, #2
 1401 003a 0B44     		add	r3, r3, r1
 1402 003c 1B68     		ldr	r3, [r3]
 1403 003e 002B     		cmp	r3, #0
 1404 0040 0AD1     		bne	.L90
 1405              		.loc 1 1485 0 is_stmt 0 discriminator 1
 1406 0042 FB68     		ldr	r3, [r7, #12]
 1407 0044 DB6A     		ldr	r3, [r3, #44]
 1408 0046 1A46     		mov	r2, r3
 1409 0048 0123     		movs	r3, #1
 1410 004a 9340     		lsls	r3, r3, r2
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 57


 1411 004c DA43     		mvns	r2, r3
 1412 004e 224B     		ldr	r3, .L98+8
 1413 0050 1B68     		ldr	r3, [r3]
 1414 0052 1340     		ands	r3, r3, r2
 1415 0054 204A     		ldr	r2, .L98+8
 1416 0056 1360     		str	r3, [r2]
 1417              	.L90:
1486:..\..\..\Source/tasks.c **** 			}
1487:..\..\..\Source/tasks.c **** 			else
1488:..\..\..\Source/tasks.c **** 			{
1489:..\..\..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1490:..\..\..\Source/tasks.c **** 			}
1491:..\..\..\Source/tasks.c **** 
1492:..\..\..\Source/tasks.c **** 			/* Is the task waiting on an event also? */
1493:..\..\..\Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 1418              		.loc 1 1493 0 is_stmt 1
 1419 0058 FB68     		ldr	r3, [r7, #12]
 1420 005a 9B6A     		ldr	r3, [r3, #40]
 1421 005c 002B     		cmp	r3, #0
 1422 005e 04D0     		beq	.L92
1494:..\..\..\Source/tasks.c **** 			{
1495:..\..\..\Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1423              		.loc 1 1495 0
 1424 0060 FB68     		ldr	r3, [r7, #12]
 1425 0062 1833     		adds	r3, r3, #24
 1426 0064 1846     		mov	r0, r3
 1427 0066 FFF7FEFF 		bl	uxListRemove
 1428              	.L92:
1496:..\..\..\Source/tasks.c **** 			}
1497:..\..\..\Source/tasks.c **** 			else
1498:..\..\..\Source/tasks.c **** 			{
1499:..\..\..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1500:..\..\..\Source/tasks.c **** 			}
1501:..\..\..\Source/tasks.c **** 
1502:..\..\..\Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 1429              		.loc 1 1502 0
 1430 006a FB68     		ldr	r3, [r7, #12]
 1431 006c 0433     		adds	r3, r3, #4
 1432 006e 1B48     		ldr	r0, .L98+12
 1433 0070 1946     		mov	r1, r3
 1434 0072 FFF7FEFF 		bl	vListInsertEnd
1503:..\..\..\Source/tasks.c **** 		}
1504:..\..\..\Source/tasks.c **** 		taskEXIT_CRITICAL();
 1435              		.loc 1 1504 0
 1436 0076 FFF7FEFF 		bl	vPortExitCritical
1505:..\..\..\Source/tasks.c **** 
1506:..\..\..\Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 1437              		.loc 1 1506 0
 1438 007a 194B     		ldr	r3, .L98+16
 1439 007c 1B68     		ldr	r3, [r3]
 1440 007e 002B     		cmp	r3, #0
 1441 0080 05D0     		beq	.L93
1507:..\..\..\Source/tasks.c **** 		{
1508:..\..\..\Source/tasks.c **** 			/* Reset the next expected unblock time in case it referred to the
1509:..\..\..\Source/tasks.c **** 			task that is now in the Suspended state. */
1510:..\..\..\Source/tasks.c **** 			taskENTER_CRITICAL();
 1442              		.loc 1 1510 0
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 58


 1443 0082 FFF7FEFF 		bl	vPortEnterCritical
1511:..\..\..\Source/tasks.c **** 			{
1512:..\..\..\Source/tasks.c **** 				prvResetNextTaskUnblockTime();
 1444              		.loc 1 1512 0
 1445 0086 FFF7FEFF 		bl	prvResetNextTaskUnblockTime
1513:..\..\..\Source/tasks.c **** 			}
1514:..\..\..\Source/tasks.c **** 			taskEXIT_CRITICAL();
 1446              		.loc 1 1514 0
 1447 008a FFF7FEFF 		bl	vPortExitCritical
 1448              	.L93:
1515:..\..\..\Source/tasks.c **** 		}
1516:..\..\..\Source/tasks.c **** 		else
1517:..\..\..\Source/tasks.c **** 		{
1518:..\..\..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1519:..\..\..\Source/tasks.c **** 		}
1520:..\..\..\Source/tasks.c **** 
1521:..\..\..\Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
 1449              		.loc 1 1521 0
 1450 008e 104B     		ldr	r3, .L98
 1451 0090 1B68     		ldr	r3, [r3]
 1452 0092 FA68     		ldr	r2, [r7, #12]
 1453 0094 9A42     		cmp	r2, r3
 1454 0096 18D1     		bne	.L87
1522:..\..\..\Source/tasks.c **** 		{
1523:..\..\..\Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
 1455              		.loc 1 1523 0
 1456 0098 114B     		ldr	r3, .L98+16
 1457 009a 1B68     		ldr	r3, [r3]
 1458 009c 002B     		cmp	r3, #0
 1459 009e 08D0     		beq	.L95
1524:..\..\..\Source/tasks.c **** 			{
1525:..\..\..\Source/tasks.c **** 				/* The current task has just been suspended. */
1526:..\..\..\Source/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
1527:..\..\..\Source/tasks.c **** 				portYIELD_WITHIN_API();
 1460              		.loc 1 1527 0
 1461 00a0 104B     		ldr	r3, .L98+20
 1462 00a2 4FF08052 		mov	r2, #268435456
 1463 00a6 1A60     		str	r2, [r3]
 1464              	@ 1527 "..\..\..\Source\tasks.c" 1
 1465 00a8 BFF34F8F 		dsb
 1466              	@ 0 "" 2
 1467              	@ 1527 "..\..\..\Source\tasks.c" 1
 1468 00ac BFF36F8F 		isb
 1469              	@ 0 "" 2
 1470              		.thumb
 1471 00b0 0BE0     		b	.L87
 1472              	.L95:
1528:..\..\..\Source/tasks.c **** 			}
1529:..\..\..\Source/tasks.c **** 			else
1530:..\..\..\Source/tasks.c **** 			{
1531:..\..\..\Source/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
1532:..\..\..\Source/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1533:..\..\..\Source/tasks.c **** 				must be adjusted to point to a different task. */
1534:..\..\..\Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 1473              		.loc 1 1534 0
 1474 00b2 0A4B     		ldr	r3, .L98+12
 1475 00b4 1A68     		ldr	r2, [r3]
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 59


 1476 00b6 0C4B     		ldr	r3, .L98+24
 1477 00b8 1B68     		ldr	r3, [r3]
 1478 00ba 9A42     		cmp	r2, r3
 1479 00bc 03D1     		bne	.L97
1535:..\..\..\Source/tasks.c **** 				{
1536:..\..\..\Source/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
1537:..\..\..\Source/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
1538:..\..\..\Source/tasks.c **** 					be set to point to it no matter what its relative priority
1539:..\..\..\Source/tasks.c **** 					is. */
1540:..\..\..\Source/tasks.c **** 					pxCurrentTCB = NULL;
 1480              		.loc 1 1540 0
 1481 00be 044B     		ldr	r3, .L98
 1482 00c0 0022     		movs	r2, #0
 1483 00c2 1A60     		str	r2, [r3]
 1484 00c4 01E0     		b	.L87
 1485              	.L97:
1541:..\..\..\Source/tasks.c **** 				}
1542:..\..\..\Source/tasks.c **** 				else
1543:..\..\..\Source/tasks.c **** 				{
1544:..\..\..\Source/tasks.c **** 					vTaskSwitchContext();
 1486              		.loc 1 1544 0
 1487 00c6 FFF7FEFF 		bl	vTaskSwitchContext
 1488              	.L87:
1545:..\..\..\Source/tasks.c **** 				}
1546:..\..\..\Source/tasks.c **** 			}
1547:..\..\..\Source/tasks.c **** 		}
1548:..\..\..\Source/tasks.c **** 		else
1549:..\..\..\Source/tasks.c **** 		{
1550:..\..\..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1551:..\..\..\Source/tasks.c **** 		}
1552:..\..\..\Source/tasks.c **** 	}
 1489              		.loc 1 1552 0
 1490 00ca 1037     		adds	r7, r7, #16
 1491              		.cfi_def_cfa_offset 8
 1492 00cc BD46     		mov	sp, r7
 1493              		.cfi_def_cfa_register 13
 1494              		@ sp needed
 1495 00ce 80BD     		pop	{r7, pc}
 1496              	.L99:
 1497              		.align	2
 1498              	.L98:
 1499 00d0 00000000 		.word	pxCurrentTCB
 1500 00d4 04000000 		.word	pxReadyTasksLists
 1501 00d8 E0000000 		.word	uxTopReadyPriority
 1502 00dc C4000000 		.word	xSuspendedTaskList
 1503 00e0 E4000000 		.word	xSchedulerRunning
 1504 00e4 04ED00E0 		.word	-536810236
 1505 00e8 D8000000 		.word	uxCurrentNumberOfTasks
 1506              		.cfi_endproc
 1507              	.LFE78:
 1508              		.size	vTaskSuspend, .-vTaskSuspend
 1509              		.section	.text.prvTaskIsTaskSuspended,"ax",%progbits
 1510              		.align	2
 1511              		.thumb
 1512              		.thumb_func
 1513              		.type	prvTaskIsTaskSuspended, %function
 1514              	prvTaskIsTaskSuspended:
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 60


 1515              	.LFB79:
1553:..\..\..\Source/tasks.c **** 
1554:..\..\..\Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1555:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
1556:..\..\..\Source/tasks.c **** 
1557:..\..\..\Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1558:..\..\..\Source/tasks.c **** 
1559:..\..\..\Source/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
1560:..\..\..\Source/tasks.c **** 	{
 1516              		.loc 1 1560 0
 1517              		.cfi_startproc
 1518              		@ args = 0, pretend = 0, frame = 16
 1519              		@ frame_needed = 1, uses_anonymous_args = 0
 1520              		@ link register save eliminated.
 1521 0000 80B4     		push	{r7}
 1522              		.cfi_def_cfa_offset 4
 1523              		.cfi_offset 7, -4
 1524 0002 85B0     		sub	sp, sp, #20
 1525              		.cfi_def_cfa_offset 24
 1526 0004 00AF     		add	r7, sp, #0
 1527              		.cfi_def_cfa_register 7
 1528 0006 7860     		str	r0, [r7, #4]
1561:..\..\..\Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
 1529              		.loc 1 1561 0
 1530 0008 0023     		movs	r3, #0
 1531 000a FB60     		str	r3, [r7, #12]
1562:..\..\..\Source/tasks.c **** 	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
 1532              		.loc 1 1562 0
 1533 000c 7B68     		ldr	r3, [r7, #4]
 1534 000e BB60     		str	r3, [r7, #8]
1563:..\..\..\Source/tasks.c **** 
1564:..\..\..\Source/tasks.c **** 		/* Accesses xPendingReadyList so must be called from a critical
1565:..\..\..\Source/tasks.c **** 		section. */
1566:..\..\..\Source/tasks.c **** 
1567:..\..\..\Source/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
1568:..\..\..\Source/tasks.c **** 		configASSERT( xTask );
1569:..\..\..\Source/tasks.c **** 
1570:..\..\..\Source/tasks.c **** 		/* Is the task being resumed actually in the suspended list? */
1571:..\..\..\Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
 1535              		.loc 1 1571 0
 1536 0010 BB68     		ldr	r3, [r7, #8]
 1537 0012 5B69     		ldr	r3, [r3, #20]
 1538 0014 0F4A     		ldr	r2, .L107
 1539 0016 9342     		cmp	r3, r2
 1540 0018 01D1     		bne	.L101
 1541              		.loc 1 1571 0 is_stmt 0 discriminator 1
 1542 001a 0123     		movs	r3, #1
 1543 001c 00E0     		b	.L102
 1544              	.L101:
 1545              		.loc 1 1571 0 discriminator 2
 1546 001e 0023     		movs	r3, #0
 1547              	.L102:
 1548              		.loc 1 1571 0 discriminator 4
 1549 0020 002B     		cmp	r3, #0
 1550 0022 0FD0     		beq	.L103
1572:..\..\..\Source/tasks.c **** 		{
1573:..\..\..\Source/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 61


1574:..\..\..\Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 1551              		.loc 1 1574 0 is_stmt 1
 1552 0024 BB68     		ldr	r3, [r7, #8]
 1553 0026 9B6A     		ldr	r3, [r3, #40]
 1554 0028 0B4A     		ldr	r2, .L107+4
 1555 002a 9342     		cmp	r3, r2
 1556 002c 0AD0     		beq	.L103
1575:..\..\..\Source/tasks.c **** 			{
1576:..\..\..\Source/tasks.c **** 				/* Is it in the suspended list because it is in the	Suspended
1577:..\..\..\Source/tasks.c **** 				state, or because is is blocked with no timeout? */
1578:..\..\..\Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
 1557              		.loc 1 1578 0
 1558 002e BB68     		ldr	r3, [r7, #8]
 1559 0030 9B6A     		ldr	r3, [r3, #40]
 1560 0032 002B     		cmp	r3, #0
 1561 0034 01D1     		bne	.L104
 1562              		.loc 1 1578 0 is_stmt 0 discriminator 1
 1563 0036 0123     		movs	r3, #1
 1564 0038 00E0     		b	.L105
 1565              	.L104:
 1566              		.loc 1 1578 0 discriminator 2
 1567 003a 0023     		movs	r3, #0
 1568              	.L105:
 1569              		.loc 1 1578 0 discriminator 4
 1570 003c 002B     		cmp	r3, #0
 1571 003e 01D0     		beq	.L103
1579:..\..\..\Source/tasks.c **** 				{
1580:..\..\..\Source/tasks.c **** 					xReturn = pdTRUE;
 1572              		.loc 1 1580 0 is_stmt 1
 1573 0040 0123     		movs	r3, #1
 1574 0042 FB60     		str	r3, [r7, #12]
 1575              	.L103:
1581:..\..\..\Source/tasks.c **** 				}
1582:..\..\..\Source/tasks.c **** 				else
1583:..\..\..\Source/tasks.c **** 				{
1584:..\..\..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1585:..\..\..\Source/tasks.c **** 				}
1586:..\..\..\Source/tasks.c **** 			}
1587:..\..\..\Source/tasks.c **** 			else
1588:..\..\..\Source/tasks.c **** 			{
1589:..\..\..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1590:..\..\..\Source/tasks.c **** 			}
1591:..\..\..\Source/tasks.c **** 		}
1592:..\..\..\Source/tasks.c **** 		else
1593:..\..\..\Source/tasks.c **** 		{
1594:..\..\..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1595:..\..\..\Source/tasks.c **** 		}
1596:..\..\..\Source/tasks.c **** 
1597:..\..\..\Source/tasks.c **** 		return xReturn;
 1576              		.loc 1 1597 0
 1577 0044 FB68     		ldr	r3, [r7, #12]
1598:..\..\..\Source/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 1578              		.loc 1 1598 0
 1579 0046 1846     		mov	r0, r3
 1580 0048 1437     		adds	r7, r7, #20
 1581              		.cfi_def_cfa_offset 4
 1582 004a BD46     		mov	sp, r7
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 62


 1583              		.cfi_def_cfa_register 13
 1584              		@ sp needed
 1585 004c 5DF8047B 		ldr	r7, [sp], #4
 1586              		.cfi_restore 7
 1587              		.cfi_def_cfa_offset 0
 1588 0050 7047     		bx	lr
 1589              	.L108:
 1590 0052 00BF     		.align	2
 1591              	.L107:
 1592 0054 C4000000 		.word	xSuspendedTaskList
 1593 0058 98000000 		.word	xPendingReadyList
 1594              		.cfi_endproc
 1595              	.LFE79:
 1596              		.size	prvTaskIsTaskSuspended, .-prvTaskIsTaskSuspended
 1597              		.section	.text.vTaskResume,"ax",%progbits
 1598              		.align	2
 1599              		.global	vTaskResume
 1600              		.thumb
 1601              		.thumb_func
 1602              		.type	vTaskResume, %function
 1603              	vTaskResume:
 1604              	.LFB80:
1599:..\..\..\Source/tasks.c **** 
1600:..\..\..\Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1601:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
1602:..\..\..\Source/tasks.c **** 
1603:..\..\..\Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1604:..\..\..\Source/tasks.c **** 
1605:..\..\..\Source/tasks.c **** 	void vTaskResume( TaskHandle_t xTaskToResume )
1606:..\..\..\Source/tasks.c **** 	{
 1605              		.loc 1 1606 0
 1606              		.cfi_startproc
 1607              		@ args = 0, pretend = 0, frame = 16
 1608              		@ frame_needed = 1, uses_anonymous_args = 0
 1609 0000 80B5     		push	{r7, lr}
 1610              		.cfi_def_cfa_offset 8
 1611              		.cfi_offset 7, -8
 1612              		.cfi_offset 14, -4
 1613 0002 84B0     		sub	sp, sp, #16
 1614              		.cfi_def_cfa_offset 24
 1615 0004 00AF     		add	r7, sp, #0
 1616              		.cfi_def_cfa_register 7
 1617 0006 7860     		str	r0, [r7, #4]
1607:..\..\..\Source/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
 1618              		.loc 1 1607 0
 1619 0008 7B68     		ldr	r3, [r7, #4]
 1620 000a FB60     		str	r3, [r7, #12]
1608:..\..\..\Source/tasks.c **** 
1609:..\..\..\Source/tasks.c **** 		/* It does not make sense to resume the calling task. */
1610:..\..\..\Source/tasks.c **** 		configASSERT( xTaskToResume );
1611:..\..\..\Source/tasks.c **** 
1612:..\..\..\Source/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
1613:..\..\..\Source/tasks.c **** 		currently executing task. */
1614:..\..\..\Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 1621              		.loc 1 1614 0
 1622 000c FB68     		ldr	r3, [r7, #12]
 1623 000e 002B     		cmp	r3, #0
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 63


 1624 0010 3BD0     		beq	.L109
 1625              		.loc 1 1614 0 is_stmt 0 discriminator 1
 1626 0012 1F4B     		ldr	r3, .L112
 1627 0014 1B68     		ldr	r3, [r3]
 1628 0016 FA68     		ldr	r2, [r7, #12]
 1629 0018 9A42     		cmp	r2, r3
 1630 001a 36D0     		beq	.L109
1615:..\..\..\Source/tasks.c **** 		{
1616:..\..\..\Source/tasks.c **** 			taskENTER_CRITICAL();
 1631              		.loc 1 1616 0 is_stmt 1
 1632 001c FFF7FEFF 		bl	vPortEnterCritical
1617:..\..\..\Source/tasks.c **** 			{
1618:..\..\..\Source/tasks.c **** 				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 1633              		.loc 1 1618 0
 1634 0020 F868     		ldr	r0, [r7, #12]
 1635 0022 FFF7FEFF 		bl	prvTaskIsTaskSuspended
 1636 0026 0346     		mov	r3, r0
 1637 0028 002B     		cmp	r3, #0
 1638 002a 2CD0     		beq	.L111
1619:..\..\..\Source/tasks.c **** 				{
1620:..\..\..\Source/tasks.c **** 					traceTASK_RESUME( pxTCB );
1621:..\..\..\Source/tasks.c **** 
1622:..\..\..\Source/tasks.c **** 					/* As we are in a critical section we can access the ready
1623:..\..\..\Source/tasks.c **** 					lists even if the scheduler is suspended. */
1624:..\..\..\Source/tasks.c **** 					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
 1639              		.loc 1 1624 0
 1640 002c FB68     		ldr	r3, [r7, #12]
 1641 002e 0433     		adds	r3, r3, #4
 1642 0030 1846     		mov	r0, r3
 1643 0032 FFF7FEFF 		bl	uxListRemove
1625:..\..\..\Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1644              		.loc 1 1625 0
 1645 0036 FB68     		ldr	r3, [r7, #12]
 1646 0038 DB6A     		ldr	r3, [r3, #44]
 1647 003a 1A46     		mov	r2, r3
 1648 003c 0123     		movs	r3, #1
 1649 003e 03FA02F2 		lsl	r2, r3, r2
 1650 0042 144B     		ldr	r3, .L112+4
 1651 0044 1B68     		ldr	r3, [r3]
 1652 0046 1343     		orrs	r3, r3, r2
 1653 0048 124A     		ldr	r2, .L112+4
 1654 004a 1360     		str	r3, [r2]
 1655 004c FB68     		ldr	r3, [r7, #12]
 1656 004e DA6A     		ldr	r2, [r3, #44]
 1657 0050 1346     		mov	r3, r2
 1658 0052 9B00     		lsls	r3, r3, #2
 1659 0054 1344     		add	r3, r3, r2
 1660 0056 9B00     		lsls	r3, r3, #2
 1661 0058 0F4A     		ldr	r2, .L112+8
 1662 005a 1A44     		add	r2, r2, r3
 1663 005c FB68     		ldr	r3, [r7, #12]
 1664 005e 0433     		adds	r3, r3, #4
 1665 0060 1046     		mov	r0, r2
 1666 0062 1946     		mov	r1, r3
 1667 0064 FFF7FEFF 		bl	vListInsertEnd
1626:..\..\..\Source/tasks.c **** 
1627:..\..\..\Source/tasks.c **** 					/* We may have just resumed a higher priority task. */
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 64


1628:..\..\..\Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1668              		.loc 1 1628 0
 1669 0068 FB68     		ldr	r3, [r7, #12]
 1670 006a DA6A     		ldr	r2, [r3, #44]
 1671 006c 084B     		ldr	r3, .L112
 1672 006e 1B68     		ldr	r3, [r3]
 1673 0070 DB6A     		ldr	r3, [r3, #44]
 1674 0072 9A42     		cmp	r2, r3
 1675 0074 07D3     		bcc	.L111
1629:..\..\..\Source/tasks.c **** 					{
1630:..\..\..\Source/tasks.c **** 						/* This yield may not cause the task just resumed to run,
1631:..\..\..\Source/tasks.c **** 						but will leave the lists in the correct state for the
1632:..\..\..\Source/tasks.c **** 						next yield. */
1633:..\..\..\Source/tasks.c **** 						taskYIELD_IF_USING_PREEMPTION();
 1676              		.loc 1 1633 0
 1677 0076 094B     		ldr	r3, .L112+12
 1678 0078 4FF08052 		mov	r2, #268435456
 1679 007c 1A60     		str	r2, [r3]
 1680              	@ 1633 "..\..\..\Source\tasks.c" 1
 1681 007e BFF34F8F 		dsb
 1682              	@ 0 "" 2
 1683              	@ 1633 "..\..\..\Source\tasks.c" 1
 1684 0082 BFF36F8F 		isb
 1685              	@ 0 "" 2
 1686              		.thumb
 1687              	.L111:
1634:..\..\..\Source/tasks.c **** 					}
1635:..\..\..\Source/tasks.c **** 					else
1636:..\..\..\Source/tasks.c **** 					{
1637:..\..\..\Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1638:..\..\..\Source/tasks.c **** 					}
1639:..\..\..\Source/tasks.c **** 				}
1640:..\..\..\Source/tasks.c **** 				else
1641:..\..\..\Source/tasks.c **** 				{
1642:..\..\..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1643:..\..\..\Source/tasks.c **** 				}
1644:..\..\..\Source/tasks.c **** 			}
1645:..\..\..\Source/tasks.c **** 			taskEXIT_CRITICAL();
 1688              		.loc 1 1645 0
 1689 0086 FFF7FEFF 		bl	vPortExitCritical
 1690              	.L109:
1646:..\..\..\Source/tasks.c **** 		}
1647:..\..\..\Source/tasks.c **** 		else
1648:..\..\..\Source/tasks.c **** 		{
1649:..\..\..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1650:..\..\..\Source/tasks.c **** 		}
1651:..\..\..\Source/tasks.c **** 	}
 1691              		.loc 1 1651 0
 1692 008a 1037     		adds	r7, r7, #16
 1693              		.cfi_def_cfa_offset 8
 1694 008c BD46     		mov	sp, r7
 1695              		.cfi_def_cfa_register 13
 1696              		@ sp needed
 1697 008e 80BD     		pop	{r7, pc}
 1698              	.L113:
 1699              		.align	2
 1700              	.L112:
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 65


 1701 0090 00000000 		.word	pxCurrentTCB
 1702 0094 E0000000 		.word	uxTopReadyPriority
 1703 0098 04000000 		.word	pxReadyTasksLists
 1704 009c 04ED00E0 		.word	-536810236
 1705              		.cfi_endproc
 1706              	.LFE80:
 1707              		.size	vTaskResume, .-vTaskResume
 1708              		.section	.text.xTaskResumeFromISR,"ax",%progbits
 1709              		.align	2
 1710              		.global	xTaskResumeFromISR
 1711              		.thumb
 1712              		.thumb_func
 1713              		.type	xTaskResumeFromISR, %function
 1714              	xTaskResumeFromISR:
 1715              	.LFB81:
1652:..\..\..\Source/tasks.c **** 
1653:..\..\..\Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1654:..\..\..\Source/tasks.c **** 
1655:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
1656:..\..\..\Source/tasks.c **** 
1657:..\..\..\Source/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1658:..\..\..\Source/tasks.c **** 
1659:..\..\..\Source/tasks.c **** 	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
1660:..\..\..\Source/tasks.c **** 	{
 1716              		.loc 1 1660 0
 1717              		.cfi_startproc
 1718              		@ args = 0, pretend = 0, frame = 32
 1719              		@ frame_needed = 1, uses_anonymous_args = 0
 1720 0000 80B5     		push	{r7, lr}
 1721              		.cfi_def_cfa_offset 8
 1722              		.cfi_offset 7, -8
 1723              		.cfi_offset 14, -4
 1724 0002 88B0     		sub	sp, sp, #32
 1725              		.cfi_def_cfa_offset 40
 1726 0004 00AF     		add	r7, sp, #0
 1727              		.cfi_def_cfa_register 7
 1728 0006 7860     		str	r0, [r7, #4]
1661:..\..\..\Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
 1729              		.loc 1 1661 0
 1730 0008 0023     		movs	r3, #0
 1731 000a FB61     		str	r3, [r7, #28]
1662:..\..\..\Source/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
 1732              		.loc 1 1662 0
 1733 000c 7B68     		ldr	r3, [r7, #4]
 1734 000e BB61     		str	r3, [r7, #24]
 1735              	.LBB33:
 1736              	.LBB34:
 253:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	(
 1737              		.loc 2 253 0
 1738              	@ 253 "../../../Source/portable/GCC/ARM_CM3/portmacro.h" 1
 1739 0010 EFF31182 			mrs r2, basepri											
 1740 0014 4FF0A003 		mov r3, #160												
 1741 0018 83F31188 		msr basepri, r3											
 1742 001c BFF36F8F 		isb														
 1743 0020 BFF34F8F 		dsb														
 1744              	
 1745              	@ 0 "" 2
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 66


 1746              		.thumb
 1747 0024 3A61     		str	r2, [r7, #16]
 1748 0026 FB60     		str	r3, [r7, #12]
 265:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** }
 1749              		.loc 2 265 0
 1750 0028 3B69     		ldr	r3, [r7, #16]
 1751              	.LBE34:
 1752              	.LBE33:
1663:..\..\..\Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
1664:..\..\..\Source/tasks.c **** 
1665:..\..\..\Source/tasks.c **** 		configASSERT( xTaskToResume );
1666:..\..\..\Source/tasks.c **** 
1667:..\..\..\Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1668:..\..\..\Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1669:..\..\..\Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1670:..\..\..\Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1671:..\..\..\Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1672:..\..\..\Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
1673:..\..\..\Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1674:..\..\..\Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1675:..\..\..\Source/tasks.c **** 		been assigned a priority above the configured maximum system call
1676:..\..\..\Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1677:..\..\..\Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1678:..\..\..\Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1679:..\..\..\Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1680:..\..\..\Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1681:..\..\..\Source/tasks.c **** 		provided on the following link:
1682:..\..\..\Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1683:..\..\..\Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1684:..\..\..\Source/tasks.c **** 
1685:..\..\..\Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1753              		.loc 1 1685 0
 1754 002a 7B61     		str	r3, [r7, #20]
1686:..\..\..\Source/tasks.c **** 		{
1687:..\..\..\Source/tasks.c **** 			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 1755              		.loc 1 1687 0
 1756 002c B869     		ldr	r0, [r7, #24]
 1757 002e FFF7FEFF 		bl	prvTaskIsTaskSuspended
 1758 0032 0346     		mov	r3, r0
 1759 0034 002B     		cmp	r3, #0
 1760 0036 31D0     		beq	.L116
1688:..\..\..\Source/tasks.c **** 			{
1689:..\..\..\Source/tasks.c **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1690:..\..\..\Source/tasks.c **** 
1691:..\..\..\Source/tasks.c **** 				/* Check the ready lists can be accessed. */
1692:..\..\..\Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 1761              		.loc 1 1692 0
 1762 0038 1D4B     		ldr	r3, .L121
 1763 003a 1B68     		ldr	r3, [r3]
 1764 003c 002B     		cmp	r3, #0
 1765 003e 27D1     		bne	.L117
1693:..\..\..\Source/tasks.c **** 				{
1694:..\..\..\Source/tasks.c **** 					/* Ready lists can be accessed so move the task from the
1695:..\..\..\Source/tasks.c **** 					suspended list to the ready list directly. */
1696:..\..\..\Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1766              		.loc 1 1696 0
 1767 0040 BB69     		ldr	r3, [r7, #24]
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 67


 1768 0042 DA6A     		ldr	r2, [r3, #44]
 1769 0044 1B4B     		ldr	r3, .L121+4
 1770 0046 1B68     		ldr	r3, [r3]
 1771 0048 DB6A     		ldr	r3, [r3, #44]
 1772 004a 9A42     		cmp	r2, r3
 1773 004c 01D3     		bcc	.L118
1697:..\..\..\Source/tasks.c **** 					{
1698:..\..\..\Source/tasks.c **** 						xYieldRequired = pdTRUE;
 1774              		.loc 1 1698 0
 1775 004e 0123     		movs	r3, #1
 1776 0050 FB61     		str	r3, [r7, #28]
 1777              	.L118:
1699:..\..\..\Source/tasks.c **** 					}
1700:..\..\..\Source/tasks.c **** 					else
1701:..\..\..\Source/tasks.c **** 					{
1702:..\..\..\Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1703:..\..\..\Source/tasks.c **** 					}
1704:..\..\..\Source/tasks.c **** 
1705:..\..\..\Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1778              		.loc 1 1705 0
 1779 0052 BB69     		ldr	r3, [r7, #24]
 1780 0054 0433     		adds	r3, r3, #4
 1781 0056 1846     		mov	r0, r3
 1782 0058 FFF7FEFF 		bl	uxListRemove
1706:..\..\..\Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1783              		.loc 1 1706 0
 1784 005c BB69     		ldr	r3, [r7, #24]
 1785 005e DB6A     		ldr	r3, [r3, #44]
 1786 0060 1A46     		mov	r2, r3
 1787 0062 0123     		movs	r3, #1
 1788 0064 03FA02F2 		lsl	r2, r3, r2
 1789 0068 134B     		ldr	r3, .L121+8
 1790 006a 1B68     		ldr	r3, [r3]
 1791 006c 1343     		orrs	r3, r3, r2
 1792 006e 124A     		ldr	r2, .L121+8
 1793 0070 1360     		str	r3, [r2]
 1794 0072 BB69     		ldr	r3, [r7, #24]
 1795 0074 DA6A     		ldr	r2, [r3, #44]
 1796 0076 1346     		mov	r3, r2
 1797 0078 9B00     		lsls	r3, r3, #2
 1798 007a 1344     		add	r3, r3, r2
 1799 007c 9B00     		lsls	r3, r3, #2
 1800 007e 0F4A     		ldr	r2, .L121+12
 1801 0080 1A44     		add	r2, r2, r3
 1802 0082 BB69     		ldr	r3, [r7, #24]
 1803 0084 0433     		adds	r3, r3, #4
 1804 0086 1046     		mov	r0, r2
 1805 0088 1946     		mov	r1, r3
 1806 008a FFF7FEFF 		bl	vListInsertEnd
 1807 008e 05E0     		b	.L116
 1808              	.L117:
1707:..\..\..\Source/tasks.c **** 				}
1708:..\..\..\Source/tasks.c **** 				else
1709:..\..\..\Source/tasks.c **** 				{
1710:..\..\..\Source/tasks.c **** 					/* The delayed or ready lists cannot be accessed so the task
1711:..\..\..\Source/tasks.c **** 					is held in the pending ready list until the scheduler is
1712:..\..\..\Source/tasks.c **** 					unsuspended. */
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 68


1713:..\..\..\Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 1809              		.loc 1 1713 0
 1810 0090 BB69     		ldr	r3, [r7, #24]
 1811 0092 1833     		adds	r3, r3, #24
 1812 0094 0A48     		ldr	r0, .L121+16
 1813 0096 1946     		mov	r1, r3
 1814 0098 FFF7FEFF 		bl	vListInsertEnd
 1815              	.L116:
 1816 009c 7B69     		ldr	r3, [r7, #20]
 1817 009e BB60     		str	r3, [r7, #8]
 1818              	.LBB35:
 1819              	.LBB36:
 1820              		.loc 2 271 0
 1821 00a0 BB68     		ldr	r3, [r7, #8]
 1822              	@ 271 "../../../Source/portable/GCC/ARM_CM3/portmacro.h" 1
 1823 00a2 83F31188 			msr basepri, r3	
 1824              	@ 0 "" 2
 1825              		.thumb
 1826              	.LBE36:
 1827              	.LBE35:
1714:..\..\..\Source/tasks.c **** 				}
1715:..\..\..\Source/tasks.c **** 			}
1716:..\..\..\Source/tasks.c **** 			else
1717:..\..\..\Source/tasks.c **** 			{
1718:..\..\..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1719:..\..\..\Source/tasks.c **** 			}
1720:..\..\..\Source/tasks.c **** 		}
1721:..\..\..\Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1722:..\..\..\Source/tasks.c **** 
1723:..\..\..\Source/tasks.c **** 		return xYieldRequired;
 1828              		.loc 1 1723 0
 1829 00a6 FB69     		ldr	r3, [r7, #28]
1724:..\..\..\Source/tasks.c **** 	}
 1830              		.loc 1 1724 0
 1831 00a8 1846     		mov	r0, r3
 1832 00aa 2037     		adds	r7, r7, #32
 1833              		.cfi_def_cfa_offset 8
 1834 00ac BD46     		mov	sp, r7
 1835              		.cfi_def_cfa_register 13
 1836              		@ sp needed
 1837 00ae 80BD     		pop	{r7, pc}
 1838              	.L122:
 1839              		.align	2
 1840              	.L121:
 1841 00b0 00010000 		.word	uxSchedulerSuspended
 1842 00b4 00000000 		.word	pxCurrentTCB
 1843 00b8 E0000000 		.word	uxTopReadyPriority
 1844 00bc 04000000 		.word	pxReadyTasksLists
 1845 00c0 98000000 		.word	xPendingReadyList
 1846              		.cfi_endproc
 1847              	.LFE81:
 1848              		.size	xTaskResumeFromISR, .-xTaskResumeFromISR
 1849              		.section	.rodata
 1850              		.align	2
 1851              	.LC0:
 1852 0000 49444C45 		.ascii	"IDLE\000"
 1852      00
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 69


 1853 0005 000000   		.section	.text.vTaskStartScheduler,"ax",%progbits
 1854              		.align	2
 1855              		.global	vTaskStartScheduler
 1856              		.thumb
 1857              		.thumb_func
 1858              		.type	vTaskStartScheduler, %function
 1859              	vTaskStartScheduler:
 1860              	.LFB82:
1725:..\..\..\Source/tasks.c **** 
1726:..\..\..\Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1727:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
1728:..\..\..\Source/tasks.c **** 
1729:..\..\..\Source/tasks.c **** void vTaskStartScheduler( void )
1730:..\..\..\Source/tasks.c **** {
 1861              		.loc 1 1730 0
 1862              		.cfi_startproc
 1863              		@ args = 0, pretend = 0, frame = 8
 1864              		@ frame_needed = 1, uses_anonymous_args = 0
 1865 0000 80B5     		push	{r7, lr}
 1866              		.cfi_def_cfa_offset 8
 1867              		.cfi_offset 7, -8
 1868              		.cfi_offset 14, -4
 1869 0002 84B0     		sub	sp, sp, #16
 1870              		.cfi_def_cfa_offset 24
 1871 0004 02AF     		add	r7, sp, #8
 1872              		.cfi_def_cfa 7, 16
1731:..\..\..\Source/tasks.c **** BaseType_t xReturn;
1732:..\..\..\Source/tasks.c **** 
1733:..\..\..\Source/tasks.c **** 	/* Add the idle task at the lowest priority. */
1734:..\..\..\Source/tasks.c **** 	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
1735:..\..\..\Source/tasks.c **** 	{
1736:..\..\..\Source/tasks.c **** 		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
1737:..\..\..\Source/tasks.c **** 		StackType_t *pxIdleTaskStackBuffer = NULL;
1738:..\..\..\Source/tasks.c **** 		uint32_t ulIdleTaskStackSize;
1739:..\..\..\Source/tasks.c **** 
1740:..\..\..\Source/tasks.c **** 		/* The Idle task is created using user provided RAM - obtain the
1741:..\..\..\Source/tasks.c **** 		address of the RAM then create the idle task. */
1742:..\..\..\Source/tasks.c **** 		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize
1743:..\..\..\Source/tasks.c **** 		xIdleTaskHandle = xTaskCreateStatic( prvIdleTask, "IDLE", ulIdleTaskStackSize, ( void * ) NULL, (
1744:..\..\..\Source/tasks.c **** 
1745:..\..\..\Source/tasks.c **** 		if( xIdleTaskHandle != NULL )
1746:..\..\..\Source/tasks.c **** 		{
1747:..\..\..\Source/tasks.c **** 			xReturn = pdPASS;
1748:..\..\..\Source/tasks.c **** 		}
1749:..\..\..\Source/tasks.c **** 		else
1750:..\..\..\Source/tasks.c **** 		{
1751:..\..\..\Source/tasks.c **** 			xReturn = pdFAIL;
1752:..\..\..\Source/tasks.c **** 		}
1753:..\..\..\Source/tasks.c **** 	}
1754:..\..\..\Source/tasks.c **** 	#else
1755:..\..\..\Source/tasks.c **** 	{
1756:..\..\..\Source/tasks.c **** 		/* The Idle task is being created using dynamically allocated RAM. */
1757:..\..\..\Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, "IDLE", configMINIMAL_STACK_SIZE, ( void * ) NULL, ( tskIDLE_
 1873              		.loc 1 1757 0
 1874 0006 0023     		movs	r3, #0
 1875 0008 0093     		str	r3, [sp]
 1876 000a 124B     		ldr	r3, .L125
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 70


 1877 000c 0193     		str	r3, [sp, #4]
 1878 000e 1248     		ldr	r0, .L125+4
 1879 0010 1249     		ldr	r1, .L125+8
 1880 0012 6422     		movs	r2, #100
 1881 0014 0023     		movs	r3, #0
 1882 0016 FFF7FEFF 		bl	xTaskCreate
 1883 001a 7860     		str	r0, [r7, #4]
1758:..\..\..\Source/tasks.c **** 	}
1759:..\..\..\Source/tasks.c **** 	#endif /* configSUPPORT_STATIC_ALLOCATION */
1760:..\..\..\Source/tasks.c **** 
1761:..\..\..\Source/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1762:..\..\..\Source/tasks.c **** 	{
1763:..\..\..\Source/tasks.c **** 		if( xReturn == pdPASS )
1764:..\..\..\Source/tasks.c **** 		{
1765:..\..\..\Source/tasks.c **** 			xReturn = xTimerCreateTimerTask();
1766:..\..\..\Source/tasks.c **** 		}
1767:..\..\..\Source/tasks.c **** 		else
1768:..\..\..\Source/tasks.c **** 		{
1769:..\..\..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1770:..\..\..\Source/tasks.c **** 		}
1771:..\..\..\Source/tasks.c **** 	}
1772:..\..\..\Source/tasks.c **** 	#endif /* configUSE_TIMERS */
1773:..\..\..\Source/tasks.c **** 
1774:..\..\..\Source/tasks.c **** 	if( xReturn == pdPASS )
 1884              		.loc 1 1774 0
 1885 001c 7B68     		ldr	r3, [r7, #4]
 1886 001e 012B     		cmp	r3, #1
 1887 0020 14D1     		bne	.L123
 1888              	.LBB37:
 1889              	.LBB38:
 237:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	(
 1890              		.loc 2 237 0
 1891              	@ 237 "../../../Source/portable/GCC/ARM_CM3/portmacro.h" 1
 1892 0022 4FF0A003 			mov r3, #160												
 1893 0026 83F31188 		msr basepri, r3											
 1894 002a BFF36F8F 		isb														
 1895 002e BFF34F8F 		dsb														
 1896              	
 1897              	@ 0 "" 2
 1898              		.thumb
 1899 0032 3B60     		str	r3, [r7]
 1900              	.LBE38:
 1901              	.LBE37:
1775:..\..\..\Source/tasks.c **** 	{
1776:..\..\..\Source/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1777:..\..\..\Source/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1778:..\..\..\Source/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1779:..\..\..\Source/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1780:..\..\..\Source/tasks.c **** 		starts to run. */
1781:..\..\..\Source/tasks.c **** 		portDISABLE_INTERRUPTS();
1782:..\..\..\Source/tasks.c **** 
1783:..\..\..\Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
1784:..\..\..\Source/tasks.c **** 		{
1785:..\..\..\Source/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
1786:..\..\..\Source/tasks.c **** 			structure specific to the task that will run first. */
1787:..\..\..\Source/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
1788:..\..\..\Source/tasks.c **** 		}
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 71


1789:..\..\..\Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
1790:..\..\..\Source/tasks.c **** 
1791:..\..\..\Source/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
 1902              		.loc 1 1791 0
 1903 0034 0A4B     		ldr	r3, .L125+12
 1904 0036 4FF0FF32 		mov	r2, #-1
 1905 003a 1A60     		str	r2, [r3]
1792:..\..\..\Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
 1906              		.loc 1 1792 0
 1907 003c 094B     		ldr	r3, .L125+16
 1908 003e 0122     		movs	r2, #1
 1909 0040 1A60     		str	r2, [r3]
1793:..\..\..\Source/tasks.c **** 		xTickCount = ( TickType_t ) 0U;
 1910              		.loc 1 1793 0
 1911 0042 094B     		ldr	r3, .L125+20
 1912 0044 0022     		movs	r2, #0
 1913 0046 1A60     		str	r2, [r3]
1794:..\..\..\Source/tasks.c **** 
1795:..\..\..\Source/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1796:..\..\..\Source/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1797:..\..\..\Source/tasks.c **** 		the run time counter time base. */
1798:..\..\..\Source/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1799:..\..\..\Source/tasks.c **** 
1800:..\..\..\Source/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1801:..\..\..\Source/tasks.c **** 		portable interface. */
1802:..\..\..\Source/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
 1914              		.loc 1 1802 0
 1915 0048 FFF7FEFF 		bl	xPortStartScheduler
 1916              	.L123:
1803:..\..\..\Source/tasks.c **** 		{
1804:..\..\..\Source/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1805:..\..\..\Source/tasks.c **** 			function will not return. */
1806:..\..\..\Source/tasks.c **** 		}
1807:..\..\..\Source/tasks.c **** 		else
1808:..\..\..\Source/tasks.c **** 		{
1809:..\..\..\Source/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1810:..\..\..\Source/tasks.c **** 		}
1811:..\..\..\Source/tasks.c **** 	}
1812:..\..\..\Source/tasks.c **** 	else
1813:..\..\..\Source/tasks.c **** 	{
1814:..\..\..\Source/tasks.c **** 		/* This line will only be reached if the kernel could not be started,
1815:..\..\..\Source/tasks.c **** 		because there was not enough FreeRTOS heap to create the idle task
1816:..\..\..\Source/tasks.c **** 		or the timer task. */
1817:..\..\..\Source/tasks.c **** 		configASSERT( xReturn );
1818:..\..\..\Source/tasks.c **** 	}
1819:..\..\..\Source/tasks.c **** 
1820:..\..\..\Source/tasks.c **** 	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
1821:..\..\..\Source/tasks.c **** 	meaning xIdleTaskHandle is not used anywhere else. */
1822:..\..\..\Source/tasks.c **** 	( void ) xIdleTaskHandle;
1823:..\..\..\Source/tasks.c **** }
 1917              		.loc 1 1823 0
 1918 004c 0837     		adds	r7, r7, #8
 1919              		.cfi_def_cfa_offset 8
 1920 004e BD46     		mov	sp, r7
 1921              		.cfi_def_cfa_register 13
 1922              		@ sp needed
 1923 0050 80BD     		pop	{r7, pc}
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 72


 1924              	.L126:
 1925 0052 00BF     		.align	2
 1926              	.L125:
 1927 0054 FC000000 		.word	xIdleTaskHandle
 1928 0058 00000000 		.word	prvIdleTask
 1929 005c 00000000 		.word	.LC0
 1930 0060 F8000000 		.word	xNextTaskUnblockTime
 1931 0064 E4000000 		.word	xSchedulerRunning
 1932 0068 DC000000 		.word	xTickCount
 1933              		.cfi_endproc
 1934              	.LFE82:
 1935              		.size	vTaskStartScheduler, .-vTaskStartScheduler
 1936              		.section	.text.vTaskEndScheduler,"ax",%progbits
 1937              		.align	2
 1938              		.global	vTaskEndScheduler
 1939              		.thumb
 1940              		.thumb_func
 1941              		.type	vTaskEndScheduler, %function
 1942              	vTaskEndScheduler:
 1943              	.LFB83:
1824:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
1825:..\..\..\Source/tasks.c **** 
1826:..\..\..\Source/tasks.c **** void vTaskEndScheduler( void )
1827:..\..\..\Source/tasks.c **** {
 1944              		.loc 1 1827 0
 1945              		.cfi_startproc
 1946              		@ args = 0, pretend = 0, frame = 8
 1947              		@ frame_needed = 1, uses_anonymous_args = 0
 1948 0000 80B5     		push	{r7, lr}
 1949              		.cfi_def_cfa_offset 8
 1950              		.cfi_offset 7, -8
 1951              		.cfi_offset 14, -4
 1952 0002 82B0     		sub	sp, sp, #8
 1953              		.cfi_def_cfa_offset 16
 1954 0004 00AF     		add	r7, sp, #0
 1955              		.cfi_def_cfa_register 7
 1956              	.LBB39:
 1957              	.LBB40:
 237:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	(
 1958              		.loc 2 237 0
 1959              	@ 237 "../../../Source/portable/GCC/ARM_CM3/portmacro.h" 1
 1960 0006 4FF0A003 			mov r3, #160												
 1961 000a 83F31188 		msr basepri, r3											
 1962 000e BFF36F8F 		isb														
 1963 0012 BFF34F8F 		dsb														
 1964              	
 1965              	@ 0 "" 2
 1966              		.thumb
 1967 0016 7B60     		str	r3, [r7, #4]
 1968              	.LBE40:
 1969              	.LBE39:
1828:..\..\..\Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1829:..\..\..\Source/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
1830:..\..\..\Source/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1831:..\..\..\Source/tasks.c **** 	portDISABLE_INTERRUPTS();
1832:..\..\..\Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
 1970              		.loc 1 1832 0
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 73


 1971 0018 034B     		ldr	r3, .L128
 1972 001a 0022     		movs	r2, #0
 1973 001c 1A60     		str	r2, [r3]
1833:..\..\..\Source/tasks.c **** 	vPortEndScheduler();
 1974              		.loc 1 1833 0
 1975 001e FFF7FEFF 		bl	vPortEndScheduler
1834:..\..\..\Source/tasks.c **** }
 1976              		.loc 1 1834 0
 1977 0022 0837     		adds	r7, r7, #8
 1978              		.cfi_def_cfa_offset 8
 1979 0024 BD46     		mov	sp, r7
 1980              		.cfi_def_cfa_register 13
 1981              		@ sp needed
 1982 0026 80BD     		pop	{r7, pc}
 1983              	.L129:
 1984              		.align	2
 1985              	.L128:
 1986 0028 E4000000 		.word	xSchedulerRunning
 1987              		.cfi_endproc
 1988              	.LFE83:
 1989              		.size	vTaskEndScheduler, .-vTaskEndScheduler
 1990              		.section	.text.vTaskSuspendAll,"ax",%progbits
 1991              		.align	2
 1992              		.global	vTaskSuspendAll
 1993              		.thumb
 1994              		.thumb_func
 1995              		.type	vTaskSuspendAll, %function
 1996              	vTaskSuspendAll:
 1997              	.LFB84:
1835:..\..\..\Source/tasks.c **** /*----------------------------------------------------------*/
1836:..\..\..\Source/tasks.c **** 
1837:..\..\..\Source/tasks.c **** void vTaskSuspendAll( void )
1838:..\..\..\Source/tasks.c **** {
 1998              		.loc 1 1838 0
 1999              		.cfi_startproc
 2000              		@ args = 0, pretend = 0, frame = 0
 2001              		@ frame_needed = 1, uses_anonymous_args = 0
 2002              		@ link register save eliminated.
 2003 0000 80B4     		push	{r7}
 2004              		.cfi_def_cfa_offset 4
 2005              		.cfi_offset 7, -4
 2006 0002 00AF     		add	r7, sp, #0
 2007              		.cfi_def_cfa_register 7
1839:..\..\..\Source/tasks.c **** 	/* A critical section is not required as the variable is of type
1840:..\..\..\Source/tasks.c **** 	BaseType_t.  Please read Richard Barry's reply in the following link to a
1841:..\..\..\Source/tasks.c **** 	post in the FreeRTOS support forum before reporting this as a bug! -
1842:..\..\..\Source/tasks.c **** 	http://goo.gl/wu4acr */
1843:..\..\..\Source/tasks.c **** 	++uxSchedulerSuspended;
 2008              		.loc 1 1843 0
 2009 0004 044B     		ldr	r3, .L131
 2010 0006 1B68     		ldr	r3, [r3]
 2011 0008 0133     		adds	r3, r3, #1
 2012 000a 034A     		ldr	r2, .L131
 2013 000c 1360     		str	r3, [r2]
1844:..\..\..\Source/tasks.c **** }
 2014              		.loc 1 1844 0
 2015 000e BD46     		mov	sp, r7
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 74


 2016              		.cfi_def_cfa_register 13
 2017              		@ sp needed
 2018 0010 5DF8047B 		ldr	r7, [sp], #4
 2019              		.cfi_restore 7
 2020              		.cfi_def_cfa_offset 0
 2021 0014 7047     		bx	lr
 2022              	.L132:
 2023 0016 00BF     		.align	2
 2024              	.L131:
 2025 0018 00010000 		.word	uxSchedulerSuspended
 2026              		.cfi_endproc
 2027              	.LFE84:
 2028              		.size	vTaskSuspendAll, .-vTaskSuspendAll
 2029              		.section	.text.xTaskResumeAll,"ax",%progbits
 2030              		.align	2
 2031              		.global	xTaskResumeAll
 2032              		.thumb
 2033              		.thumb_func
 2034              		.type	xTaskResumeAll, %function
 2035              	xTaskResumeAll:
 2036              	.LFB85:
1845:..\..\..\Source/tasks.c **** /*----------------------------------------------------------*/
1846:..\..\..\Source/tasks.c **** 
1847:..\..\..\Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
1848:..\..\..\Source/tasks.c **** 
1849:..\..\..\Source/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void )
1850:..\..\..\Source/tasks.c **** 	{
1851:..\..\..\Source/tasks.c **** 	TickType_t xReturn;
1852:..\..\..\Source/tasks.c **** 	UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
1853:..\..\..\Source/tasks.c **** 
1854:..\..\..\Source/tasks.c **** 		/* uxHigherPriorityReadyTasks takes care of the case where
1855:..\..\..\Source/tasks.c **** 		configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
1856:..\..\..\Source/tasks.c **** 		task that are in the Ready state, even though the idle task is
1857:..\..\..\Source/tasks.c **** 		running. */
1858:..\..\..\Source/tasks.c **** 		#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
1859:..\..\..\Source/tasks.c **** 		{
1860:..\..\..\Source/tasks.c **** 			if( uxTopReadyPriority > tskIDLE_PRIORITY )
1861:..\..\..\Source/tasks.c **** 			{
1862:..\..\..\Source/tasks.c **** 				uxHigherPriorityReadyTasks = pdTRUE;
1863:..\..\..\Source/tasks.c **** 			}
1864:..\..\..\Source/tasks.c **** 		}
1865:..\..\..\Source/tasks.c **** 		#else
1866:..\..\..\Source/tasks.c **** 		{
1867:..\..\..\Source/tasks.c **** 			const UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;
1868:..\..\..\Source/tasks.c **** 
1869:..\..\..\Source/tasks.c **** 			/* When port optimised task selection is used the uxTopReadyPriority
1870:..\..\..\Source/tasks.c **** 			variable is used as a bit map.  If bits other than the least
1871:..\..\..\Source/tasks.c **** 			significant bit are set then there are tasks that have a priority
1872:..\..\..\Source/tasks.c **** 			above the idle priority that are in the Ready state.  This takes
1873:..\..\..\Source/tasks.c **** 			care of the case where the co-operative scheduler is in use. */
1874:..\..\..\Source/tasks.c **** 			if( uxTopReadyPriority > uxLeastSignificantBit )
1875:..\..\..\Source/tasks.c **** 			{
1876:..\..\..\Source/tasks.c **** 				uxHigherPriorityReadyTasks = pdTRUE;
1877:..\..\..\Source/tasks.c **** 			}
1878:..\..\..\Source/tasks.c **** 		}
1879:..\..\..\Source/tasks.c **** 		#endif
1880:..\..\..\Source/tasks.c **** 
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 75


1881:..\..\..\Source/tasks.c **** 		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
1882:..\..\..\Source/tasks.c **** 		{
1883:..\..\..\Source/tasks.c **** 			xReturn = 0;
1884:..\..\..\Source/tasks.c **** 		}
1885:..\..\..\Source/tasks.c **** 		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
1886:..\..\..\Source/tasks.c **** 		{
1887:..\..\..\Source/tasks.c **** 			/* There are other idle priority tasks in the ready state.  If
1888:..\..\..\Source/tasks.c **** 			time slicing is used then the very next tick interrupt must be
1889:..\..\..\Source/tasks.c **** 			processed. */
1890:..\..\..\Source/tasks.c **** 			xReturn = 0;
1891:..\..\..\Source/tasks.c **** 		}
1892:..\..\..\Source/tasks.c **** 		else if( uxHigherPriorityReadyTasks != pdFALSE )
1893:..\..\..\Source/tasks.c **** 		{
1894:..\..\..\Source/tasks.c **** 			/* There are tasks in the Ready state that have a priority above the
1895:..\..\..\Source/tasks.c **** 			idle priority.  This path can only be reached if
1896:..\..\..\Source/tasks.c **** 			configUSE_PREEMPTION is 0. */
1897:..\..\..\Source/tasks.c **** 			xReturn = 0;
1898:..\..\..\Source/tasks.c **** 		}
1899:..\..\..\Source/tasks.c **** 		else
1900:..\..\..\Source/tasks.c **** 		{
1901:..\..\..\Source/tasks.c **** 			xReturn = xNextTaskUnblockTime - xTickCount;
1902:..\..\..\Source/tasks.c **** 		}
1903:..\..\..\Source/tasks.c **** 
1904:..\..\..\Source/tasks.c **** 		return xReturn;
1905:..\..\..\Source/tasks.c **** 	}
1906:..\..\..\Source/tasks.c **** 
1907:..\..\..\Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
1908:..\..\..\Source/tasks.c **** /*----------------------------------------------------------*/
1909:..\..\..\Source/tasks.c **** 
1910:..\..\..\Source/tasks.c **** BaseType_t xTaskResumeAll( void )
1911:..\..\..\Source/tasks.c **** {
 2037              		.loc 1 1911 0
 2038              		.cfi_startproc
 2039              		@ args = 0, pretend = 0, frame = 16
 2040              		@ frame_needed = 1, uses_anonymous_args = 0
 2041 0000 80B5     		push	{r7, lr}
 2042              		.cfi_def_cfa_offset 8
 2043              		.cfi_offset 7, -8
 2044              		.cfi_offset 14, -4
 2045 0002 84B0     		sub	sp, sp, #16
 2046              		.cfi_def_cfa_offset 24
 2047 0004 00AF     		add	r7, sp, #0
 2048              		.cfi_def_cfa_register 7
1912:..\..\..\Source/tasks.c **** TCB_t *pxTCB = NULL;
 2049              		.loc 1 1912 0
 2050 0006 0023     		movs	r3, #0
 2051 0008 FB60     		str	r3, [r7, #12]
1913:..\..\..\Source/tasks.c **** BaseType_t xAlreadyYielded = pdFALSE;
 2052              		.loc 1 1913 0
 2053 000a 0023     		movs	r3, #0
 2054 000c BB60     		str	r3, [r7, #8]
1914:..\..\..\Source/tasks.c **** 
1915:..\..\..\Source/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
1916:..\..\..\Source/tasks.c **** 	previous call to vTaskSuspendAll(). */
1917:..\..\..\Source/tasks.c **** 	configASSERT( uxSchedulerSuspended );
1918:..\..\..\Source/tasks.c **** 
1919:..\..\..\Source/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 76


1920:..\..\..\Source/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
1921:..\..\..\Source/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
1922:..\..\..\Source/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
1923:..\..\..\Source/tasks.c **** 	tasks from this list into their appropriate ready list. */
1924:..\..\..\Source/tasks.c **** 	taskENTER_CRITICAL();
 2055              		.loc 1 1924 0
 2056 000e FFF7FEFF 		bl	vPortEnterCritical
1925:..\..\..\Source/tasks.c **** 	{
1926:..\..\..\Source/tasks.c **** 		--uxSchedulerSuspended;
 2057              		.loc 1 1926 0
 2058 0012 3A4B     		ldr	r3, .L142
 2059 0014 1B68     		ldr	r3, [r3]
 2060 0016 013B     		subs	r3, r3, #1
 2061 0018 384A     		ldr	r2, .L142
 2062 001a 1360     		str	r3, [r2]
1927:..\..\..\Source/tasks.c **** 
1928:..\..\..\Source/tasks.c **** 		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 2063              		.loc 1 1928 0
 2064 001c 374B     		ldr	r3, .L142
 2065 001e 1B68     		ldr	r3, [r3]
 2066 0020 002B     		cmp	r3, #0
 2067 0022 63D1     		bne	.L134
1929:..\..\..\Source/tasks.c **** 		{
1930:..\..\..\Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 2068              		.loc 1 1930 0
 2069 0024 364B     		ldr	r3, .L142+4
 2070 0026 1B68     		ldr	r3, [r3]
 2071 0028 002B     		cmp	r3, #0
 2072 002a 5FD0     		beq	.L134
1931:..\..\..\Source/tasks.c **** 			{
1932:..\..\..\Source/tasks.c **** 				/* Move any readied tasks from the pending list into the
1933:..\..\..\Source/tasks.c **** 				appropriate ready list. */
1934:..\..\..\Source/tasks.c **** 				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 2073              		.loc 1 1934 0
 2074 002c 30E0     		b	.L135
 2075              	.L136:
1935:..\..\..\Source/tasks.c **** 				{
1936:..\..\..\Source/tasks.c **** 					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 2076              		.loc 1 1936 0
 2077 002e 354B     		ldr	r3, .L142+8
 2078 0030 DB68     		ldr	r3, [r3, #12]
 2079 0032 DB68     		ldr	r3, [r3, #12]
 2080 0034 FB60     		str	r3, [r7, #12]
1937:..\..\..\Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 2081              		.loc 1 1937 0
 2082 0036 FB68     		ldr	r3, [r7, #12]
 2083 0038 1833     		adds	r3, r3, #24
 2084 003a 1846     		mov	r0, r3
 2085 003c FFF7FEFF 		bl	uxListRemove
1938:..\..\..\Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 2086              		.loc 1 1938 0
 2087 0040 FB68     		ldr	r3, [r7, #12]
 2088 0042 0433     		adds	r3, r3, #4
 2089 0044 1846     		mov	r0, r3
 2090 0046 FFF7FEFF 		bl	uxListRemove
1939:..\..\..\Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 2091              		.loc 1 1939 0
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 77


 2092 004a FB68     		ldr	r3, [r7, #12]
 2093 004c DB6A     		ldr	r3, [r3, #44]
 2094 004e 1A46     		mov	r2, r3
 2095 0050 0123     		movs	r3, #1
 2096 0052 03FA02F2 		lsl	r2, r3, r2
 2097 0056 2C4B     		ldr	r3, .L142+12
 2098 0058 1B68     		ldr	r3, [r3]
 2099 005a 1343     		orrs	r3, r3, r2
 2100 005c 2A4A     		ldr	r2, .L142+12
 2101 005e 1360     		str	r3, [r2]
 2102 0060 FB68     		ldr	r3, [r7, #12]
 2103 0062 DA6A     		ldr	r2, [r3, #44]
 2104 0064 1346     		mov	r3, r2
 2105 0066 9B00     		lsls	r3, r3, #2
 2106 0068 1344     		add	r3, r3, r2
 2107 006a 9B00     		lsls	r3, r3, #2
 2108 006c 274A     		ldr	r2, .L142+16
 2109 006e 1A44     		add	r2, r2, r3
 2110 0070 FB68     		ldr	r3, [r7, #12]
 2111 0072 0433     		adds	r3, r3, #4
 2112 0074 1046     		mov	r0, r2
 2113 0076 1946     		mov	r1, r3
 2114 0078 FFF7FEFF 		bl	vListInsertEnd
1940:..\..\..\Source/tasks.c **** 
1941:..\..\..\Source/tasks.c **** 					/* If the moved task has a priority higher than the current
1942:..\..\..\Source/tasks.c **** 					task then a yield must be performed. */
1943:..\..\..\Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2115              		.loc 1 1943 0
 2116 007c FB68     		ldr	r3, [r7, #12]
 2117 007e DA6A     		ldr	r2, [r3, #44]
 2118 0080 234B     		ldr	r3, .L142+20
 2119 0082 1B68     		ldr	r3, [r3]
 2120 0084 DB6A     		ldr	r3, [r3, #44]
 2121 0086 9A42     		cmp	r2, r3
 2122 0088 02D3     		bcc	.L135
1944:..\..\..\Source/tasks.c **** 					{
1945:..\..\..\Source/tasks.c **** 						xYieldPending = pdTRUE;
 2123              		.loc 1 1945 0
 2124 008a 224B     		ldr	r3, .L142+24
 2125 008c 0122     		movs	r2, #1
 2126 008e 1A60     		str	r2, [r3]
 2127              	.L135:
1934:..\..\..\Source/tasks.c **** 				{
 2128              		.loc 1 1934 0
 2129 0090 1C4B     		ldr	r3, .L142+8
 2130 0092 1B68     		ldr	r3, [r3]
 2131 0094 002B     		cmp	r3, #0
 2132 0096 CAD1     		bne	.L136
1946:..\..\..\Source/tasks.c **** 					}
1947:..\..\..\Source/tasks.c **** 					else
1948:..\..\..\Source/tasks.c **** 					{
1949:..\..\..\Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1950:..\..\..\Source/tasks.c **** 					}
1951:..\..\..\Source/tasks.c **** 				}
1952:..\..\..\Source/tasks.c **** 
1953:..\..\..\Source/tasks.c **** 				if( pxTCB != NULL )
 2133              		.loc 1 1953 0
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 78


 2134 0098 FB68     		ldr	r3, [r7, #12]
 2135 009a 002B     		cmp	r3, #0
 2136 009c 01D0     		beq	.L137
1954:..\..\..\Source/tasks.c **** 				{
1955:..\..\..\Source/tasks.c **** 					/* A task was unblocked while the scheduler was suspended,
1956:..\..\..\Source/tasks.c **** 					which may have prevented the next unblock time from being
1957:..\..\..\Source/tasks.c **** 					re-calculated, in which case re-calculate it now.  Mainly
1958:..\..\..\Source/tasks.c **** 					important for low power tickless implementations, where
1959:..\..\..\Source/tasks.c **** 					this can prevent an unnecessary exit from low power
1960:..\..\..\Source/tasks.c **** 					state. */
1961:..\..\..\Source/tasks.c **** 					prvResetNextTaskUnblockTime();
 2137              		.loc 1 1961 0
 2138 009e FFF7FEFF 		bl	prvResetNextTaskUnblockTime
 2139              	.L137:
 2140              	.LBB41:
1962:..\..\..\Source/tasks.c **** 				}
1963:..\..\..\Source/tasks.c **** 
1964:..\..\..\Source/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
1965:..\..\..\Source/tasks.c **** 				they should be processed now.  This ensures the tick count does
1966:..\..\..\Source/tasks.c **** 				not	slip, and that any delayed tasks are resumed at the correct
1967:..\..\..\Source/tasks.c **** 				time. */
1968:..\..\..\Source/tasks.c **** 				{
1969:..\..\..\Source/tasks.c **** 					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 2141              		.loc 1 1969 0
 2142 00a2 1D4B     		ldr	r3, .L142+28
 2143 00a4 1B68     		ldr	r3, [r3]
 2144 00a6 7B60     		str	r3, [r7, #4]
1970:..\..\..\Source/tasks.c **** 
1971:..\..\..\Source/tasks.c **** 					if( uxPendedCounts > ( UBaseType_t ) 0U )
 2145              		.loc 1 1971 0
 2146 00a8 7B68     		ldr	r3, [r7, #4]
 2147 00aa 002B     		cmp	r3, #0
 2148 00ac 10D0     		beq	.L138
 2149              	.L140:
1972:..\..\..\Source/tasks.c **** 					{
1973:..\..\..\Source/tasks.c **** 						do
1974:..\..\..\Source/tasks.c **** 						{
1975:..\..\..\Source/tasks.c **** 							if( xTaskIncrementTick() != pdFALSE )
 2150              		.loc 1 1975 0
 2151 00ae FFF7FEFF 		bl	xTaskIncrementTick
 2152 00b2 0346     		mov	r3, r0
 2153 00b4 002B     		cmp	r3, #0
 2154 00b6 02D0     		beq	.L139
1976:..\..\..\Source/tasks.c **** 							{
1977:..\..\..\Source/tasks.c **** 								xYieldPending = pdTRUE;
 2155              		.loc 1 1977 0
 2156 00b8 164B     		ldr	r3, .L142+24
 2157 00ba 0122     		movs	r2, #1
 2158 00bc 1A60     		str	r2, [r3]
 2159              	.L139:
1978:..\..\..\Source/tasks.c **** 							}
1979:..\..\..\Source/tasks.c **** 							else
1980:..\..\..\Source/tasks.c **** 							{
1981:..\..\..\Source/tasks.c **** 								mtCOVERAGE_TEST_MARKER();
1982:..\..\..\Source/tasks.c **** 							}
1983:..\..\..\Source/tasks.c **** 							--uxPendedCounts;
 2160              		.loc 1 1983 0
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 79


 2161 00be 7B68     		ldr	r3, [r7, #4]
 2162 00c0 013B     		subs	r3, r3, #1
 2163 00c2 7B60     		str	r3, [r7, #4]
1984:..\..\..\Source/tasks.c **** 						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 2164              		.loc 1 1984 0
 2165 00c4 7B68     		ldr	r3, [r7, #4]
 2166 00c6 002B     		cmp	r3, #0
 2167 00c8 F1D1     		bne	.L140
1985:..\..\..\Source/tasks.c **** 
1986:..\..\..\Source/tasks.c **** 						uxPendedTicks = 0;
 2168              		.loc 1 1986 0
 2169 00ca 134B     		ldr	r3, .L142+28
 2170 00cc 0022     		movs	r2, #0
 2171 00ce 1A60     		str	r2, [r3]
 2172              	.L138:
 2173              	.LBE41:
1987:..\..\..\Source/tasks.c **** 					}
1988:..\..\..\Source/tasks.c **** 					else
1989:..\..\..\Source/tasks.c **** 					{
1990:..\..\..\Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1991:..\..\..\Source/tasks.c **** 					}
1992:..\..\..\Source/tasks.c **** 				}
1993:..\..\..\Source/tasks.c **** 
1994:..\..\..\Source/tasks.c **** 				if( xYieldPending != pdFALSE )
 2174              		.loc 1 1994 0
 2175 00d0 104B     		ldr	r3, .L142+24
 2176 00d2 1B68     		ldr	r3, [r3]
 2177 00d4 002B     		cmp	r3, #0
 2178 00d6 09D0     		beq	.L134
1995:..\..\..\Source/tasks.c **** 				{
1996:..\..\..\Source/tasks.c **** 					#if( configUSE_PREEMPTION != 0 )
1997:..\..\..\Source/tasks.c **** 					{
1998:..\..\..\Source/tasks.c **** 						xAlreadyYielded = pdTRUE;
 2179              		.loc 1 1998 0
 2180 00d8 0123     		movs	r3, #1
 2181 00da BB60     		str	r3, [r7, #8]
1999:..\..\..\Source/tasks.c **** 					}
2000:..\..\..\Source/tasks.c **** 					#endif
2001:..\..\..\Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
 2182              		.loc 1 2001 0
 2183 00dc 0F4B     		ldr	r3, .L142+32
 2184 00de 4FF08052 		mov	r2, #268435456
 2185 00e2 1A60     		str	r2, [r3]
 2186              	@ 2001 "..\..\..\Source\tasks.c" 1
 2187 00e4 BFF34F8F 		dsb
 2188              	@ 0 "" 2
 2189              	@ 2001 "..\..\..\Source\tasks.c" 1
 2190 00e8 BFF36F8F 		isb
 2191              	@ 0 "" 2
 2192              		.thumb
 2193              	.L134:
2002:..\..\..\Source/tasks.c **** 				}
2003:..\..\..\Source/tasks.c **** 				else
2004:..\..\..\Source/tasks.c **** 				{
2005:..\..\..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
2006:..\..\..\Source/tasks.c **** 				}
2007:..\..\..\Source/tasks.c **** 			}
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 80


2008:..\..\..\Source/tasks.c **** 		}
2009:..\..\..\Source/tasks.c **** 		else
2010:..\..\..\Source/tasks.c **** 		{
2011:..\..\..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2012:..\..\..\Source/tasks.c **** 		}
2013:..\..\..\Source/tasks.c **** 	}
2014:..\..\..\Source/tasks.c **** 	taskEXIT_CRITICAL();
 2194              		.loc 1 2014 0
 2195 00ec FFF7FEFF 		bl	vPortExitCritical
2015:..\..\..\Source/tasks.c **** 
2016:..\..\..\Source/tasks.c **** 	return xAlreadyYielded;
 2196              		.loc 1 2016 0
 2197 00f0 BB68     		ldr	r3, [r7, #8]
2017:..\..\..\Source/tasks.c **** }
 2198              		.loc 1 2017 0
 2199 00f2 1846     		mov	r0, r3
 2200 00f4 1037     		adds	r7, r7, #16
 2201              		.cfi_def_cfa_offset 8
 2202 00f6 BD46     		mov	sp, r7
 2203              		.cfi_def_cfa_register 13
 2204              		@ sp needed
 2205 00f8 80BD     		pop	{r7, pc}
 2206              	.L143:
 2207 00fa 00BF     		.align	2
 2208              	.L142:
 2209 00fc 00010000 		.word	uxSchedulerSuspended
 2210 0100 D8000000 		.word	uxCurrentNumberOfTasks
 2211 0104 98000000 		.word	xPendingReadyList
 2212 0108 E0000000 		.word	uxTopReadyPriority
 2213 010c 04000000 		.word	pxReadyTasksLists
 2214 0110 00000000 		.word	pxCurrentTCB
 2215 0114 EC000000 		.word	xYieldPending
 2216 0118 E8000000 		.word	uxPendedTicks
 2217 011c 04ED00E0 		.word	-536810236
 2218              		.cfi_endproc
 2219              	.LFE85:
 2220              		.size	xTaskResumeAll, .-xTaskResumeAll
 2221              		.section	.text.xTaskGetTickCount,"ax",%progbits
 2222              		.align	2
 2223              		.global	xTaskGetTickCount
 2224              		.thumb
 2225              		.thumb_func
 2226              		.type	xTaskGetTickCount, %function
 2227              	xTaskGetTickCount:
 2228              	.LFB86:
2018:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
2019:..\..\..\Source/tasks.c **** 
2020:..\..\..\Source/tasks.c **** TickType_t xTaskGetTickCount( void )
2021:..\..\..\Source/tasks.c **** {
 2229              		.loc 1 2021 0
 2230              		.cfi_startproc
 2231              		@ args = 0, pretend = 0, frame = 8
 2232              		@ frame_needed = 1, uses_anonymous_args = 0
 2233              		@ link register save eliminated.
 2234 0000 80B4     		push	{r7}
 2235              		.cfi_def_cfa_offset 4
 2236              		.cfi_offset 7, -4
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 81


 2237 0002 83B0     		sub	sp, sp, #12
 2238              		.cfi_def_cfa_offset 16
 2239 0004 00AF     		add	r7, sp, #0
 2240              		.cfi_def_cfa_register 7
2022:..\..\..\Source/tasks.c **** TickType_t xTicks;
2023:..\..\..\Source/tasks.c **** 
2024:..\..\..\Source/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
2025:..\..\..\Source/tasks.c **** 	portTICK_TYPE_ENTER_CRITICAL();
2026:..\..\..\Source/tasks.c **** 	{
2027:..\..\..\Source/tasks.c **** 		xTicks = xTickCount;
 2241              		.loc 1 2027 0
 2242 0006 054B     		ldr	r3, .L146
 2243 0008 1B68     		ldr	r3, [r3]
 2244 000a 7B60     		str	r3, [r7, #4]
2028:..\..\..\Source/tasks.c **** 	}
2029:..\..\..\Source/tasks.c **** 	portTICK_TYPE_EXIT_CRITICAL();
2030:..\..\..\Source/tasks.c **** 
2031:..\..\..\Source/tasks.c **** 	return xTicks;
 2245              		.loc 1 2031 0
 2246 000c 7B68     		ldr	r3, [r7, #4]
2032:..\..\..\Source/tasks.c **** }
 2247              		.loc 1 2032 0
 2248 000e 1846     		mov	r0, r3
 2249 0010 0C37     		adds	r7, r7, #12
 2250              		.cfi_def_cfa_offset 4
 2251 0012 BD46     		mov	sp, r7
 2252              		.cfi_def_cfa_register 13
 2253              		@ sp needed
 2254 0014 5DF8047B 		ldr	r7, [sp], #4
 2255              		.cfi_restore 7
 2256              		.cfi_def_cfa_offset 0
 2257 0018 7047     		bx	lr
 2258              	.L147:
 2259 001a 00BF     		.align	2
 2260              	.L146:
 2261 001c DC000000 		.word	xTickCount
 2262              		.cfi_endproc
 2263              	.LFE86:
 2264              		.size	xTaskGetTickCount, .-xTaskGetTickCount
 2265              		.section	.text.xTaskGetTickCountFromISR,"ax",%progbits
 2266              		.align	2
 2267              		.global	xTaskGetTickCountFromISR
 2268              		.thumb
 2269              		.thumb_func
 2270              		.type	xTaskGetTickCountFromISR, %function
 2271              	xTaskGetTickCountFromISR:
 2272              	.LFB87:
2033:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
2034:..\..\..\Source/tasks.c **** 
2035:..\..\..\Source/tasks.c **** TickType_t xTaskGetTickCountFromISR( void )
2036:..\..\..\Source/tasks.c **** {
 2273              		.loc 1 2036 0
 2274              		.cfi_startproc
 2275              		@ args = 0, pretend = 0, frame = 8
 2276              		@ frame_needed = 1, uses_anonymous_args = 0
 2277              		@ link register save eliminated.
 2278 0000 80B4     		push	{r7}
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 82


 2279              		.cfi_def_cfa_offset 4
 2280              		.cfi_offset 7, -4
 2281 0002 83B0     		sub	sp, sp, #12
 2282              		.cfi_def_cfa_offset 16
 2283 0004 00AF     		add	r7, sp, #0
 2284              		.cfi_def_cfa_register 7
2037:..\..\..\Source/tasks.c **** TickType_t xReturn;
2038:..\..\..\Source/tasks.c **** UBaseType_t uxSavedInterruptStatus;
2039:..\..\..\Source/tasks.c **** 
2040:..\..\..\Source/tasks.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
2041:..\..\..\Source/tasks.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
2042:..\..\..\Source/tasks.c **** 	above the maximum system call priority are kept permanently enabled, even
2043:..\..\..\Source/tasks.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
2044:..\..\..\Source/tasks.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
2045:..\..\..\Source/tasks.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
2046:..\..\..\Source/tasks.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
2047:..\..\..\Source/tasks.c **** 	assigned a priority above the configured maximum system call priority.
2048:..\..\..\Source/tasks.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
2049:..\..\..\Source/tasks.c **** 	that have been assigned a priority at or (logically) below the maximum
2050:..\..\..\Source/tasks.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
2051:..\..\..\Source/tasks.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
2052:..\..\..\Source/tasks.c **** 	More information (albeit Cortex-M specific) is provided on the following
2053:..\..\..\Source/tasks.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
2054:..\..\..\Source/tasks.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
2055:..\..\..\Source/tasks.c **** 
2056:..\..\..\Source/tasks.c **** 	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
 2285              		.loc 1 2056 0
 2286 0006 0023     		movs	r3, #0
 2287 0008 7B60     		str	r3, [r7, #4]
2057:..\..\..\Source/tasks.c **** 	{
2058:..\..\..\Source/tasks.c **** 		xReturn = xTickCount;
 2288              		.loc 1 2058 0
 2289 000a 054B     		ldr	r3, .L150
 2290 000c 1B68     		ldr	r3, [r3]
 2291 000e 3B60     		str	r3, [r7]
2059:..\..\..\Source/tasks.c **** 	}
2060:..\..\..\Source/tasks.c **** 	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2061:..\..\..\Source/tasks.c **** 
2062:..\..\..\Source/tasks.c **** 	return xReturn;
 2292              		.loc 1 2062 0
 2293 0010 3B68     		ldr	r3, [r7]
2063:..\..\..\Source/tasks.c **** }
 2294              		.loc 1 2063 0
 2295 0012 1846     		mov	r0, r3
 2296 0014 0C37     		adds	r7, r7, #12
 2297              		.cfi_def_cfa_offset 4
 2298 0016 BD46     		mov	sp, r7
 2299              		.cfi_def_cfa_register 13
 2300              		@ sp needed
 2301 0018 5DF8047B 		ldr	r7, [sp], #4
 2302              		.cfi_restore 7
 2303              		.cfi_def_cfa_offset 0
 2304 001c 7047     		bx	lr
 2305              	.L151:
 2306 001e 00BF     		.align	2
 2307              	.L150:
 2308 0020 DC000000 		.word	xTickCount
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 83


 2309              		.cfi_endproc
 2310              	.LFE87:
 2311              		.size	xTaskGetTickCountFromISR, .-xTaskGetTickCountFromISR
 2312              		.section	.text.uxTaskGetNumberOfTasks,"ax",%progbits
 2313              		.align	2
 2314              		.global	uxTaskGetNumberOfTasks
 2315              		.thumb
 2316              		.thumb_func
 2317              		.type	uxTaskGetNumberOfTasks, %function
 2318              	uxTaskGetNumberOfTasks:
 2319              	.LFB88:
2064:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
2065:..\..\..\Source/tasks.c **** 
2066:..\..\..\Source/tasks.c **** UBaseType_t uxTaskGetNumberOfTasks( void )
2067:..\..\..\Source/tasks.c **** {
 2320              		.loc 1 2067 0
 2321              		.cfi_startproc
 2322              		@ args = 0, pretend = 0, frame = 0
 2323              		@ frame_needed = 1, uses_anonymous_args = 0
 2324              		@ link register save eliminated.
 2325 0000 80B4     		push	{r7}
 2326              		.cfi_def_cfa_offset 4
 2327              		.cfi_offset 7, -4
 2328 0002 00AF     		add	r7, sp, #0
 2329              		.cfi_def_cfa_register 7
2068:..\..\..\Source/tasks.c **** 	/* A critical section is not required because the variables are of type
2069:..\..\..\Source/tasks.c **** 	BaseType_t. */
2070:..\..\..\Source/tasks.c **** 	return uxCurrentNumberOfTasks;
 2330              		.loc 1 2070 0
 2331 0004 034B     		ldr	r3, .L154
 2332 0006 1B68     		ldr	r3, [r3]
2071:..\..\..\Source/tasks.c **** }
 2333              		.loc 1 2071 0
 2334 0008 1846     		mov	r0, r3
 2335 000a BD46     		mov	sp, r7
 2336              		.cfi_def_cfa_register 13
 2337              		@ sp needed
 2338 000c 5DF8047B 		ldr	r7, [sp], #4
 2339              		.cfi_restore 7
 2340              		.cfi_def_cfa_offset 0
 2341 0010 7047     		bx	lr
 2342              	.L155:
 2343 0012 00BF     		.align	2
 2344              	.L154:
 2345 0014 D8000000 		.word	uxCurrentNumberOfTasks
 2346              		.cfi_endproc
 2347              	.LFE88:
 2348              		.size	uxTaskGetNumberOfTasks, .-uxTaskGetNumberOfTasks
 2349              		.section	.text.pcTaskGetName,"ax",%progbits
 2350              		.align	2
 2351              		.global	pcTaskGetName
 2352              		.thumb
 2353              		.thumb_func
 2354              		.type	pcTaskGetName, %function
 2355              	pcTaskGetName:
 2356              	.LFB89:
2072:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 84


2073:..\..\..\Source/tasks.c **** 
2074:..\..\..\Source/tasks.c **** char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed fo
2075:..\..\..\Source/tasks.c **** {
 2357              		.loc 1 2075 0
 2358              		.cfi_startproc
 2359              		@ args = 0, pretend = 0, frame = 16
 2360              		@ frame_needed = 1, uses_anonymous_args = 0
 2361              		@ link register save eliminated.
 2362 0000 80B4     		push	{r7}
 2363              		.cfi_def_cfa_offset 4
 2364              		.cfi_offset 7, -4
 2365 0002 85B0     		sub	sp, sp, #20
 2366              		.cfi_def_cfa_offset 24
 2367 0004 00AF     		add	r7, sp, #0
 2368              		.cfi_def_cfa_register 7
 2369 0006 7860     		str	r0, [r7, #4]
2076:..\..\..\Source/tasks.c **** TCB_t *pxTCB;
2077:..\..\..\Source/tasks.c **** 
2078:..\..\..\Source/tasks.c **** 	/* If null is passed in here then the name of the calling task is being
2079:..\..\..\Source/tasks.c **** 	queried. */
2080:..\..\..\Source/tasks.c **** 	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 2370              		.loc 1 2080 0
 2371 0008 7B68     		ldr	r3, [r7, #4]
 2372 000a 002B     		cmp	r3, #0
 2373 000c 02D1     		bne	.L157
 2374              		.loc 1 2080 0 is_stmt 0 discriminator 1
 2375 000e 064B     		ldr	r3, .L160
 2376 0010 1B68     		ldr	r3, [r3]
 2377 0012 00E0     		b	.L158
 2378              	.L157:
 2379              		.loc 1 2080 0 discriminator 2
 2380 0014 7B68     		ldr	r3, [r7, #4]
 2381              	.L158:
 2382              		.loc 1 2080 0 discriminator 4
 2383 0016 FB60     		str	r3, [r7, #12]
2081:..\..\..\Source/tasks.c **** 	configASSERT( pxTCB );
2082:..\..\..\Source/tasks.c **** 	return &( pxTCB->pcTaskName[ 0 ] );
 2384              		.loc 1 2082 0 is_stmt 1 discriminator 4
 2385 0018 FB68     		ldr	r3, [r7, #12]
 2386 001a 3433     		adds	r3, r3, #52
2083:..\..\..\Source/tasks.c **** }
 2387              		.loc 1 2083 0 discriminator 4
 2388 001c 1846     		mov	r0, r3
 2389 001e 1437     		adds	r7, r7, #20
 2390              		.cfi_def_cfa_offset 4
 2391 0020 BD46     		mov	sp, r7
 2392              		.cfi_def_cfa_register 13
 2393              		@ sp needed
 2394 0022 5DF8047B 		ldr	r7, [sp], #4
 2395              		.cfi_restore 7
 2396              		.cfi_def_cfa_offset 0
 2397 0026 7047     		bx	lr
 2398              	.L161:
 2399              		.align	2
 2400              	.L160:
 2401 0028 00000000 		.word	pxCurrentTCB
 2402              		.cfi_endproc
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 85


 2403              	.LFE89:
 2404              		.size	pcTaskGetName, .-pcTaskGetName
 2405              		.section	.text.xTaskIncrementTick,"ax",%progbits
 2406              		.align	2
 2407              		.global	xTaskIncrementTick
 2408              		.thumb
 2409              		.thumb_func
 2410              		.type	xTaskIncrementTick, %function
 2411              	xTaskIncrementTick:
 2412              	.LFB90:
2084:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
2085:..\..\..\Source/tasks.c **** 
2086:..\..\..\Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
2087:..\..\..\Source/tasks.c **** 
2088:..\..\..\Source/tasks.c **** 	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] )
2089:..\..\..\Source/tasks.c **** 	{
2090:..\..\..\Source/tasks.c **** 	TCB_t *pxNextTCB, *pxFirstTCB, *pxReturn = NULL;
2091:..\..\..\Source/tasks.c **** 	UBaseType_t x;
2092:..\..\..\Source/tasks.c **** 	char cNextChar;
2093:..\..\..\Source/tasks.c **** 
2094:..\..\..\Source/tasks.c **** 		/* This function is called with the scheduler suspended. */
2095:..\..\..\Source/tasks.c **** 
2096:..\..\..\Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
2097:..\..\..\Source/tasks.c **** 		{
2098:..\..\..\Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2099:..\..\..\Source/tasks.c **** 
2100:..\..\..\Source/tasks.c **** 			do
2101:..\..\..\Source/tasks.c **** 			{
2102:..\..\..\Source/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2103:..\..\..\Source/tasks.c **** 
2104:..\..\..\Source/tasks.c **** 				/* Check each character in the name looking for a match or
2105:..\..\..\Source/tasks.c **** 				mismatch. */
2106:..\..\..\Source/tasks.c **** 				for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
2107:..\..\..\Source/tasks.c **** 				{
2108:..\..\..\Source/tasks.c **** 					cNextChar = pxNextTCB->pcTaskName[ x ];
2109:..\..\..\Source/tasks.c **** 
2110:..\..\..\Source/tasks.c **** 					if( cNextChar != pcNameToQuery[ x ] )
2111:..\..\..\Source/tasks.c **** 					{
2112:..\..\..\Source/tasks.c **** 						/* Characters didn't match. */
2113:..\..\..\Source/tasks.c **** 						break;
2114:..\..\..\Source/tasks.c **** 					}
2115:..\..\..\Source/tasks.c **** 					else if( cNextChar == 0x00 )
2116:..\..\..\Source/tasks.c **** 					{
2117:..\..\..\Source/tasks.c **** 						/* Both strings terminated, a match must have been
2118:..\..\..\Source/tasks.c **** 						found. */
2119:..\..\..\Source/tasks.c **** 						pxReturn = pxNextTCB;
2120:..\..\..\Source/tasks.c **** 						break;
2121:..\..\..\Source/tasks.c **** 					}
2122:..\..\..\Source/tasks.c **** 					else
2123:..\..\..\Source/tasks.c **** 					{
2124:..\..\..\Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2125:..\..\..\Source/tasks.c **** 					}
2126:..\..\..\Source/tasks.c **** 				}
2127:..\..\..\Source/tasks.c **** 
2128:..\..\..\Source/tasks.c **** 				if( pxReturn != NULL )
2129:..\..\..\Source/tasks.c **** 				{
2130:..\..\..\Source/tasks.c **** 					/* The handle has been found. */
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 86


2131:..\..\..\Source/tasks.c **** 					break;
2132:..\..\..\Source/tasks.c **** 				}
2133:..\..\..\Source/tasks.c **** 
2134:..\..\..\Source/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
2135:..\..\..\Source/tasks.c **** 		}
2136:..\..\..\Source/tasks.c **** 		else
2137:..\..\..\Source/tasks.c **** 		{
2138:..\..\..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2139:..\..\..\Source/tasks.c **** 		}
2140:..\..\..\Source/tasks.c **** 
2141:..\..\..\Source/tasks.c **** 		return pxReturn;
2142:..\..\..\Source/tasks.c **** 	}
2143:..\..\..\Source/tasks.c **** 
2144:..\..\..\Source/tasks.c **** #endif /* INCLUDE_xTaskGetHandle */
2145:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
2146:..\..\..\Source/tasks.c **** 
2147:..\..\..\Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
2148:..\..\..\Source/tasks.c **** 
2149:..\..\..\Source/tasks.c **** 	TaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) /*lint !e971 Unqualified char types are a
2150:..\..\..\Source/tasks.c **** 	{
2151:..\..\..\Source/tasks.c **** 	UBaseType_t uxQueue = configMAX_PRIORITIES;
2152:..\..\..\Source/tasks.c **** 	TCB_t* pxTCB;
2153:..\..\..\Source/tasks.c **** 
2154:..\..\..\Source/tasks.c **** 		/* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */
2155:..\..\..\Source/tasks.c **** 		configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );
2156:..\..\..\Source/tasks.c **** 
2157:..\..\..\Source/tasks.c **** 		vTaskSuspendAll();
2158:..\..\..\Source/tasks.c **** 		{
2159:..\..\..\Source/tasks.c **** 			/* Search the ready lists. */
2160:..\..\..\Source/tasks.c **** 			do
2161:..\..\..\Source/tasks.c **** 			{
2162:..\..\..\Source/tasks.c **** 				uxQueue--;
2163:..\..\..\Source/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &( pxReadyTasksLists[ uxQueue ] ), pcNam
2164:..\..\..\Source/tasks.c **** 
2165:..\..\..\Source/tasks.c **** 				if( pxTCB != NULL )
2166:..\..\..\Source/tasks.c **** 				{
2167:..\..\..\Source/tasks.c **** 					/* Found the handle. */
2168:..\..\..\Source/tasks.c **** 					break;
2169:..\..\..\Source/tasks.c **** 				}
2170:..\..\..\Source/tasks.c **** 
2171:..\..\..\Source/tasks.c **** 			} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts
2172:..\..\..\Source/tasks.c **** 
2173:..\..\..\Source/tasks.c **** 			/* Search the delayed lists. */
2174:..\..\..\Source/tasks.c **** 			if( pxTCB == NULL )
2175:..\..\..\Source/tasks.c **** 			{
2176:..\..\..\Source/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQuery );
2177:..\..\..\Source/tasks.c **** 			}
2178:..\..\..\Source/tasks.c **** 
2179:..\..\..\Source/tasks.c **** 			if( pxTCB == NULL )
2180:..\..\..\Source/tasks.c **** 			{
2181:..\..\..\Source/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, pcNameToQuery
2182:..\..\..\Source/tasks.c **** 			}
2183:..\..\..\Source/tasks.c **** 
2184:..\..\..\Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
2185:..\..\..\Source/tasks.c **** 			{
2186:..\..\..\Source/tasks.c **** 				if( pxTCB == NULL )
2187:..\..\..\Source/tasks.c **** 				{
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 87


2188:..\..\..\Source/tasks.c **** 					/* Search the suspended list. */
2189:..\..\..\Source/tasks.c **** 					pxTCB = prvSearchForNameWithinSingleList( &xSuspendedTaskList, pcNameToQuery );
2190:..\..\..\Source/tasks.c **** 				}
2191:..\..\..\Source/tasks.c **** 			}
2192:..\..\..\Source/tasks.c **** 			#endif
2193:..\..\..\Source/tasks.c **** 
2194:..\..\..\Source/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
2195:..\..\..\Source/tasks.c **** 			{
2196:..\..\..\Source/tasks.c **** 				if( pxTCB == NULL )
2197:..\..\..\Source/tasks.c **** 				{
2198:..\..\..\Source/tasks.c **** 					/* Search the deleted list. */
2199:..\..\..\Source/tasks.c **** 					pxTCB = prvSearchForNameWithinSingleList( &xTasksWaitingTermination, pcNameToQuery );
2200:..\..\..\Source/tasks.c **** 				}
2201:..\..\..\Source/tasks.c **** 			}
2202:..\..\..\Source/tasks.c **** 			#endif
2203:..\..\..\Source/tasks.c **** 		}
2204:..\..\..\Source/tasks.c **** 		( void ) xTaskResumeAll();
2205:..\..\..\Source/tasks.c **** 
2206:..\..\..\Source/tasks.c **** 		return ( TaskHandle_t ) pxTCB;
2207:..\..\..\Source/tasks.c **** 	}
2208:..\..\..\Source/tasks.c **** 
2209:..\..\..\Source/tasks.c **** #endif /* INCLUDE_xTaskGetHandle */
2210:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
2211:..\..\..\Source/tasks.c **** 
2212:..\..\..\Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2213:..\..\..\Source/tasks.c **** 
2214:..\..\..\Source/tasks.c **** 	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArra
2215:..\..\..\Source/tasks.c **** 	{
2216:..\..\..\Source/tasks.c **** 	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
2217:..\..\..\Source/tasks.c **** 
2218:..\..\..\Source/tasks.c **** 		vTaskSuspendAll();
2219:..\..\..\Source/tasks.c **** 		{
2220:..\..\..\Source/tasks.c **** 			/* Is there a space in the array for each task in the system? */
2221:..\..\..\Source/tasks.c **** 			if( uxArraySize >= uxCurrentNumberOfTasks )
2222:..\..\..\Source/tasks.c **** 			{
2223:..\..\..\Source/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
2224:..\..\..\Source/tasks.c **** 				task in the Ready state. */
2225:..\..\..\Source/tasks.c **** 				do
2226:..\..\..\Source/tasks.c **** 				{
2227:..\..\..\Source/tasks.c **** 					uxQueue--;
2228:..\..\..\Source/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists
2229:..\..\..\Source/tasks.c **** 
2230:..\..\..\Source/tasks.c **** 				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the cast
2231:..\..\..\Source/tasks.c **** 
2232:..\..\..\Source/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
2233:..\..\..\Source/tasks.c **** 				task in the Blocked state. */
2234:..\..\..\Source/tasks.c **** 				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelaye
2235:..\..\..\Source/tasks.c **** 				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverfl
2236:..\..\..\Source/tasks.c **** 
2237:..\..\..\Source/tasks.c **** 				#if( INCLUDE_vTaskDelete == 1 )
2238:..\..\..\Source/tasks.c **** 				{
2239:..\..\..\Source/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
2240:..\..\..\Source/tasks.c **** 					each task that has been deleted but not yet cleaned up. */
2241:..\..\..\Source/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermin
2242:..\..\..\Source/tasks.c **** 				}
2243:..\..\..\Source/tasks.c **** 				#endif
2244:..\..\..\Source/tasks.c **** 
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 88


2245:..\..\..\Source/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
2246:..\..\..\Source/tasks.c **** 				{
2247:..\..\..\Source/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
2248:..\..\..\Source/tasks.c **** 					each task in the Suspended state. */
2249:..\..\..\Source/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList,
2250:..\..\..\Source/tasks.c **** 				}
2251:..\..\..\Source/tasks.c **** 				#endif
2252:..\..\..\Source/tasks.c **** 
2253:..\..\..\Source/tasks.c **** 				#if ( configGENERATE_RUN_TIME_STATS == 1)
2254:..\..\..\Source/tasks.c **** 				{
2255:..\..\..\Source/tasks.c **** 					if( pulTotalRunTime != NULL )
2256:..\..\..\Source/tasks.c **** 					{
2257:..\..\..\Source/tasks.c **** 						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2258:..\..\..\Source/tasks.c **** 							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
2259:..\..\..\Source/tasks.c **** 						#else
2260:..\..\..\Source/tasks.c **** 							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2261:..\..\..\Source/tasks.c **** 						#endif
2262:..\..\..\Source/tasks.c **** 					}
2263:..\..\..\Source/tasks.c **** 				}
2264:..\..\..\Source/tasks.c **** 				#else
2265:..\..\..\Source/tasks.c **** 				{
2266:..\..\..\Source/tasks.c **** 					if( pulTotalRunTime != NULL )
2267:..\..\..\Source/tasks.c **** 					{
2268:..\..\..\Source/tasks.c **** 						*pulTotalRunTime = 0;
2269:..\..\..\Source/tasks.c **** 					}
2270:..\..\..\Source/tasks.c **** 				}
2271:..\..\..\Source/tasks.c **** 				#endif
2272:..\..\..\Source/tasks.c **** 			}
2273:..\..\..\Source/tasks.c **** 			else
2274:..\..\..\Source/tasks.c **** 			{
2275:..\..\..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2276:..\..\..\Source/tasks.c **** 			}
2277:..\..\..\Source/tasks.c **** 		}
2278:..\..\..\Source/tasks.c **** 		( void ) xTaskResumeAll();
2279:..\..\..\Source/tasks.c **** 
2280:..\..\..\Source/tasks.c **** 		return uxTask;
2281:..\..\..\Source/tasks.c **** 	}
2282:..\..\..\Source/tasks.c **** 
2283:..\..\..\Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2284:..\..\..\Source/tasks.c **** /*----------------------------------------------------------*/
2285:..\..\..\Source/tasks.c **** 
2286:..\..\..\Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
2287:..\..\..\Source/tasks.c **** 
2288:..\..\..\Source/tasks.c **** 	TaskHandle_t xTaskGetIdleTaskHandle( void )
2289:..\..\..\Source/tasks.c **** 	{
2290:..\..\..\Source/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
2291:..\..\..\Source/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
2292:..\..\..\Source/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
2293:..\..\..\Source/tasks.c **** 		return xIdleTaskHandle;
2294:..\..\..\Source/tasks.c **** 	}
2295:..\..\..\Source/tasks.c **** 
2296:..\..\..\Source/tasks.c **** #endif /* INCLUDE_xTaskGetIdleTaskHandle */
2297:..\..\..\Source/tasks.c **** /*----------------------------------------------------------*/
2298:..\..\..\Source/tasks.c **** 
2299:..\..\..\Source/tasks.c **** /* This conditional compilation should use inequality to 0, not equality to 1.
2300:..\..\..\Source/tasks.c **** This is to ensure vTaskStepTick() is available when user defined low power mode
2301:..\..\..\Source/tasks.c **** implementations require configUSE_TICKLESS_IDLE to be set to a value other than
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 89


2302:..\..\..\Source/tasks.c **** 1. */
2303:..\..\..\Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
2304:..\..\..\Source/tasks.c **** 
2305:..\..\..\Source/tasks.c **** 	void vTaskStepTick( const TickType_t xTicksToJump )
2306:..\..\..\Source/tasks.c **** 	{
2307:..\..\..\Source/tasks.c **** 		/* Correct the tick count value after a period during which the tick
2308:..\..\..\Source/tasks.c **** 		was suppressed.  Note this does *not* call the tick hook function for
2309:..\..\..\Source/tasks.c **** 		each stepped tick. */
2310:..\..\..\Source/tasks.c **** 		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
2311:..\..\..\Source/tasks.c **** 		xTickCount += xTicksToJump;
2312:..\..\..\Source/tasks.c **** 		traceINCREASE_TICK_COUNT( xTicksToJump );
2313:..\..\..\Source/tasks.c **** 	}
2314:..\..\..\Source/tasks.c **** 
2315:..\..\..\Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2316:..\..\..\Source/tasks.c **** /*----------------------------------------------------------*/
2317:..\..\..\Source/tasks.c **** 
2318:..\..\..\Source/tasks.c **** #if ( INCLUDE_xTaskAbortDelay == 1 )
2319:..\..\..\Source/tasks.c **** 
2320:..\..\..\Source/tasks.c **** 	BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
2321:..\..\..\Source/tasks.c **** 	{
2322:..\..\..\Source/tasks.c **** 	TCB_t *pxTCB = ( TCB_t * ) xTask;
2323:..\..\..\Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
2324:..\..\..\Source/tasks.c **** 
2325:..\..\..\Source/tasks.c **** 		configASSERT( pxTCB );
2326:..\..\..\Source/tasks.c **** 
2327:..\..\..\Source/tasks.c **** 		vTaskSuspendAll();
2328:..\..\..\Source/tasks.c **** 		{
2329:..\..\..\Source/tasks.c **** 			/* A task can only be prematurely removed from the Blocked state if
2330:..\..\..\Source/tasks.c **** 			it is actually in the Blocked state. */
2331:..\..\..\Source/tasks.c **** 			if( eTaskGetState( xTask ) == eBlocked )
2332:..\..\..\Source/tasks.c **** 			{
2333:..\..\..\Source/tasks.c **** 				/* Remove the reference to the task from the blocked list.  An
2334:..\..\..\Source/tasks.c **** 				interrupt won't touch the xStateListItem because the
2335:..\..\..\Source/tasks.c **** 				scheduler is suspended. */
2336:..\..\..\Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2337:..\..\..\Source/tasks.c **** 
2338:..\..\..\Source/tasks.c **** 				/* Is the task waiting on an event also?  If so remove it from
2339:..\..\..\Source/tasks.c **** 				the event list too.  Interrupts can touch the event list item,
2340:..\..\..\Source/tasks.c **** 				even though the scheduler is suspended, so a critical section
2341:..\..\..\Source/tasks.c **** 				is used. */
2342:..\..\..\Source/tasks.c **** 				taskENTER_CRITICAL();
2343:..\..\..\Source/tasks.c **** 				{
2344:..\..\..\Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2345:..\..\..\Source/tasks.c **** 					{
2346:..\..\..\Source/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2347:..\..\..\Source/tasks.c **** 						pxTCB->ucDelayAborted = pdTRUE;
2348:..\..\..\Source/tasks.c **** 					}
2349:..\..\..\Source/tasks.c **** 					else
2350:..\..\..\Source/tasks.c **** 					{
2351:..\..\..\Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2352:..\..\..\Source/tasks.c **** 					}
2353:..\..\..\Source/tasks.c **** 				}
2354:..\..\..\Source/tasks.c **** 				taskEXIT_CRITICAL();
2355:..\..\..\Source/tasks.c **** 
2356:..\..\..\Source/tasks.c **** 				/* Place the unblocked task into the appropriate ready list. */
2357:..\..\..\Source/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
2358:..\..\..\Source/tasks.c **** 
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 90


2359:..\..\..\Source/tasks.c **** 				/* A task being unblocked cannot cause an immediate context
2360:..\..\..\Source/tasks.c **** 				switch if preemption is turned off. */
2361:..\..\..\Source/tasks.c **** 				#if (  configUSE_PREEMPTION == 1 )
2362:..\..\..\Source/tasks.c **** 				{
2363:..\..\..\Source/tasks.c **** 					/* Preemption is on, but a context switch should only be
2364:..\..\..\Source/tasks.c **** 					performed if the unblocked task has a priority that is
2365:..\..\..\Source/tasks.c **** 					equal to or higher than the currently executing task. */
2366:..\..\..\Source/tasks.c **** 					if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
2367:..\..\..\Source/tasks.c **** 					{
2368:..\..\..\Source/tasks.c **** 						/* Pend the yield to be performed when the scheduler
2369:..\..\..\Source/tasks.c **** 						is unsuspended. */
2370:..\..\..\Source/tasks.c **** 						xYieldPending = pdTRUE;
2371:..\..\..\Source/tasks.c **** 					}
2372:..\..\..\Source/tasks.c **** 					else
2373:..\..\..\Source/tasks.c **** 					{
2374:..\..\..\Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2375:..\..\..\Source/tasks.c **** 					}
2376:..\..\..\Source/tasks.c **** 				}
2377:..\..\..\Source/tasks.c **** 				#endif /* configUSE_PREEMPTION */
2378:..\..\..\Source/tasks.c **** 			}
2379:..\..\..\Source/tasks.c **** 			else
2380:..\..\..\Source/tasks.c **** 			{
2381:..\..\..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2382:..\..\..\Source/tasks.c **** 			}
2383:..\..\..\Source/tasks.c **** 		}
2384:..\..\..\Source/tasks.c **** 		xTaskResumeAll();
2385:..\..\..\Source/tasks.c **** 
2386:..\..\..\Source/tasks.c **** 		return xReturn;
2387:..\..\..\Source/tasks.c **** 	}
2388:..\..\..\Source/tasks.c **** 
2389:..\..\..\Source/tasks.c **** #endif /* INCLUDE_xTaskAbortDelay */
2390:..\..\..\Source/tasks.c **** /*----------------------------------------------------------*/
2391:..\..\..\Source/tasks.c **** 
2392:..\..\..\Source/tasks.c **** BaseType_t xTaskIncrementTick( void )
2393:..\..\..\Source/tasks.c **** {
 2413              		.loc 1 2393 0
 2414              		.cfi_startproc
 2415              		@ args = 0, pretend = 0, frame = 24
 2416              		@ frame_needed = 1, uses_anonymous_args = 0
 2417 0000 80B5     		push	{r7, lr}
 2418              		.cfi_def_cfa_offset 8
 2419              		.cfi_offset 7, -8
 2420              		.cfi_offset 14, -4
 2421 0002 86B0     		sub	sp, sp, #24
 2422              		.cfi_def_cfa_offset 32
 2423 0004 00AF     		add	r7, sp, #0
 2424              		.cfi_def_cfa_register 7
2394:..\..\..\Source/tasks.c **** TCB_t * pxTCB;
2395:..\..\..\Source/tasks.c **** TickType_t xItemValue;
2396:..\..\..\Source/tasks.c **** BaseType_t xSwitchRequired = pdFALSE;
 2425              		.loc 1 2396 0
 2426 0006 0023     		movs	r3, #0
 2427 0008 7B61     		str	r3, [r7, #20]
2397:..\..\..\Source/tasks.c **** 
2398:..\..\..\Source/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
2399:..\..\..\Source/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
2400:..\..\..\Source/tasks.c **** 	tasks to be unblocked. */
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 91


2401:..\..\..\Source/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
2402:..\..\..\Source/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 2428              		.loc 1 2402 0
 2429 000a 494B     		ldr	r3, .L177
 2430 000c 1B68     		ldr	r3, [r3]
 2431 000e 002B     		cmp	r3, #0
 2432 0010 7ED1     		bne	.L163
 2433              	.LBB42:
2403:..\..\..\Source/tasks.c **** 	{
2404:..\..\..\Source/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this
2405:..\..\..\Source/tasks.c **** 		block. */
2406:..\..\..\Source/tasks.c **** 		const TickType_t xConstTickCount = xTickCount + 1;
 2434              		.loc 1 2406 0
 2435 0012 484B     		ldr	r3, .L177+4
 2436 0014 1B68     		ldr	r3, [r3]
 2437 0016 0133     		adds	r3, r3, #1
 2438 0018 3B61     		str	r3, [r7, #16]
2407:..\..\..\Source/tasks.c **** 
2408:..\..\..\Source/tasks.c **** 		/* Increment the RTOS tick, switching the delayed and overflowed
2409:..\..\..\Source/tasks.c **** 		delayed lists if it wraps to 0. */
2410:..\..\..\Source/tasks.c **** 		xTickCount = xConstTickCount;
 2439              		.loc 1 2410 0
 2440 001a 464A     		ldr	r2, .L177+4
 2441 001c 3B69     		ldr	r3, [r7, #16]
 2442 001e 1360     		str	r3, [r2]
2411:..\..\..\Source/tasks.c **** 
2412:..\..\..\Source/tasks.c **** 		if( xConstTickCount == ( TickType_t ) 0U )
 2443              		.loc 1 2412 0
 2444 0020 3B69     		ldr	r3, [r7, #16]
 2445 0022 002B     		cmp	r3, #0
 2446 0024 10D1     		bne	.L164
 2447              	.LBB43:
2413:..\..\..\Source/tasks.c **** 		{
2414:..\..\..\Source/tasks.c **** 			taskSWITCH_DELAYED_LISTS();
 2448              		.loc 1 2414 0
 2449 0026 444B     		ldr	r3, .L177+8
 2450 0028 1B68     		ldr	r3, [r3]
 2451 002a FB60     		str	r3, [r7, #12]
 2452 002c 434B     		ldr	r3, .L177+12
 2453 002e 1B68     		ldr	r3, [r3]
 2454 0030 414A     		ldr	r2, .L177+8
 2455 0032 1360     		str	r3, [r2]
 2456 0034 414A     		ldr	r2, .L177+12
 2457 0036 FB68     		ldr	r3, [r7, #12]
 2458 0038 1360     		str	r3, [r2]
 2459 003a 414B     		ldr	r3, .L177+16
 2460 003c 1B68     		ldr	r3, [r3]
 2461 003e 0133     		adds	r3, r3, #1
 2462 0040 3F4A     		ldr	r2, .L177+16
 2463 0042 1360     		str	r3, [r2]
 2464 0044 FFF7FEFF 		bl	prvResetNextTaskUnblockTime
 2465              	.L164:
 2466              	.LBE43:
2415:..\..\..\Source/tasks.c **** 		}
2416:..\..\..\Source/tasks.c **** 		else
2417:..\..\..\Source/tasks.c **** 		{
2418:..\..\..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 92


2419:..\..\..\Source/tasks.c **** 		}
2420:..\..\..\Source/tasks.c **** 
2421:..\..\..\Source/tasks.c **** 		/* See if this tick has made a timeout expire.  Tasks are stored in
2422:..\..\..\Source/tasks.c **** 		the	queue in the order of their wake time - meaning once one task
2423:..\..\..\Source/tasks.c **** 		has been found whose block time has not expired there is no need to
2424:..\..\..\Source/tasks.c **** 		look any further down the list. */
2425:..\..\..\Source/tasks.c **** 		if( xConstTickCount >= xNextTaskUnblockTime )
 2467              		.loc 1 2425 0
 2468 0048 3E4B     		ldr	r3, .L177+20
 2469 004a 1B68     		ldr	r3, [r3]
 2470 004c 3A69     		ldr	r2, [r7, #16]
 2471 004e 9A42     		cmp	r2, r3
 2472 0050 4FD3     		bcc	.L165
 2473              	.L172:
2426:..\..\..\Source/tasks.c **** 		{
2427:..\..\..\Source/tasks.c **** 			for( ;; )
2428:..\..\..\Source/tasks.c **** 			{
2429:..\..\..\Source/tasks.c **** 				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 2474              		.loc 1 2429 0
 2475 0052 394B     		ldr	r3, .L177+8
 2476 0054 1B68     		ldr	r3, [r3]
 2477 0056 1B68     		ldr	r3, [r3]
 2478 0058 002B     		cmp	r3, #0
 2479 005a 01D1     		bne	.L166
 2480              		.loc 1 2429 0 is_stmt 0 discriminator 1
 2481 005c 0123     		movs	r3, #1
 2482 005e 00E0     		b	.L167
 2483              	.L166:
 2484              		.loc 1 2429 0 discriminator 2
 2485 0060 0023     		movs	r3, #0
 2486              	.L167:
 2487              		.loc 1 2429 0 discriminator 4
 2488 0062 002B     		cmp	r3, #0
 2489 0064 04D0     		beq	.L168
2430:..\..\..\Source/tasks.c **** 				{
2431:..\..\..\Source/tasks.c **** 					/* The delayed list is empty.  Set xNextTaskUnblockTime
2432:..\..\..\Source/tasks.c **** 					to the maximum possible value so it is extremely
2433:..\..\..\Source/tasks.c **** 					unlikely that the
2434:..\..\..\Source/tasks.c **** 					if( xTickCount >= xNextTaskUnblockTime ) test will pass
2435:..\..\..\Source/tasks.c **** 					next time through. */
2436:..\..\..\Source/tasks.c **** 					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redun
 2490              		.loc 1 2436 0 is_stmt 1
 2491 0066 374B     		ldr	r3, .L177+20
 2492 0068 4FF0FF32 		mov	r2, #-1
 2493 006c 1A60     		str	r2, [r3]
2437:..\..\..\Source/tasks.c **** 					break;
 2494              		.loc 1 2437 0
 2495 006e 40E0     		b	.L165
 2496              	.L168:
2438:..\..\..\Source/tasks.c **** 				}
2439:..\..\..\Source/tasks.c **** 				else
2440:..\..\..\Source/tasks.c **** 				{
2441:..\..\..\Source/tasks.c **** 					/* The delayed list is not empty, get the value of the
2442:..\..\..\Source/tasks.c **** 					item at the head of the delayed list.  This is the time
2443:..\..\..\Source/tasks.c **** 					at which the task at the head of the delayed list must
2444:..\..\..\Source/tasks.c **** 					be removed from the Blocked state. */
2445:..\..\..\Source/tasks.c **** 					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 93


 2497              		.loc 1 2445 0
 2498 0070 314B     		ldr	r3, .L177+8
 2499 0072 1B68     		ldr	r3, [r3]
 2500 0074 DB68     		ldr	r3, [r3, #12]
 2501 0076 DB68     		ldr	r3, [r3, #12]
 2502 0078 BB60     		str	r3, [r7, #8]
2446:..\..\..\Source/tasks.c **** 					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 2503              		.loc 1 2446 0
 2504 007a BB68     		ldr	r3, [r7, #8]
 2505 007c 5B68     		ldr	r3, [r3, #4]
 2506 007e 7B60     		str	r3, [r7, #4]
2447:..\..\..\Source/tasks.c **** 
2448:..\..\..\Source/tasks.c **** 					if( xConstTickCount < xItemValue )
 2507              		.loc 1 2448 0
 2508 0080 3A69     		ldr	r2, [r7, #16]
 2509 0082 7B68     		ldr	r3, [r7, #4]
 2510 0084 9A42     		cmp	r2, r3
 2511 0086 03D2     		bcs	.L169
2449:..\..\..\Source/tasks.c **** 					{
2450:..\..\..\Source/tasks.c **** 						/* It is not time to unblock this item yet, but the
2451:..\..\..\Source/tasks.c **** 						item value is the time at which the task at the head
2452:..\..\..\Source/tasks.c **** 						of the blocked list must be removed from the Blocked
2453:..\..\..\Source/tasks.c **** 						state -	so record the item value in
2454:..\..\..\Source/tasks.c **** 						xNextTaskUnblockTime. */
2455:..\..\..\Source/tasks.c **** 						xNextTaskUnblockTime = xItemValue;
 2512              		.loc 1 2455 0
 2513 0088 2E4A     		ldr	r2, .L177+20
 2514 008a 7B68     		ldr	r3, [r7, #4]
 2515 008c 1360     		str	r3, [r2]
2456:..\..\..\Source/tasks.c **** 						break;
 2516              		.loc 1 2456 0
 2517 008e 30E0     		b	.L165
 2518              	.L169:
2457:..\..\..\Source/tasks.c **** 					}
2458:..\..\..\Source/tasks.c **** 					else
2459:..\..\..\Source/tasks.c **** 					{
2460:..\..\..\Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2461:..\..\..\Source/tasks.c **** 					}
2462:..\..\..\Source/tasks.c **** 
2463:..\..\..\Source/tasks.c **** 					/* It is time to remove the item from the Blocked state. */
2464:..\..\..\Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 2519              		.loc 1 2464 0
 2520 0090 BB68     		ldr	r3, [r7, #8]
 2521 0092 0433     		adds	r3, r3, #4
 2522 0094 1846     		mov	r0, r3
 2523 0096 FFF7FEFF 		bl	uxListRemove
2465:..\..\..\Source/tasks.c **** 
2466:..\..\..\Source/tasks.c **** 					/* Is the task waiting on an event also?  If so remove
2467:..\..\..\Source/tasks.c **** 					it from the event list. */
2468:..\..\..\Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 2524              		.loc 1 2468 0
 2525 009a BB68     		ldr	r3, [r7, #8]
 2526 009c 9B6A     		ldr	r3, [r3, #40]
 2527 009e 002B     		cmp	r3, #0
 2528 00a0 04D0     		beq	.L170
2469:..\..\..\Source/tasks.c **** 					{
2470:..\..\..\Source/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 94


 2529              		.loc 1 2470 0
 2530 00a2 BB68     		ldr	r3, [r7, #8]
 2531 00a4 1833     		adds	r3, r3, #24
 2532 00a6 1846     		mov	r0, r3
 2533 00a8 FFF7FEFF 		bl	uxListRemove
 2534              	.L170:
2471:..\..\..\Source/tasks.c **** 					}
2472:..\..\..\Source/tasks.c **** 					else
2473:..\..\..\Source/tasks.c **** 					{
2474:..\..\..\Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2475:..\..\..\Source/tasks.c **** 					}
2476:..\..\..\Source/tasks.c **** 
2477:..\..\..\Source/tasks.c **** 					/* Place the unblocked task into the appropriate ready
2478:..\..\..\Source/tasks.c **** 					list. */
2479:..\..\..\Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 2535              		.loc 1 2479 0
 2536 00ac BB68     		ldr	r3, [r7, #8]
 2537 00ae DB6A     		ldr	r3, [r3, #44]
 2538 00b0 1A46     		mov	r2, r3
 2539 00b2 0123     		movs	r3, #1
 2540 00b4 03FA02F2 		lsl	r2, r3, r2
 2541 00b8 234B     		ldr	r3, .L177+24
 2542 00ba 1B68     		ldr	r3, [r3]
 2543 00bc 1343     		orrs	r3, r3, r2
 2544 00be 224A     		ldr	r2, .L177+24
 2545 00c0 1360     		str	r3, [r2]
 2546 00c2 BB68     		ldr	r3, [r7, #8]
 2547 00c4 DA6A     		ldr	r2, [r3, #44]
 2548 00c6 1346     		mov	r3, r2
 2549 00c8 9B00     		lsls	r3, r3, #2
 2550 00ca 1344     		add	r3, r3, r2
 2551 00cc 9B00     		lsls	r3, r3, #2
 2552 00ce 1F4A     		ldr	r2, .L177+28
 2553 00d0 1A44     		add	r2, r2, r3
 2554 00d2 BB68     		ldr	r3, [r7, #8]
 2555 00d4 0433     		adds	r3, r3, #4
 2556 00d6 1046     		mov	r0, r2
 2557 00d8 1946     		mov	r1, r3
 2558 00da FFF7FEFF 		bl	vListInsertEnd
2480:..\..\..\Source/tasks.c **** 
2481:..\..\..\Source/tasks.c **** 					/* A task being unblocked cannot cause an immediate
2482:..\..\..\Source/tasks.c **** 					context switch if preemption is turned off. */
2483:..\..\..\Source/tasks.c **** 					#if (  configUSE_PREEMPTION == 1 )
2484:..\..\..\Source/tasks.c **** 					{
2485:..\..\..\Source/tasks.c **** 						/* Preemption is on, but a context switch should
2486:..\..\..\Source/tasks.c **** 						only be performed if the unblocked task has a
2487:..\..\..\Source/tasks.c **** 						priority that is equal to or higher than the
2488:..\..\..\Source/tasks.c **** 						currently executing task. */
2489:..\..\..\Source/tasks.c **** 						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2559              		.loc 1 2489 0
 2560 00de BB68     		ldr	r3, [r7, #8]
 2561 00e0 DA6A     		ldr	r2, [r3, #44]
 2562 00e2 1B4B     		ldr	r3, .L177+32
 2563 00e4 1B68     		ldr	r3, [r3]
 2564 00e6 DB6A     		ldr	r3, [r3, #44]
 2565 00e8 9A42     		cmp	r2, r3
 2566 00ea 01D3     		bcc	.L171
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 95


2490:..\..\..\Source/tasks.c **** 						{
2491:..\..\..\Source/tasks.c **** 							xSwitchRequired = pdTRUE;
 2567              		.loc 1 2491 0
 2568 00ec 0123     		movs	r3, #1
 2569 00ee 7B61     		str	r3, [r7, #20]
 2570              	.L171:
2492:..\..\..\Source/tasks.c **** 						}
2493:..\..\..\Source/tasks.c **** 						else
2494:..\..\..\Source/tasks.c **** 						{
2495:..\..\..\Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
2496:..\..\..\Source/tasks.c **** 						}
2497:..\..\..\Source/tasks.c **** 					}
2498:..\..\..\Source/tasks.c **** 					#endif /* configUSE_PREEMPTION */
2499:..\..\..\Source/tasks.c **** 				}
2500:..\..\..\Source/tasks.c **** 			}
 2571              		.loc 1 2500 0
 2572 00f0 AFE7     		b	.L172
 2573              	.L165:
2501:..\..\..\Source/tasks.c **** 		}
2502:..\..\..\Source/tasks.c **** 
2503:..\..\..\Source/tasks.c **** 		/* Tasks of equal priority to the currently running task will share
2504:..\..\..\Source/tasks.c **** 		processing time (time slice) if preemption is on, and the application
2505:..\..\..\Source/tasks.c **** 		writer has not explicitly turned time slicing off. */
2506:..\..\..\Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
2507:..\..\..\Source/tasks.c **** 		{
2508:..\..\..\Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_
 2574              		.loc 1 2508 0
 2575 00f2 174B     		ldr	r3, .L177+32
 2576 00f4 1B68     		ldr	r3, [r3]
 2577 00f6 DA6A     		ldr	r2, [r3, #44]
 2578 00f8 1449     		ldr	r1, .L177+28
 2579 00fa 1346     		mov	r3, r2
 2580 00fc 9B00     		lsls	r3, r3, #2
 2581 00fe 1344     		add	r3, r3, r2
 2582 0100 9B00     		lsls	r3, r3, #2
 2583 0102 0B44     		add	r3, r3, r1
 2584 0104 1B68     		ldr	r3, [r3]
 2585 0106 012B     		cmp	r3, #1
 2586 0108 01D9     		bls	.L173
2509:..\..\..\Source/tasks.c **** 			{
2510:..\..\..\Source/tasks.c **** 				xSwitchRequired = pdTRUE;
 2587              		.loc 1 2510 0
 2588 010a 0123     		movs	r3, #1
 2589 010c 7B61     		str	r3, [r7, #20]
 2590              	.L173:
 2591              	.LBE42:
 2592 010e 04E0     		b	.L174
 2593              	.L163:
2511:..\..\..\Source/tasks.c **** 			}
2512:..\..\..\Source/tasks.c **** 			else
2513:..\..\..\Source/tasks.c **** 			{
2514:..\..\..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2515:..\..\..\Source/tasks.c **** 			}
2516:..\..\..\Source/tasks.c **** 		}
2517:..\..\..\Source/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
2518:..\..\..\Source/tasks.c **** 
2519:..\..\..\Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 96


2520:..\..\..\Source/tasks.c **** 		{
2521:..\..\..\Source/tasks.c **** 			/* Guard against the tick hook being called when the pended tick
2522:..\..\..\Source/tasks.c **** 			count is being unwound (when the scheduler is being unlocked). */
2523:..\..\..\Source/tasks.c **** 			if( uxPendedTicks == ( UBaseType_t ) 0U )
2524:..\..\..\Source/tasks.c **** 			{
2525:..\..\..\Source/tasks.c **** 				vApplicationTickHook();
2526:..\..\..\Source/tasks.c **** 			}
2527:..\..\..\Source/tasks.c **** 			else
2528:..\..\..\Source/tasks.c **** 			{
2529:..\..\..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2530:..\..\..\Source/tasks.c **** 			}
2531:..\..\..\Source/tasks.c **** 		}
2532:..\..\..\Source/tasks.c **** 		#endif /* configUSE_TICK_HOOK */
2533:..\..\..\Source/tasks.c **** 	}
2534:..\..\..\Source/tasks.c **** 	else
2535:..\..\..\Source/tasks.c **** 	{
2536:..\..\..\Source/tasks.c **** 		++uxPendedTicks;
 2594              		.loc 1 2536 0
 2595 0110 104B     		ldr	r3, .L177+36
 2596 0112 1B68     		ldr	r3, [r3]
 2597 0114 0133     		adds	r3, r3, #1
 2598 0116 0F4A     		ldr	r2, .L177+36
 2599 0118 1360     		str	r3, [r2]
 2600              	.L174:
2537:..\..\..\Source/tasks.c **** 
2538:..\..\..\Source/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
2539:..\..\..\Source/tasks.c **** 		scheduler is locked. */
2540:..\..\..\Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2541:..\..\..\Source/tasks.c **** 		{
2542:..\..\..\Source/tasks.c **** 			vApplicationTickHook();
2543:..\..\..\Source/tasks.c **** 		}
2544:..\..\..\Source/tasks.c **** 		#endif
2545:..\..\..\Source/tasks.c **** 	}
2546:..\..\..\Source/tasks.c **** 
2547:..\..\..\Source/tasks.c **** 	#if ( configUSE_PREEMPTION == 1 )
2548:..\..\..\Source/tasks.c **** 	{
2549:..\..\..\Source/tasks.c **** 		if( xYieldPending != pdFALSE )
 2601              		.loc 1 2549 0
 2602 011a 0F4B     		ldr	r3, .L177+40
 2603 011c 1B68     		ldr	r3, [r3]
 2604 011e 002B     		cmp	r3, #0
 2605 0120 01D0     		beq	.L175
2550:..\..\..\Source/tasks.c **** 		{
2551:..\..\..\Source/tasks.c **** 			xSwitchRequired = pdTRUE;
 2606              		.loc 1 2551 0
 2607 0122 0123     		movs	r3, #1
 2608 0124 7B61     		str	r3, [r7, #20]
 2609              	.L175:
2552:..\..\..\Source/tasks.c **** 		}
2553:..\..\..\Source/tasks.c **** 		else
2554:..\..\..\Source/tasks.c **** 		{
2555:..\..\..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2556:..\..\..\Source/tasks.c **** 		}
2557:..\..\..\Source/tasks.c **** 	}
2558:..\..\..\Source/tasks.c **** 	#endif /* configUSE_PREEMPTION */
2559:..\..\..\Source/tasks.c **** 
2560:..\..\..\Source/tasks.c **** 	return xSwitchRequired;
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 97


 2610              		.loc 1 2560 0
 2611 0126 7B69     		ldr	r3, [r7, #20]
2561:..\..\..\Source/tasks.c **** }
 2612              		.loc 1 2561 0
 2613 0128 1846     		mov	r0, r3
 2614 012a 1837     		adds	r7, r7, #24
 2615              		.cfi_def_cfa_offset 8
 2616 012c BD46     		mov	sp, r7
 2617              		.cfi_def_cfa_register 13
 2618              		@ sp needed
 2619 012e 80BD     		pop	{r7, pc}
 2620              	.L178:
 2621              		.align	2
 2622              	.L177:
 2623 0130 00010000 		.word	uxSchedulerSuspended
 2624 0134 DC000000 		.word	xTickCount
 2625 0138 90000000 		.word	pxDelayedTaskList
 2626 013c 94000000 		.word	pxOverflowDelayedTaskList
 2627 0140 F0000000 		.word	xNumOfOverflows
 2628 0144 F8000000 		.word	xNextTaskUnblockTime
 2629 0148 E0000000 		.word	uxTopReadyPriority
 2630 014c 04000000 		.word	pxReadyTasksLists
 2631 0150 00000000 		.word	pxCurrentTCB
 2632 0154 E8000000 		.word	uxPendedTicks
 2633 0158 EC000000 		.word	xYieldPending
 2634              		.cfi_endproc
 2635              	.LFE90:
 2636              		.size	xTaskIncrementTick, .-xTaskIncrementTick
 2637              		.section	.text.vTaskSwitchContext,"ax",%progbits
 2638              		.align	2
 2639              		.global	vTaskSwitchContext
 2640              		.thumb
 2641              		.thumb_func
 2642              		.type	vTaskSwitchContext, %function
 2643              	vTaskSwitchContext:
 2644              	.LFB91:
2562:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
2563:..\..\..\Source/tasks.c **** 
2564:..\..\..\Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2565:..\..\..\Source/tasks.c **** 
2566:..\..\..\Source/tasks.c **** 	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
2567:..\..\..\Source/tasks.c **** 	{
2568:..\..\..\Source/tasks.c **** 	TCB_t *xTCB;
2569:..\..\..\Source/tasks.c **** 
2570:..\..\..\Source/tasks.c **** 		/* If xTask is NULL then it is the task hook of the calling task that is
2571:..\..\..\Source/tasks.c **** 		getting set. */
2572:..\..\..\Source/tasks.c **** 		if( xTask == NULL )
2573:..\..\..\Source/tasks.c **** 		{
2574:..\..\..\Source/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2575:..\..\..\Source/tasks.c **** 		}
2576:..\..\..\Source/tasks.c **** 		else
2577:..\..\..\Source/tasks.c **** 		{
2578:..\..\..\Source/tasks.c **** 			xTCB = ( TCB_t * ) xTask;
2579:..\..\..\Source/tasks.c **** 		}
2580:..\..\..\Source/tasks.c **** 
2581:..\..\..\Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2582:..\..\..\Source/tasks.c **** 		the value can be accessed from an interrupt. */
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 98


2583:..\..\..\Source/tasks.c **** 		taskENTER_CRITICAL();
2584:..\..\..\Source/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
2585:..\..\..\Source/tasks.c **** 		taskEXIT_CRITICAL();
2586:..\..\..\Source/tasks.c **** 	}
2587:..\..\..\Source/tasks.c **** 
2588:..\..\..\Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2589:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
2590:..\..\..\Source/tasks.c **** 
2591:..\..\..\Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2592:..\..\..\Source/tasks.c **** 
2593:..\..\..\Source/tasks.c **** 	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
2594:..\..\..\Source/tasks.c **** 	{
2595:..\..\..\Source/tasks.c **** 	TCB_t *xTCB;
2596:..\..\..\Source/tasks.c **** 	TaskHookFunction_t xReturn;
2597:..\..\..\Source/tasks.c **** 
2598:..\..\..\Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
2599:..\..\..\Source/tasks.c **** 		if( xTask == NULL )
2600:..\..\..\Source/tasks.c **** 		{
2601:..\..\..\Source/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2602:..\..\..\Source/tasks.c **** 		}
2603:..\..\..\Source/tasks.c **** 		else
2604:..\..\..\Source/tasks.c **** 		{
2605:..\..\..\Source/tasks.c **** 			xTCB = ( TCB_t * ) xTask;
2606:..\..\..\Source/tasks.c **** 		}
2607:..\..\..\Source/tasks.c **** 
2608:..\..\..\Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2609:..\..\..\Source/tasks.c **** 		the value can be accessed from an interrupt. */
2610:..\..\..\Source/tasks.c **** 		taskENTER_CRITICAL();
2611:..\..\..\Source/tasks.c **** 		{
2612:..\..\..\Source/tasks.c **** 			xReturn = xTCB->pxTaskTag;
2613:..\..\..\Source/tasks.c **** 		}
2614:..\..\..\Source/tasks.c **** 		taskEXIT_CRITICAL();
2615:..\..\..\Source/tasks.c **** 
2616:..\..\..\Source/tasks.c **** 		return xReturn;
2617:..\..\..\Source/tasks.c **** 	}
2618:..\..\..\Source/tasks.c **** 
2619:..\..\..\Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2620:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
2621:..\..\..\Source/tasks.c **** 
2622:..\..\..\Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2623:..\..\..\Source/tasks.c **** 
2624:..\..\..\Source/tasks.c **** 	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
2625:..\..\..\Source/tasks.c **** 	{
2626:..\..\..\Source/tasks.c **** 	TCB_t *xTCB;
2627:..\..\..\Source/tasks.c **** 	BaseType_t xReturn;
2628:..\..\..\Source/tasks.c **** 
2629:..\..\..\Source/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
2630:..\..\..\Source/tasks.c **** 		if( xTask == NULL )
2631:..\..\..\Source/tasks.c **** 		{
2632:..\..\..\Source/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2633:..\..\..\Source/tasks.c **** 		}
2634:..\..\..\Source/tasks.c **** 		else
2635:..\..\..\Source/tasks.c **** 		{
2636:..\..\..\Source/tasks.c **** 			xTCB = ( TCB_t * ) xTask;
2637:..\..\..\Source/tasks.c **** 		}
2638:..\..\..\Source/tasks.c **** 
2639:..\..\..\Source/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 99


2640:..\..\..\Source/tasks.c **** 		{
2641:..\..\..\Source/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
2642:..\..\..\Source/tasks.c **** 		}
2643:..\..\..\Source/tasks.c **** 		else
2644:..\..\..\Source/tasks.c **** 		{
2645:..\..\..\Source/tasks.c **** 			xReturn = pdFAIL;
2646:..\..\..\Source/tasks.c **** 		}
2647:..\..\..\Source/tasks.c **** 
2648:..\..\..\Source/tasks.c **** 		return xReturn;
2649:..\..\..\Source/tasks.c **** 	}
2650:..\..\..\Source/tasks.c **** 
2651:..\..\..\Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2652:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
2653:..\..\..\Source/tasks.c **** 
2654:..\..\..\Source/tasks.c **** void vTaskSwitchContext( void )
2655:..\..\..\Source/tasks.c **** {
 2645              		.loc 1 2655 0
 2646              		.cfi_startproc
 2647              		@ args = 0, pretend = 0, frame = 24
 2648              		@ frame_needed = 1, uses_anonymous_args = 0
 2649 0000 80B5     		push	{r7, lr}
 2650              		.cfi_def_cfa_offset 8
 2651              		.cfi_offset 7, -8
 2652              		.cfi_offset 14, -4
 2653 0002 86B0     		sub	sp, sp, #24
 2654              		.cfi_def_cfa_offset 32
 2655 0004 00AF     		add	r7, sp, #0
 2656              		.cfi_def_cfa_register 7
2656:..\..\..\Source/tasks.c **** 	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 2657              		.loc 1 2656 0
 2658 0006 2E4B     		ldr	r3, .L186
 2659 0008 1B68     		ldr	r3, [r3]
 2660 000a 002B     		cmp	r3, #0
 2661 000c 03D0     		beq	.L180
2657:..\..\..\Source/tasks.c **** 	{
2658:..\..\..\Source/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
2659:..\..\..\Source/tasks.c **** 		switch. */
2660:..\..\..\Source/tasks.c **** 		xYieldPending = pdTRUE;
 2662              		.loc 1 2660 0
 2663 000e 2D4B     		ldr	r3, .L186+4
 2664 0010 0122     		movs	r2, #1
 2665 0012 1A60     		str	r2, [r3]
 2666 0014 51E0     		b	.L179
 2667              	.L180:
2661:..\..\..\Source/tasks.c **** 	}
2662:..\..\..\Source/tasks.c **** 	else
2663:..\..\..\Source/tasks.c **** 	{
2664:..\..\..\Source/tasks.c **** 		xYieldPending = pdFALSE;
 2668              		.loc 1 2664 0
 2669 0016 2B4B     		ldr	r3, .L186+4
 2670 0018 0022     		movs	r2, #0
 2671 001a 1A60     		str	r2, [r3]
 2672              	.LBB44:
2665:..\..\..\Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
2666:..\..\..\Source/tasks.c **** 
2667:..\..\..\Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
2668:..\..\..\Source/tasks.c **** 		{
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 100


2669:..\..\..\Source/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2670:..\..\..\Source/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
2671:..\..\..\Source/tasks.c **** 				#else
2672:..\..\..\Source/tasks.c **** 					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2673:..\..\..\Source/tasks.c **** 				#endif
2674:..\..\..\Source/tasks.c **** 
2675:..\..\..\Source/tasks.c **** 				/* Add the amount of time the task has been running to the
2676:..\..\..\Source/tasks.c **** 				accumulated time so far.  The time the task started running was
2677:..\..\..\Source/tasks.c **** 				stored in ulTaskSwitchedInTime.  Note that there is no overflow
2678:..\..\..\Source/tasks.c **** 				protection here so count values are only valid until the timer
2679:..\..\..\Source/tasks.c **** 				overflows.  The guard against negative values is to protect
2680:..\..\..\Source/tasks.c **** 				against suspect run time stat counter implementations - which
2681:..\..\..\Source/tasks.c **** 				are provided by the application, not the kernel. */
2682:..\..\..\Source/tasks.c **** 				if( ulTotalRunTime > ulTaskSwitchedInTime )
2683:..\..\..\Source/tasks.c **** 				{
2684:..\..\..\Source/tasks.c **** 					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
2685:..\..\..\Source/tasks.c **** 				}
2686:..\..\..\Source/tasks.c **** 				else
2687:..\..\..\Source/tasks.c **** 				{
2688:..\..\..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
2689:..\..\..\Source/tasks.c **** 				}
2690:..\..\..\Source/tasks.c **** 				ulTaskSwitchedInTime = ulTotalRunTime;
2691:..\..\..\Source/tasks.c **** 		}
2692:..\..\..\Source/tasks.c **** 		#endif /* configGENERATE_RUN_TIME_STATS */
2693:..\..\..\Source/tasks.c **** 
2694:..\..\..\Source/tasks.c **** 		/* Check for stack overflow, if configured. */
2695:..\..\..\Source/tasks.c **** 		taskCHECK_FOR_STACK_OVERFLOW();
 2673              		.loc 1 2695 0
 2674 001c 2A4B     		ldr	r3, .L186+8
 2675 001e 1B68     		ldr	r3, [r3]
 2676 0020 1B6B     		ldr	r3, [r3, #48]
 2677 0022 7B61     		str	r3, [r7, #20]
 2678 0024 4FF0A533 		mov	r3, #-1515870811
 2679 0028 3B61     		str	r3, [r7, #16]
 2680 002a 7B69     		ldr	r3, [r7, #20]
 2681 002c 1A68     		ldr	r2, [r3]
 2682 002e 3B69     		ldr	r3, [r7, #16]
 2683 0030 9A42     		cmp	r2, r3
 2684 0032 11D1     		bne	.L182
 2685              		.loc 1 2695 0 is_stmt 0 discriminator 2
 2686 0034 7B69     		ldr	r3, [r7, #20]
 2687 0036 0433     		adds	r3, r3, #4
 2688 0038 1A68     		ldr	r2, [r3]
 2689 003a 3B69     		ldr	r3, [r7, #16]
 2690 003c 9A42     		cmp	r2, r3
 2691 003e 0BD1     		bne	.L182
 2692              		.loc 1 2695 0 discriminator 4
 2693 0040 7B69     		ldr	r3, [r7, #20]
 2694 0042 0833     		adds	r3, r3, #8
 2695 0044 1A68     		ldr	r2, [r3]
 2696 0046 3B69     		ldr	r3, [r7, #16]
 2697 0048 9A42     		cmp	r2, r3
 2698 004a 05D1     		bne	.L182
 2699              		.loc 1 2695 0 discriminator 6
 2700 004c 7B69     		ldr	r3, [r7, #20]
 2701 004e 0C33     		adds	r3, r3, #12
 2702 0050 1A68     		ldr	r2, [r3]
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 101


 2703 0052 3B69     		ldr	r3, [r7, #16]
 2704 0054 9A42     		cmp	r2, r3
 2705 0056 08D0     		beq	.L183
 2706              	.L182:
 2707              		.loc 1 2695 0 discriminator 7
 2708 0058 1B4B     		ldr	r3, .L186+8
 2709 005a 1A68     		ldr	r2, [r3]
 2710 005c 1A4B     		ldr	r3, .L186+8
 2711 005e 1B68     		ldr	r3, [r3]
 2712 0060 3433     		adds	r3, r3, #52
 2713 0062 1046     		mov	r0, r2
 2714 0064 1946     		mov	r1, r3
 2715 0066 FFF7FEFF 		bl	vApplicationStackOverflowHook
 2716              	.L183:
 2717              	.LBE44:
 2718              	.LBB45:
2696:..\..\..\Source/tasks.c **** 
2697:..\..\..\Source/tasks.c **** 		/* Select a new task to run using either the generic C or port
2698:..\..\..\Source/tasks.c **** 		optimised asm code. */
2699:..\..\..\Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
 2719              		.loc 1 2699 0 is_stmt 1
 2720 006a 184B     		ldr	r3, .L186+12
 2721 006c 1B68     		ldr	r3, [r3]
 2722 006e 7B60     		str	r3, [r7, #4]
 2723              	.LBB46:
 2724              	.LBB47:
 176:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 		return ucReturn;
 2725              		.loc 2 176 0
 2726 0070 7B68     		ldr	r3, [r7, #4]
 2727              	@ 176 "../../../Source/portable/GCC/ARM_CM3/portmacro.h" 1
 2728 0072 B3FA83F3 		clz r3, r3
 2729              	@ 0 "" 2
 2730              		.thumb
 2731 0076 FB70     		strb	r3, [r7, #3]
 177:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	}
 2732              		.loc 2 177 0
 2733 0078 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2734              	.LBE47:
 2735              	.LBE46:
 2736              		.loc 1 2699 0
 2737 007a C3F11F03 		rsb	r3, r3, #31
 2738 007e FB60     		str	r3, [r7, #12]
 2739              	.LBB48:
 2740 0080 FA68     		ldr	r2, [r7, #12]
 2741 0082 1346     		mov	r3, r2
 2742 0084 9B00     		lsls	r3, r3, #2
 2743 0086 1344     		add	r3, r3, r2
 2744 0088 9B00     		lsls	r3, r3, #2
 2745 008a 114A     		ldr	r2, .L186+16
 2746 008c 1344     		add	r3, r3, r2
 2747 008e BB60     		str	r3, [r7, #8]
 2748 0090 BB68     		ldr	r3, [r7, #8]
 2749 0092 5B68     		ldr	r3, [r3, #4]
 2750 0094 5A68     		ldr	r2, [r3, #4]
 2751 0096 BB68     		ldr	r3, [r7, #8]
 2752 0098 5A60     		str	r2, [r3, #4]
 2753 009a BB68     		ldr	r3, [r7, #8]
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 102


 2754 009c 5A68     		ldr	r2, [r3, #4]
 2755 009e BB68     		ldr	r3, [r7, #8]
 2756 00a0 0833     		adds	r3, r3, #8
 2757 00a2 9A42     		cmp	r2, r3
 2758 00a4 04D1     		bne	.L185
 2759              		.loc 1 2699 0 is_stmt 0 discriminator 1
 2760 00a6 BB68     		ldr	r3, [r7, #8]
 2761 00a8 5B68     		ldr	r3, [r3, #4]
 2762 00aa 5A68     		ldr	r2, [r3, #4]
 2763 00ac BB68     		ldr	r3, [r7, #8]
 2764 00ae 5A60     		str	r2, [r3, #4]
 2765              	.L185:
 2766              		.loc 1 2699 0 discriminator 3
 2767 00b0 BB68     		ldr	r3, [r7, #8]
 2768 00b2 5B68     		ldr	r3, [r3, #4]
 2769 00b4 DB68     		ldr	r3, [r3, #12]
 2770 00b6 044A     		ldr	r2, .L186+8
 2771 00b8 1360     		str	r3, [r2]
 2772              	.L179:
 2773              	.LBE48:
 2774              	.LBE45:
2700:..\..\..\Source/tasks.c **** 		traceTASK_SWITCHED_IN();
2701:..\..\..\Source/tasks.c **** 
2702:..\..\..\Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2703:..\..\..\Source/tasks.c **** 		{
2704:..\..\..\Source/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
2705:..\..\..\Source/tasks.c **** 			structure specific to this task. */
2706:..\..\..\Source/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2707:..\..\..\Source/tasks.c **** 		}
2708:..\..\..\Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
2709:..\..\..\Source/tasks.c **** 	}
2710:..\..\..\Source/tasks.c **** }
 2775              		.loc 1 2710 0 is_stmt 1
 2776 00ba 1837     		adds	r7, r7, #24
 2777              		.cfi_def_cfa_offset 8
 2778 00bc BD46     		mov	sp, r7
 2779              		.cfi_def_cfa_register 13
 2780              		@ sp needed
 2781 00be 80BD     		pop	{r7, pc}
 2782              	.L187:
 2783              		.align	2
 2784              	.L186:
 2785 00c0 00010000 		.word	uxSchedulerSuspended
 2786 00c4 EC000000 		.word	xYieldPending
 2787 00c8 00000000 		.word	pxCurrentTCB
 2788 00cc E0000000 		.word	uxTopReadyPriority
 2789 00d0 04000000 		.word	pxReadyTasksLists
 2790              		.cfi_endproc
 2791              	.LFE91:
 2792              		.size	vTaskSwitchContext, .-vTaskSwitchContext
 2793              		.section	.text.vTaskPlaceOnEventList,"ax",%progbits
 2794              		.align	2
 2795              		.global	vTaskPlaceOnEventList
 2796              		.thumb
 2797              		.thumb_func
 2798              		.type	vTaskPlaceOnEventList, %function
 2799              	vTaskPlaceOnEventList:
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 103


 2800              	.LFB92:
2711:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
2712:..\..\..\Source/tasks.c **** 
2713:..\..\..\Source/tasks.c **** void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
2714:..\..\..\Source/tasks.c **** {
 2801              		.loc 1 2714 0
 2802              		.cfi_startproc
 2803              		@ args = 0, pretend = 0, frame = 8
 2804              		@ frame_needed = 1, uses_anonymous_args = 0
 2805 0000 80B5     		push	{r7, lr}
 2806              		.cfi_def_cfa_offset 8
 2807              		.cfi_offset 7, -8
 2808              		.cfi_offset 14, -4
 2809 0002 82B0     		sub	sp, sp, #8
 2810              		.cfi_def_cfa_offset 16
 2811 0004 00AF     		add	r7, sp, #0
 2812              		.cfi_def_cfa_register 7
 2813 0006 7860     		str	r0, [r7, #4]
 2814 0008 3960     		str	r1, [r7]
2715:..\..\..\Source/tasks.c **** 	configASSERT( pxEventList );
2716:..\..\..\Source/tasks.c **** 
2717:..\..\..\Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
2718:..\..\..\Source/tasks.c **** 	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
2719:..\..\..\Source/tasks.c **** 
2720:..\..\..\Source/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
2721:..\..\..\Source/tasks.c **** 	This is placed in the list in priority order so the highest priority task
2722:..\..\..\Source/tasks.c **** 	is the first to be woken by the event.  The queue that contains the event
2723:..\..\..\Source/tasks.c **** 	list is locked, preventing simultaneous access from interrupts. */
2724:..\..\..\Source/tasks.c **** 	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 2815              		.loc 1 2724 0
 2816 000a 074B     		ldr	r3, .L189
 2817 000c 1B68     		ldr	r3, [r3]
 2818 000e 1833     		adds	r3, r3, #24
 2819 0010 7868     		ldr	r0, [r7, #4]
 2820 0012 1946     		mov	r1, r3
 2821 0014 FFF7FEFF 		bl	vListInsert
2725:..\..\..\Source/tasks.c **** 
2726:..\..\..\Source/tasks.c **** 	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 2822              		.loc 1 2726 0
 2823 0018 3868     		ldr	r0, [r7]
 2824 001a 0121     		movs	r1, #1
 2825 001c FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
2727:..\..\..\Source/tasks.c **** }
 2826              		.loc 1 2727 0
 2827 0020 0837     		adds	r7, r7, #8
 2828              		.cfi_def_cfa_offset 8
 2829 0022 BD46     		mov	sp, r7
 2830              		.cfi_def_cfa_register 13
 2831              		@ sp needed
 2832 0024 80BD     		pop	{r7, pc}
 2833              	.L190:
 2834 0026 00BF     		.align	2
 2835              	.L189:
 2836 0028 00000000 		.word	pxCurrentTCB
 2837              		.cfi_endproc
 2838              	.LFE92:
 2839              		.size	vTaskPlaceOnEventList, .-vTaskPlaceOnEventList
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 104


 2840              		.section	.text.vTaskPlaceOnUnorderedEventList,"ax",%progbits
 2841              		.align	2
 2842              		.global	vTaskPlaceOnUnorderedEventList
 2843              		.thumb
 2844              		.thumb_func
 2845              		.type	vTaskPlaceOnUnorderedEventList, %function
 2846              	vTaskPlaceOnUnorderedEventList:
 2847              	.LFB93:
2728:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
2729:..\..\..\Source/tasks.c **** 
2730:..\..\..\Source/tasks.c **** void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickT
2731:..\..\..\Source/tasks.c **** {
 2848              		.loc 1 2731 0
 2849              		.cfi_startproc
 2850              		@ args = 0, pretend = 0, frame = 16
 2851              		@ frame_needed = 1, uses_anonymous_args = 0
 2852 0000 80B5     		push	{r7, lr}
 2853              		.cfi_def_cfa_offset 8
 2854              		.cfi_offset 7, -8
 2855              		.cfi_offset 14, -4
 2856 0002 84B0     		sub	sp, sp, #16
 2857              		.cfi_def_cfa_offset 24
 2858 0004 00AF     		add	r7, sp, #0
 2859              		.cfi_def_cfa_register 7
 2860 0006 F860     		str	r0, [r7, #12]
 2861 0008 B960     		str	r1, [r7, #8]
 2862 000a 7A60     		str	r2, [r7, #4]
2732:..\..\..\Source/tasks.c **** 	configASSERT( pxEventList );
2733:..\..\..\Source/tasks.c **** 
2734:..\..\..\Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2735:..\..\..\Source/tasks.c **** 	the event groups implementation. */
2736:..\..\..\Source/tasks.c **** 	configASSERT( uxSchedulerSuspended != 0 );
2737:..\..\..\Source/tasks.c **** 
2738:..\..\..\Source/tasks.c **** 	/* Store the item value in the event list item.  It is safe to access the
2739:..\..\..\Source/tasks.c **** 	event list item here as interrupts won't access the event list item of a
2740:..\..\..\Source/tasks.c **** 	task that is not in the Blocked state. */
2741:..\..\..\Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE
 2863              		.loc 1 2741 0
 2864 000c 094B     		ldr	r3, .L192
 2865 000e 1B68     		ldr	r3, [r3]
 2866 0010 BA68     		ldr	r2, [r7, #8]
 2867 0012 42F00042 		orr	r2, r2, #-2147483648
 2868 0016 9A61     		str	r2, [r3, #24]
2742:..\..\..\Source/tasks.c **** 
2743:..\..\..\Source/tasks.c **** 	/* Place the event list item of the TCB at the end of the appropriate event
2744:..\..\..\Source/tasks.c **** 	list.  It is safe to access the event list here because it is part of an
2745:..\..\..\Source/tasks.c **** 	event group implementation - and interrupts don't access event groups
2746:..\..\..\Source/tasks.c **** 	directly (instead they access them indirectly by pending function calls to
2747:..\..\..\Source/tasks.c **** 	the task level). */
2748:..\..\..\Source/tasks.c **** 	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 2869              		.loc 1 2748 0
 2870 0018 064B     		ldr	r3, .L192
 2871 001a 1B68     		ldr	r3, [r3]
 2872 001c 1833     		adds	r3, r3, #24
 2873 001e F868     		ldr	r0, [r7, #12]
 2874 0020 1946     		mov	r1, r3
 2875 0022 FFF7FEFF 		bl	vListInsertEnd
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 105


2749:..\..\..\Source/tasks.c **** 
2750:..\..\..\Source/tasks.c **** 	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 2876              		.loc 1 2750 0
 2877 0026 7868     		ldr	r0, [r7, #4]
 2878 0028 0121     		movs	r1, #1
 2879 002a FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
2751:..\..\..\Source/tasks.c **** }
 2880              		.loc 1 2751 0
 2881 002e 1037     		adds	r7, r7, #16
 2882              		.cfi_def_cfa_offset 8
 2883 0030 BD46     		mov	sp, r7
 2884              		.cfi_def_cfa_register 13
 2885              		@ sp needed
 2886 0032 80BD     		pop	{r7, pc}
 2887              	.L193:
 2888              		.align	2
 2889              	.L192:
 2890 0034 00000000 		.word	pxCurrentTCB
 2891              		.cfi_endproc
 2892              	.LFE93:
 2893              		.size	vTaskPlaceOnUnorderedEventList, .-vTaskPlaceOnUnorderedEventList
 2894              		.section	.text.xTaskRemoveFromEventList,"ax",%progbits
 2895              		.align	2
 2896              		.global	xTaskRemoveFromEventList
 2897              		.thumb
 2898              		.thumb_func
 2899              		.type	xTaskRemoveFromEventList, %function
 2900              	xTaskRemoveFromEventList:
 2901              	.LFB94:
2752:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
2753:..\..\..\Source/tasks.c **** 
2754:..\..\..\Source/tasks.c **** #if( configUSE_TIMERS == 1 )
2755:..\..\..\Source/tasks.c **** 
2756:..\..\..\Source/tasks.c **** 	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const B
2757:..\..\..\Source/tasks.c **** 	{
2758:..\..\..\Source/tasks.c **** 		configASSERT( pxEventList );
2759:..\..\..\Source/tasks.c **** 
2760:..\..\..\Source/tasks.c **** 		/* This function should not be called by application code hence the
2761:..\..\..\Source/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
2762:..\..\..\Source/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
2763:..\..\..\Source/tasks.c **** 		it should be called with the scheduler suspended. */
2764:..\..\..\Source/tasks.c **** 
2765:..\..\..\Source/tasks.c **** 
2766:..\..\..\Source/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
2767:..\..\..\Source/tasks.c **** 		In this case it is assume that this is the only task that is going to
2768:..\..\..\Source/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
2769:..\..\..\Source/tasks.c **** 		can be used in place of vListInsert. */
2770:..\..\..\Source/tasks.c **** 		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
2771:..\..\..\Source/tasks.c **** 
2772:..\..\..\Source/tasks.c **** 		/* If the task should block indefinitely then set the block time to a
2773:..\..\..\Source/tasks.c **** 		value that will be recognised as an indefinite delay inside the
2774:..\..\..\Source/tasks.c **** 		prvAddCurrentTaskToDelayedList() function. */
2775:..\..\..\Source/tasks.c **** 		if( xWaitIndefinitely != pdFALSE )
2776:..\..\..\Source/tasks.c **** 		{
2777:..\..\..\Source/tasks.c **** 			xTicksToWait = portMAX_DELAY;
2778:..\..\..\Source/tasks.c **** 		}
2779:..\..\..\Source/tasks.c **** 
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 106


2780:..\..\..\Source/tasks.c **** 		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
2781:..\..\..\Source/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
2782:..\..\..\Source/tasks.c **** 	}
2783:..\..\..\Source/tasks.c **** 
2784:..\..\..\Source/tasks.c **** #endif /* configUSE_TIMERS */
2785:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
2786:..\..\..\Source/tasks.c **** 
2787:..\..\..\Source/tasks.c **** BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
2788:..\..\..\Source/tasks.c **** {
 2902              		.loc 1 2788 0
 2903              		.cfi_startproc
 2904              		@ args = 0, pretend = 0, frame = 16
 2905              		@ frame_needed = 1, uses_anonymous_args = 0
 2906 0000 80B5     		push	{r7, lr}
 2907              		.cfi_def_cfa_offset 8
 2908              		.cfi_offset 7, -8
 2909              		.cfi_offset 14, -4
 2910 0002 84B0     		sub	sp, sp, #16
 2911              		.cfi_def_cfa_offset 24
 2912 0004 00AF     		add	r7, sp, #0
 2913              		.cfi_def_cfa_register 7
 2914 0006 7860     		str	r0, [r7, #4]
2789:..\..\..\Source/tasks.c **** TCB_t *pxUnblockedTCB;
2790:..\..\..\Source/tasks.c **** BaseType_t xReturn;
2791:..\..\..\Source/tasks.c **** 
2792:..\..\..\Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
2793:..\..\..\Source/tasks.c **** 	called from a critical section within an ISR. */
2794:..\..\..\Source/tasks.c **** 
2795:..\..\..\Source/tasks.c **** 	/* The event list is sorted in priority order, so the first in the list can
2796:..\..\..\Source/tasks.c **** 	be removed as it is known to be the highest priority.  Remove the TCB from
2797:..\..\..\Source/tasks.c **** 	the delayed list, and add it to the ready list.
2798:..\..\..\Source/tasks.c **** 
2799:..\..\..\Source/tasks.c **** 	If an event is for a queue that is locked then this function will never
2800:..\..\..\Source/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
2801:..\..\..\Source/tasks.c **** 	means exclusive access to the event list is guaranteed here.
2802:..\..\..\Source/tasks.c **** 
2803:..\..\..\Source/tasks.c **** 	This function assumes that a check has already been made to ensure that
2804:..\..\..\Source/tasks.c **** 	pxEventList is not empty. */
2805:..\..\..\Source/tasks.c **** 	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 2915              		.loc 1 2805 0
 2916 0008 7B68     		ldr	r3, [r7, #4]
 2917 000a DB68     		ldr	r3, [r3, #12]
 2918 000c DB68     		ldr	r3, [r3, #12]
 2919 000e BB60     		str	r3, [r7, #8]
2806:..\..\..\Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
2807:..\..\..\Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 2920              		.loc 1 2807 0
 2921 0010 BB68     		ldr	r3, [r7, #8]
 2922 0012 1833     		adds	r3, r3, #24
 2923 0014 1846     		mov	r0, r3
 2924 0016 FFF7FEFF 		bl	uxListRemove
2808:..\..\..\Source/tasks.c **** 
2809:..\..\..\Source/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 2925              		.loc 1 2809 0
 2926 001a 1E4B     		ldr	r3, .L200
 2927 001c 1B68     		ldr	r3, [r3]
 2928 001e 002B     		cmp	r3, #0
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 107


 2929 0020 1ED1     		bne	.L195
2810:..\..\..\Source/tasks.c **** 	{
2811:..\..\..\Source/tasks.c **** 		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 2930              		.loc 1 2811 0
 2931 0022 BB68     		ldr	r3, [r7, #8]
 2932 0024 0433     		adds	r3, r3, #4
 2933 0026 1846     		mov	r0, r3
 2934 0028 FFF7FEFF 		bl	uxListRemove
2812:..\..\..\Source/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
 2935              		.loc 1 2812 0
 2936 002c BB68     		ldr	r3, [r7, #8]
 2937 002e DB6A     		ldr	r3, [r3, #44]
 2938 0030 1A46     		mov	r2, r3
 2939 0032 0123     		movs	r3, #1
 2940 0034 03FA02F2 		lsl	r2, r3, r2
 2941 0038 174B     		ldr	r3, .L200+4
 2942 003a 1B68     		ldr	r3, [r3]
 2943 003c 1343     		orrs	r3, r3, r2
 2944 003e 164A     		ldr	r2, .L200+4
 2945 0040 1360     		str	r3, [r2]
 2946 0042 BB68     		ldr	r3, [r7, #8]
 2947 0044 DA6A     		ldr	r2, [r3, #44]
 2948 0046 1346     		mov	r3, r2
 2949 0048 9B00     		lsls	r3, r3, #2
 2950 004a 1344     		add	r3, r3, r2
 2951 004c 9B00     		lsls	r3, r3, #2
 2952 004e 134A     		ldr	r2, .L200+8
 2953 0050 1A44     		add	r2, r2, r3
 2954 0052 BB68     		ldr	r3, [r7, #8]
 2955 0054 0433     		adds	r3, r3, #4
 2956 0056 1046     		mov	r0, r2
 2957 0058 1946     		mov	r1, r3
 2958 005a FFF7FEFF 		bl	vListInsertEnd
 2959 005e 05E0     		b	.L196
 2960              	.L195:
2813:..\..\..\Source/tasks.c **** 	}
2814:..\..\..\Source/tasks.c **** 	else
2815:..\..\..\Source/tasks.c **** 	{
2816:..\..\..\Source/tasks.c **** 		/* The delayed and ready lists cannot be accessed, so hold this task
2817:..\..\..\Source/tasks.c **** 		pending until the scheduler is resumed. */
2818:..\..\..\Source/tasks.c **** 		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 2961              		.loc 1 2818 0
 2962 0060 BB68     		ldr	r3, [r7, #8]
 2963 0062 1833     		adds	r3, r3, #24
 2964 0064 0E48     		ldr	r0, .L200+12
 2965 0066 1946     		mov	r1, r3
 2966 0068 FFF7FEFF 		bl	vListInsertEnd
 2967              	.L196:
2819:..\..\..\Source/tasks.c **** 	}
2820:..\..\..\Source/tasks.c **** 
2821:..\..\..\Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 2968              		.loc 1 2821 0
 2969 006c BB68     		ldr	r3, [r7, #8]
 2970 006e DA6A     		ldr	r2, [r3, #44]
 2971 0070 0C4B     		ldr	r3, .L200+16
 2972 0072 1B68     		ldr	r3, [r3]
 2973 0074 DB6A     		ldr	r3, [r3, #44]
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 108


 2974 0076 9A42     		cmp	r2, r3
 2975 0078 05D9     		bls	.L197
2822:..\..\..\Source/tasks.c **** 	{
2823:..\..\..\Source/tasks.c **** 		/* Return true if the task removed from the event list has a higher
2824:..\..\..\Source/tasks.c **** 		priority than the calling task.  This allows the calling task to know if
2825:..\..\..\Source/tasks.c **** 		it should force a context switch now. */
2826:..\..\..\Source/tasks.c **** 		xReturn = pdTRUE;
 2976              		.loc 1 2826 0
 2977 007a 0123     		movs	r3, #1
 2978 007c FB60     		str	r3, [r7, #12]
2827:..\..\..\Source/tasks.c **** 
2828:..\..\..\Source/tasks.c **** 		/* Mark that a yield is pending in case the user is not using the
2829:..\..\..\Source/tasks.c **** 		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2830:..\..\..\Source/tasks.c **** 		xYieldPending = pdTRUE;
 2979              		.loc 1 2830 0
 2980 007e 0A4B     		ldr	r3, .L200+20
 2981 0080 0122     		movs	r2, #1
 2982 0082 1A60     		str	r2, [r3]
 2983 0084 01E0     		b	.L198
 2984              	.L197:
2831:..\..\..\Source/tasks.c **** 	}
2832:..\..\..\Source/tasks.c **** 	else
2833:..\..\..\Source/tasks.c **** 	{
2834:..\..\..\Source/tasks.c **** 		xReturn = pdFALSE;
 2985              		.loc 1 2834 0
 2986 0086 0023     		movs	r3, #0
 2987 0088 FB60     		str	r3, [r7, #12]
 2988              	.L198:
2835:..\..\..\Source/tasks.c **** 	}
2836:..\..\..\Source/tasks.c **** 
2837:..\..\..\Source/tasks.c **** 	#if( configUSE_TICKLESS_IDLE != 0 )
2838:..\..\..\Source/tasks.c **** 	{
2839:..\..\..\Source/tasks.c **** 		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
2840:..\..\..\Source/tasks.c **** 		might be set to the blocked task's time out time.  If the task is
2841:..\..\..\Source/tasks.c **** 		unblocked for a reason other than a timeout xNextTaskUnblockTime is
2842:..\..\..\Source/tasks.c **** 		normally left unchanged, because it is automatically reset to a new
2843:..\..\..\Source/tasks.c **** 		value when the tick count equals xNextTaskUnblockTime.  However if
2844:..\..\..\Source/tasks.c **** 		tickless idling is used it might be more important to enter sleep mode
2845:..\..\..\Source/tasks.c **** 		at the earliest possible time - so reset xNextTaskUnblockTime here to
2846:..\..\..\Source/tasks.c **** 		ensure it is updated at the earliest possible time. */
2847:..\..\..\Source/tasks.c **** 		prvResetNextTaskUnblockTime();
2848:..\..\..\Source/tasks.c **** 	}
2849:..\..\..\Source/tasks.c **** 	#endif
2850:..\..\..\Source/tasks.c **** 
2851:..\..\..\Source/tasks.c **** 	return xReturn;
 2989              		.loc 1 2851 0
 2990 008a FB68     		ldr	r3, [r7, #12]
2852:..\..\..\Source/tasks.c **** }
 2991              		.loc 1 2852 0
 2992 008c 1846     		mov	r0, r3
 2993 008e 1037     		adds	r7, r7, #16
 2994              		.cfi_def_cfa_offset 8
 2995 0090 BD46     		mov	sp, r7
 2996              		.cfi_def_cfa_register 13
 2997              		@ sp needed
 2998 0092 80BD     		pop	{r7, pc}
 2999              	.L201:
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 109


 3000              		.align	2
 3001              	.L200:
 3002 0094 00010000 		.word	uxSchedulerSuspended
 3003 0098 E0000000 		.word	uxTopReadyPriority
 3004 009c 04000000 		.word	pxReadyTasksLists
 3005 00a0 98000000 		.word	xPendingReadyList
 3006 00a4 00000000 		.word	pxCurrentTCB
 3007 00a8 EC000000 		.word	xYieldPending
 3008              		.cfi_endproc
 3009              	.LFE94:
 3010              		.size	xTaskRemoveFromEventList, .-xTaskRemoveFromEventList
 3011              		.section	.text.xTaskRemoveFromUnorderedEventList,"ax",%progbits
 3012              		.align	2
 3013              		.global	xTaskRemoveFromUnorderedEventList
 3014              		.thumb
 3015              		.thumb_func
 3016              		.type	xTaskRemoveFromUnorderedEventList, %function
 3017              	xTaskRemoveFromUnorderedEventList:
 3018              	.LFB95:
2853:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
2854:..\..\..\Source/tasks.c **** 
2855:..\..\..\Source/tasks.c **** BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemV
2856:..\..\..\Source/tasks.c **** {
 3019              		.loc 1 2856 0
 3020              		.cfi_startproc
 3021              		@ args = 0, pretend = 0, frame = 16
 3022              		@ frame_needed = 1, uses_anonymous_args = 0
 3023 0000 80B5     		push	{r7, lr}
 3024              		.cfi_def_cfa_offset 8
 3025              		.cfi_offset 7, -8
 3026              		.cfi_offset 14, -4
 3027 0002 84B0     		sub	sp, sp, #16
 3028              		.cfi_def_cfa_offset 24
 3029 0004 00AF     		add	r7, sp, #0
 3030              		.cfi_def_cfa_register 7
 3031 0006 7860     		str	r0, [r7, #4]
 3032 0008 3960     		str	r1, [r7]
2857:..\..\..\Source/tasks.c **** TCB_t *pxUnblockedTCB;
2858:..\..\..\Source/tasks.c **** BaseType_t xReturn;
2859:..\..\..\Source/tasks.c **** 
2860:..\..\..\Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2861:..\..\..\Source/tasks.c **** 	the event flags implementation. */
2862:..\..\..\Source/tasks.c **** 	configASSERT( uxSchedulerSuspended != pdFALSE );
2863:..\..\..\Source/tasks.c **** 
2864:..\..\..\Source/tasks.c **** 	/* Store the new item value in the event list. */
2865:..\..\..\Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 3033              		.loc 1 2865 0
 3034 000a 3B68     		ldr	r3, [r7]
 3035 000c 43F00042 		orr	r2, r3, #-2147483648
 3036 0010 7B68     		ldr	r3, [r7, #4]
 3037 0012 1A60     		str	r2, [r3]
2866:..\..\..\Source/tasks.c **** 
2867:..\..\..\Source/tasks.c **** 	/* Remove the event list form the event flag.  Interrupts do not access
2868:..\..\..\Source/tasks.c **** 	event flags. */
2869:..\..\..\Source/tasks.c **** 	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
 3038              		.loc 1 2869 0
 3039 0014 7B68     		ldr	r3, [r7, #4]
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 110


 3040 0016 DB68     		ldr	r3, [r3, #12]
 3041 0018 BB60     		str	r3, [r7, #8]
2870:..\..\..\Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
2871:..\..\..\Source/tasks.c **** 	( void ) uxListRemove( pxEventListItem );
 3042              		.loc 1 2871 0
 3043 001a 7868     		ldr	r0, [r7, #4]
 3044 001c FFF7FEFF 		bl	uxListRemove
2872:..\..\..\Source/tasks.c **** 
2873:..\..\..\Source/tasks.c **** 	/* Remove the task from the delayed list and add it to the ready list.  The
2874:..\..\..\Source/tasks.c **** 	scheduler is suspended so interrupts will not be accessing the ready
2875:..\..\..\Source/tasks.c **** 	lists. */
2876:..\..\..\Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 3045              		.loc 1 2876 0
 3046 0020 BB68     		ldr	r3, [r7, #8]
 3047 0022 0433     		adds	r3, r3, #4
 3048 0024 1846     		mov	r0, r3
 3049 0026 FFF7FEFF 		bl	uxListRemove
2877:..\..\..\Source/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
 3050              		.loc 1 2877 0
 3051 002a BB68     		ldr	r3, [r7, #8]
 3052 002c DB6A     		ldr	r3, [r3, #44]
 3053 002e 1A46     		mov	r2, r3
 3054 0030 0123     		movs	r3, #1
 3055 0032 03FA02F2 		lsl	r2, r3, r2
 3056 0036 134B     		ldr	r3, .L206
 3057 0038 1B68     		ldr	r3, [r3]
 3058 003a 1343     		orrs	r3, r3, r2
 3059 003c 114A     		ldr	r2, .L206
 3060 003e 1360     		str	r3, [r2]
 3061 0040 BB68     		ldr	r3, [r7, #8]
 3062 0042 DA6A     		ldr	r2, [r3, #44]
 3063 0044 1346     		mov	r3, r2
 3064 0046 9B00     		lsls	r3, r3, #2
 3065 0048 1344     		add	r3, r3, r2
 3066 004a 9B00     		lsls	r3, r3, #2
 3067 004c 0E4A     		ldr	r2, .L206+4
 3068 004e 1A44     		add	r2, r2, r3
 3069 0050 BB68     		ldr	r3, [r7, #8]
 3070 0052 0433     		adds	r3, r3, #4
 3071 0054 1046     		mov	r0, r2
 3072 0056 1946     		mov	r1, r3
 3073 0058 FFF7FEFF 		bl	vListInsertEnd
2878:..\..\..\Source/tasks.c **** 
2879:..\..\..\Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 3074              		.loc 1 2879 0
 3075 005c BB68     		ldr	r3, [r7, #8]
 3076 005e DA6A     		ldr	r2, [r3, #44]
 3077 0060 0A4B     		ldr	r3, .L206+8
 3078 0062 1B68     		ldr	r3, [r3]
 3079 0064 DB6A     		ldr	r3, [r3, #44]
 3080 0066 9A42     		cmp	r2, r3
 3081 0068 05D9     		bls	.L203
2880:..\..\..\Source/tasks.c **** 	{
2881:..\..\..\Source/tasks.c **** 		/* Return true if the task removed from the event list has
2882:..\..\..\Source/tasks.c **** 		a higher priority than the calling task.  This allows
2883:..\..\..\Source/tasks.c **** 		the calling task to know if it should force a context
2884:..\..\..\Source/tasks.c **** 		switch now. */
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 111


2885:..\..\..\Source/tasks.c **** 		xReturn = pdTRUE;
 3082              		.loc 1 2885 0
 3083 006a 0123     		movs	r3, #1
 3084 006c FB60     		str	r3, [r7, #12]
2886:..\..\..\Source/tasks.c **** 
2887:..\..\..\Source/tasks.c **** 		/* Mark that a yield is pending in case the user is not using the
2888:..\..\..\Source/tasks.c **** 		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2889:..\..\..\Source/tasks.c **** 		xYieldPending = pdTRUE;
 3085              		.loc 1 2889 0
 3086 006e 084B     		ldr	r3, .L206+12
 3087 0070 0122     		movs	r2, #1
 3088 0072 1A60     		str	r2, [r3]
 3089 0074 01E0     		b	.L204
 3090              	.L203:
2890:..\..\..\Source/tasks.c **** 	}
2891:..\..\..\Source/tasks.c **** 	else
2892:..\..\..\Source/tasks.c **** 	{
2893:..\..\..\Source/tasks.c **** 		xReturn = pdFALSE;
 3091              		.loc 1 2893 0
 3092 0076 0023     		movs	r3, #0
 3093 0078 FB60     		str	r3, [r7, #12]
 3094              	.L204:
2894:..\..\..\Source/tasks.c **** 	}
2895:..\..\..\Source/tasks.c **** 
2896:..\..\..\Source/tasks.c **** 	return xReturn;
 3095              		.loc 1 2896 0
 3096 007a FB68     		ldr	r3, [r7, #12]
2897:..\..\..\Source/tasks.c **** }
 3097              		.loc 1 2897 0
 3098 007c 1846     		mov	r0, r3
 3099 007e 1037     		adds	r7, r7, #16
 3100              		.cfi_def_cfa_offset 8
 3101 0080 BD46     		mov	sp, r7
 3102              		.cfi_def_cfa_register 13
 3103              		@ sp needed
 3104 0082 80BD     		pop	{r7, pc}
 3105              	.L207:
 3106              		.align	2
 3107              	.L206:
 3108 0084 E0000000 		.word	uxTopReadyPriority
 3109 0088 04000000 		.word	pxReadyTasksLists
 3110 008c 00000000 		.word	pxCurrentTCB
 3111 0090 EC000000 		.word	xYieldPending
 3112              		.cfi_endproc
 3113              	.LFE95:
 3114              		.size	xTaskRemoveFromUnorderedEventList, .-xTaskRemoveFromUnorderedEventList
 3115              		.section	.text.vTaskSetTimeOutState,"ax",%progbits
 3116              		.align	2
 3117              		.global	vTaskSetTimeOutState
 3118              		.thumb
 3119              		.thumb_func
 3120              		.type	vTaskSetTimeOutState, %function
 3121              	vTaskSetTimeOutState:
 3122              	.LFB96:
2898:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
2899:..\..\..\Source/tasks.c **** 
2900:..\..\..\Source/tasks.c **** void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 112


2901:..\..\..\Source/tasks.c **** {
 3123              		.loc 1 2901 0
 3124              		.cfi_startproc
 3125              		@ args = 0, pretend = 0, frame = 8
 3126              		@ frame_needed = 1, uses_anonymous_args = 0
 3127              		@ link register save eliminated.
 3128 0000 80B4     		push	{r7}
 3129              		.cfi_def_cfa_offset 4
 3130              		.cfi_offset 7, -4
 3131 0002 83B0     		sub	sp, sp, #12
 3132              		.cfi_def_cfa_offset 16
 3133 0004 00AF     		add	r7, sp, #0
 3134              		.cfi_def_cfa_register 7
 3135 0006 7860     		str	r0, [r7, #4]
2902:..\..\..\Source/tasks.c **** 	configASSERT( pxTimeOut );
2903:..\..\..\Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 3136              		.loc 1 2903 0
 3137 0008 064B     		ldr	r3, .L209
 3138 000a 1A68     		ldr	r2, [r3]
 3139 000c 7B68     		ldr	r3, [r7, #4]
 3140 000e 1A60     		str	r2, [r3]
2904:..\..\..\Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 3141              		.loc 1 2904 0
 3142 0010 054B     		ldr	r3, .L209+4
 3143 0012 1A68     		ldr	r2, [r3]
 3144 0014 7B68     		ldr	r3, [r7, #4]
 3145 0016 5A60     		str	r2, [r3, #4]
2905:..\..\..\Source/tasks.c **** }
 3146              		.loc 1 2905 0
 3147 0018 0C37     		adds	r7, r7, #12
 3148              		.cfi_def_cfa_offset 4
 3149 001a BD46     		mov	sp, r7
 3150              		.cfi_def_cfa_register 13
 3151              		@ sp needed
 3152 001c 5DF8047B 		ldr	r7, [sp], #4
 3153              		.cfi_restore 7
 3154              		.cfi_def_cfa_offset 0
 3155 0020 7047     		bx	lr
 3156              	.L210:
 3157 0022 00BF     		.align	2
 3158              	.L209:
 3159 0024 F0000000 		.word	xNumOfOverflows
 3160 0028 DC000000 		.word	xTickCount
 3161              		.cfi_endproc
 3162              	.LFE96:
 3163              		.size	vTaskSetTimeOutState, .-vTaskSetTimeOutState
 3164              		.section	.text.xTaskCheckForTimeOut,"ax",%progbits
 3165              		.align	2
 3166              		.global	xTaskCheckForTimeOut
 3167              		.thumb
 3168              		.thumb_func
 3169              		.type	xTaskCheckForTimeOut, %function
 3170              	xTaskCheckForTimeOut:
 3171              	.LFB97:
2906:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
2907:..\..\..\Source/tasks.c **** 
2908:..\..\..\Source/tasks.c **** BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 113


2909:..\..\..\Source/tasks.c **** {
 3172              		.loc 1 2909 0
 3173              		.cfi_startproc
 3174              		@ args = 0, pretend = 0, frame = 16
 3175              		@ frame_needed = 1, uses_anonymous_args = 0
 3176 0000 80B5     		push	{r7, lr}
 3177              		.cfi_def_cfa_offset 8
 3178              		.cfi_offset 7, -8
 3179              		.cfi_offset 14, -4
 3180 0002 84B0     		sub	sp, sp, #16
 3181              		.cfi_def_cfa_offset 24
 3182 0004 00AF     		add	r7, sp, #0
 3183              		.cfi_def_cfa_register 7
 3184 0006 7860     		str	r0, [r7, #4]
 3185 0008 3960     		str	r1, [r7]
2910:..\..\..\Source/tasks.c **** BaseType_t xReturn;
2911:..\..\..\Source/tasks.c **** 
2912:..\..\..\Source/tasks.c **** 	configASSERT( pxTimeOut );
2913:..\..\..\Source/tasks.c **** 	configASSERT( pxTicksToWait );
2914:..\..\..\Source/tasks.c **** 
2915:..\..\..\Source/tasks.c **** 	taskENTER_CRITICAL();
 3186              		.loc 1 2915 0
 3187 000a FFF7FEFF 		bl	vPortEnterCritical
 3188              	.LBB49:
2916:..\..\..\Source/tasks.c **** 	{
2917:..\..\..\Source/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this block. */
2918:..\..\..\Source/tasks.c **** 		const TickType_t xConstTickCount = xTickCount;
 3189              		.loc 1 2918 0
 3190 000e 1C4B     		ldr	r3, .L217
 3191 0010 1B68     		ldr	r3, [r3]
 3192 0012 BB60     		str	r3, [r7, #8]
2919:..\..\..\Source/tasks.c **** 
2920:..\..\..\Source/tasks.c **** 		#if( INCLUDE_xTaskAbortDelay == 1 )
2921:..\..\..\Source/tasks.c **** 			if( pxCurrentTCB->ucDelayAborted != pdFALSE )
2922:..\..\..\Source/tasks.c **** 			{
2923:..\..\..\Source/tasks.c **** 				/* The delay was aborted, which is not the same as a time out,
2924:..\..\..\Source/tasks.c **** 				but has the same result. */
2925:..\..\..\Source/tasks.c **** 				pxCurrentTCB->ucDelayAborted = pdFALSE;
2926:..\..\..\Source/tasks.c **** 				xReturn = pdTRUE;
2927:..\..\..\Source/tasks.c **** 			}
2928:..\..\..\Source/tasks.c **** 			else
2929:..\..\..\Source/tasks.c **** 		#endif
2930:..\..\..\Source/tasks.c **** 
2931:..\..\..\Source/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
2932:..\..\..\Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
 3193              		.loc 1 2932 0
 3194 0014 3B68     		ldr	r3, [r7]
 3195 0016 1B68     		ldr	r3, [r3]
 3196 0018 B3F1FF3F 		cmp	r3, #-1
 3197 001c 02D1     		bne	.L212
2933:..\..\..\Source/tasks.c **** 			{
2934:..\..\..\Source/tasks.c **** 				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
2935:..\..\..\Source/tasks.c **** 				specified is the maximum block time then the task should block
2936:..\..\..\Source/tasks.c **** 				indefinitely, and therefore never time out. */
2937:..\..\..\Source/tasks.c **** 				xReturn = pdFALSE;
 3198              		.loc 1 2937 0
 3199 001e 0023     		movs	r3, #0
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 114


 3200 0020 FB60     		str	r3, [r7, #12]
 3201 0022 26E0     		b	.L213
 3202              	.L212:
2938:..\..\..\Source/tasks.c **** 			}
2939:..\..\..\Source/tasks.c **** 			else
2940:..\..\..\Source/tasks.c **** 		#endif
2941:..\..\..\Source/tasks.c **** 
2942:..\..\..\Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEn
 3203              		.loc 1 2942 0
 3204 0024 7B68     		ldr	r3, [r7, #4]
 3205 0026 1A68     		ldr	r2, [r3]
 3206 0028 164B     		ldr	r3, .L217+4
 3207 002a 1B68     		ldr	r3, [r3]
 3208 002c 9A42     		cmp	r2, r3
 3209 002e 07D0     		beq	.L214
 3210              		.loc 1 2942 0 is_stmt 0 discriminator 1
 3211 0030 7B68     		ldr	r3, [r7, #4]
 3212 0032 5A68     		ldr	r2, [r3, #4]
 3213 0034 BB68     		ldr	r3, [r7, #8]
 3214 0036 9A42     		cmp	r2, r3
 3215 0038 02D8     		bhi	.L214
2943:..\..\..\Source/tasks.c **** 		{
2944:..\..\..\Source/tasks.c **** 			/* The tick count is greater than the time at which
2945:..\..\..\Source/tasks.c **** 			vTaskSetTimeout() was called, but has also overflowed since
2946:..\..\..\Source/tasks.c **** 			vTaskSetTimeOut() was called.  It must have wrapped all the way
2947:..\..\..\Source/tasks.c **** 			around and gone past again. This passed since vTaskSetTimeout()
2948:..\..\..\Source/tasks.c **** 			was called. */
2949:..\..\..\Source/tasks.c **** 			xReturn = pdTRUE;
 3216              		.loc 1 2949 0 is_stmt 1
 3217 003a 0123     		movs	r3, #1
 3218 003c FB60     		str	r3, [r7, #12]
 3219 003e 18E0     		b	.L213
 3220              	.L214:
2950:..\..\..\Source/tasks.c **** 		}
2951:..\..\..\Source/tasks.c **** 		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /
 3221              		.loc 1 2951 0
 3222 0040 7B68     		ldr	r3, [r7, #4]
 3223 0042 5B68     		ldr	r3, [r3, #4]
 3224 0044 BA68     		ldr	r2, [r7, #8]
 3225 0046 D21A     		subs	r2, r2, r3
 3226 0048 3B68     		ldr	r3, [r7]
 3227 004a 1B68     		ldr	r3, [r3]
 3228 004c 9A42     		cmp	r2, r3
 3229 004e 0ED2     		bcs	.L215
2952:..\..\..\Source/tasks.c **** 		{
2953:..\..\..\Source/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
2954:..\..\..\Source/tasks.c **** 			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
 3230              		.loc 1 2954 0
 3231 0050 3B68     		ldr	r3, [r7]
 3232 0052 1A68     		ldr	r2, [r3]
 3233 0054 7B68     		ldr	r3, [r7, #4]
 3234 0056 5968     		ldr	r1, [r3, #4]
 3235 0058 BB68     		ldr	r3, [r7, #8]
 3236 005a CB1A     		subs	r3, r1, r3
 3237 005c 1A44     		add	r2, r2, r3
 3238 005e 3B68     		ldr	r3, [r7]
 3239 0060 1A60     		str	r2, [r3]
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 115


2955:..\..\..\Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 3240              		.loc 1 2955 0
 3241 0062 7868     		ldr	r0, [r7, #4]
 3242 0064 FFF7FEFF 		bl	vTaskSetTimeOutState
2956:..\..\..\Source/tasks.c **** 			xReturn = pdFALSE;
 3243              		.loc 1 2956 0
 3244 0068 0023     		movs	r3, #0
 3245 006a FB60     		str	r3, [r7, #12]
 3246 006c 01E0     		b	.L213
 3247              	.L215:
2957:..\..\..\Source/tasks.c **** 		}
2958:..\..\..\Source/tasks.c **** 		else
2959:..\..\..\Source/tasks.c **** 		{
2960:..\..\..\Source/tasks.c **** 			xReturn = pdTRUE;
 3248              		.loc 1 2960 0
 3249 006e 0123     		movs	r3, #1
 3250 0070 FB60     		str	r3, [r7, #12]
 3251              	.L213:
 3252              	.LBE49:
2961:..\..\..\Source/tasks.c **** 		}
2962:..\..\..\Source/tasks.c **** 	}
2963:..\..\..\Source/tasks.c **** 	taskEXIT_CRITICAL();
 3253              		.loc 1 2963 0
 3254 0072 FFF7FEFF 		bl	vPortExitCritical
2964:..\..\..\Source/tasks.c **** 
2965:..\..\..\Source/tasks.c **** 	return xReturn;
 3255              		.loc 1 2965 0
 3256 0076 FB68     		ldr	r3, [r7, #12]
2966:..\..\..\Source/tasks.c **** }
 3257              		.loc 1 2966 0
 3258 0078 1846     		mov	r0, r3
 3259 007a 1037     		adds	r7, r7, #16
 3260              		.cfi_def_cfa_offset 8
 3261 007c BD46     		mov	sp, r7
 3262              		.cfi_def_cfa_register 13
 3263              		@ sp needed
 3264 007e 80BD     		pop	{r7, pc}
 3265              	.L218:
 3266              		.align	2
 3267              	.L217:
 3268 0080 DC000000 		.word	xTickCount
 3269 0084 F0000000 		.word	xNumOfOverflows
 3270              		.cfi_endproc
 3271              	.LFE97:
 3272              		.size	xTaskCheckForTimeOut, .-xTaskCheckForTimeOut
 3273              		.section	.text.vTaskMissedYield,"ax",%progbits
 3274              		.align	2
 3275              		.global	vTaskMissedYield
 3276              		.thumb
 3277              		.thumb_func
 3278              		.type	vTaskMissedYield, %function
 3279              	vTaskMissedYield:
 3280              	.LFB98:
2967:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
2968:..\..\..\Source/tasks.c **** 
2969:..\..\..\Source/tasks.c **** void vTaskMissedYield( void )
2970:..\..\..\Source/tasks.c **** {
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 116


 3281              		.loc 1 2970 0
 3282              		.cfi_startproc
 3283              		@ args = 0, pretend = 0, frame = 0
 3284              		@ frame_needed = 1, uses_anonymous_args = 0
 3285              		@ link register save eliminated.
 3286 0000 80B4     		push	{r7}
 3287              		.cfi_def_cfa_offset 4
 3288              		.cfi_offset 7, -4
 3289 0002 00AF     		add	r7, sp, #0
 3290              		.cfi_def_cfa_register 7
2971:..\..\..\Source/tasks.c **** 	xYieldPending = pdTRUE;
 3291              		.loc 1 2971 0
 3292 0004 034B     		ldr	r3, .L220
 3293 0006 0122     		movs	r2, #1
 3294 0008 1A60     		str	r2, [r3]
2972:..\..\..\Source/tasks.c **** }
 3295              		.loc 1 2972 0
 3296 000a BD46     		mov	sp, r7
 3297              		.cfi_def_cfa_register 13
 3298              		@ sp needed
 3299 000c 5DF8047B 		ldr	r7, [sp], #4
 3300              		.cfi_restore 7
 3301              		.cfi_def_cfa_offset 0
 3302 0010 7047     		bx	lr
 3303              	.L221:
 3304 0012 00BF     		.align	2
 3305              	.L220:
 3306 0014 EC000000 		.word	xYieldPending
 3307              		.cfi_endproc
 3308              	.LFE98:
 3309              		.size	vTaskMissedYield, .-vTaskMissedYield
 3310              		.section	.text.prvIdleTask,"ax",%progbits
 3311              		.align	2
 3312              		.thumb
 3313              		.thumb_func
 3314              		.type	prvIdleTask, %function
 3315              	prvIdleTask:
 3316              	.LFB99:
2973:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
2974:..\..\..\Source/tasks.c **** 
2975:..\..\..\Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2976:..\..\..\Source/tasks.c **** 
2977:..\..\..\Source/tasks.c **** 	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
2978:..\..\..\Source/tasks.c **** 	{
2979:..\..\..\Source/tasks.c **** 	UBaseType_t uxReturn;
2980:..\..\..\Source/tasks.c **** 	TCB_t *pxTCB;
2981:..\..\..\Source/tasks.c **** 
2982:..\..\..\Source/tasks.c **** 		if( xTask != NULL )
2983:..\..\..\Source/tasks.c **** 		{
2984:..\..\..\Source/tasks.c **** 			pxTCB = ( TCB_t * ) xTask;
2985:..\..\..\Source/tasks.c **** 			uxReturn = pxTCB->uxTaskNumber;
2986:..\..\..\Source/tasks.c **** 		}
2987:..\..\..\Source/tasks.c **** 		else
2988:..\..\..\Source/tasks.c **** 		{
2989:..\..\..\Source/tasks.c **** 			uxReturn = 0U;
2990:..\..\..\Source/tasks.c **** 		}
2991:..\..\..\Source/tasks.c **** 
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 117


2992:..\..\..\Source/tasks.c **** 		return uxReturn;
2993:..\..\..\Source/tasks.c **** 	}
2994:..\..\..\Source/tasks.c **** 
2995:..\..\..\Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2996:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
2997:..\..\..\Source/tasks.c **** 
2998:..\..\..\Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2999:..\..\..\Source/tasks.c **** 
3000:..\..\..\Source/tasks.c **** 	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
3001:..\..\..\Source/tasks.c **** 	{
3002:..\..\..\Source/tasks.c **** 	TCB_t *pxTCB;
3003:..\..\..\Source/tasks.c **** 
3004:..\..\..\Source/tasks.c **** 		if( xTask != NULL )
3005:..\..\..\Source/tasks.c **** 		{
3006:..\..\..\Source/tasks.c **** 			pxTCB = ( TCB_t * ) xTask;
3007:..\..\..\Source/tasks.c **** 			pxTCB->uxTaskNumber = uxHandle;
3008:..\..\..\Source/tasks.c **** 		}
3009:..\..\..\Source/tasks.c **** 	}
3010:..\..\..\Source/tasks.c **** 
3011:..\..\..\Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3012:..\..\..\Source/tasks.c **** 
3013:..\..\..\Source/tasks.c **** /*
3014:..\..\..\Source/tasks.c ****  * -----------------------------------------------------------
3015:..\..\..\Source/tasks.c ****  * The Idle task.
3016:..\..\..\Source/tasks.c ****  * ----------------------------------------------------------
3017:..\..\..\Source/tasks.c ****  *
3018:..\..\..\Source/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
3019:..\..\..\Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
3020:..\..\..\Source/tasks.c ****  *
3021:..\..\..\Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
3022:..\..\..\Source/tasks.c ****  *
3023:..\..\..\Source/tasks.c ****  */
3024:..\..\..\Source/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
3025:..\..\..\Source/tasks.c **** {
 3317              		.loc 1 3025 0
 3318              		.cfi_startproc
 3319              		@ args = 0, pretend = 0, frame = 8
 3320              		@ frame_needed = 1, uses_anonymous_args = 0
 3321 0000 80B5     		push	{r7, lr}
 3322              		.cfi_def_cfa_offset 8
 3323              		.cfi_offset 7, -8
 3324              		.cfi_offset 14, -4
 3325 0002 82B0     		sub	sp, sp, #8
 3326              		.cfi_def_cfa_offset 16
 3327 0004 00AF     		add	r7, sp, #0
 3328              		.cfi_def_cfa_register 7
 3329 0006 7860     		str	r0, [r7, #4]
 3330              	.L223:
3026:..\..\..\Source/tasks.c **** 	/* Stop warnings. */
3027:..\..\..\Source/tasks.c **** 	( void ) pvParameters;
3028:..\..\..\Source/tasks.c **** 
3029:..\..\..\Source/tasks.c **** 	/** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
3030:..\..\..\Source/tasks.c **** 	SCHEDULER IS STARTED. **/
3031:..\..\..\Source/tasks.c **** 
3032:..\..\..\Source/tasks.c **** 	for( ;; )
3033:..\..\..\Source/tasks.c **** 	{
3034:..\..\..\Source/tasks.c **** 		/* See if any tasks have deleted themselves - if so then the idle task
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 118


3035:..\..\..\Source/tasks.c **** 		is responsible for freeing the deleted task's TCB and stack. */
3036:..\..\..\Source/tasks.c **** 		prvCheckTasksWaitingTermination();
 3331              		.loc 1 3036 0 discriminator 1
 3332 0008 FFF7FEFF 		bl	prvCheckTasksWaitingTermination
3037:..\..\..\Source/tasks.c **** 
3038:..\..\..\Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
3039:..\..\..\Source/tasks.c **** 		{
3040:..\..\..\Source/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
3041:..\..\..\Source/tasks.c **** 			see if any other task has become available.  If we are using
3042:..\..\..\Source/tasks.c **** 			preemption we don't need to do this as any task becoming available
3043:..\..\..\Source/tasks.c **** 			will automatically get the processor anyway. */
3044:..\..\..\Source/tasks.c **** 			taskYIELD();
3045:..\..\..\Source/tasks.c **** 		}
3046:..\..\..\Source/tasks.c **** 		#endif /* configUSE_PREEMPTION */
3047:..\..\..\Source/tasks.c **** 
3048:..\..\..\Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
3049:..\..\..\Source/tasks.c **** 		{
3050:..\..\..\Source/tasks.c **** 			/* When using preemption tasks of equal priority will be
3051:..\..\..\Source/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
3052:..\..\..\Source/tasks.c **** 			to run then the idle task should yield before the end of the
3053:..\..\..\Source/tasks.c **** 			timeslice.
3054:..\..\..\Source/tasks.c **** 
3055:..\..\..\Source/tasks.c **** 			A critical region is not required here as we are just reading from
3056:..\..\..\Source/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
3057:..\..\..\Source/tasks.c **** 			the ready list at the idle priority contains more than one task
3058:..\..\..\Source/tasks.c **** 			then a task other than the idle task is ready to execute. */
3059:..\..\..\Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
3060:..\..\..\Source/tasks.c **** 			{
3061:..\..\..\Source/tasks.c **** 				taskYIELD();
3062:..\..\..\Source/tasks.c **** 			}
3063:..\..\..\Source/tasks.c **** 			else
3064:..\..\..\Source/tasks.c **** 			{
3065:..\..\..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3066:..\..\..\Source/tasks.c **** 			}
3067:..\..\..\Source/tasks.c **** 		}
3068:..\..\..\Source/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
3069:..\..\..\Source/tasks.c **** 
3070:..\..\..\Source/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
3071:..\..\..\Source/tasks.c **** 		{
3072:..\..\..\Source/tasks.c **** 			extern void vApplicationIdleHook( void );
3073:..\..\..\Source/tasks.c **** 
3074:..\..\..\Source/tasks.c **** 			/* Call the user defined function from within the idle task.  This
3075:..\..\..\Source/tasks.c **** 			allows the application designer to add background functionality
3076:..\..\..\Source/tasks.c **** 			without the overhead of a separate task.
3077:..\..\..\Source/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
3078:..\..\..\Source/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
3079:..\..\..\Source/tasks.c **** 			vApplicationIdleHook();
3080:..\..\..\Source/tasks.c **** 		}
3081:..\..\..\Source/tasks.c **** 		#endif /* configUSE_IDLE_HOOK */
3082:..\..\..\Source/tasks.c **** 
3083:..\..\..\Source/tasks.c **** 		/* This conditional compilation should use inequality to 0, not equality
3084:..\..\..\Source/tasks.c **** 		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
3085:..\..\..\Source/tasks.c **** 		user defined low power mode	implementations require
3086:..\..\..\Source/tasks.c **** 		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
3087:..\..\..\Source/tasks.c **** 		#if ( configUSE_TICKLESS_IDLE != 0 )
3088:..\..\..\Source/tasks.c **** 		{
3089:..\..\..\Source/tasks.c **** 		TickType_t xExpectedIdleTime;
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 119


3090:..\..\..\Source/tasks.c **** 
3091:..\..\..\Source/tasks.c **** 			/* It is not desirable to suspend then resume the scheduler on
3092:..\..\..\Source/tasks.c **** 			each iteration of the idle task.  Therefore, a preliminary
3093:..\..\..\Source/tasks.c **** 			test of the expected idle time is performed without the
3094:..\..\..\Source/tasks.c **** 			scheduler suspended.  The result here is not necessarily
3095:..\..\..\Source/tasks.c **** 			valid. */
3096:..\..\..\Source/tasks.c **** 			xExpectedIdleTime = prvGetExpectedIdleTime();
3097:..\..\..\Source/tasks.c **** 
3098:..\..\..\Source/tasks.c **** 			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3099:..\..\..\Source/tasks.c **** 			{
3100:..\..\..\Source/tasks.c **** 				vTaskSuspendAll();
3101:..\..\..\Source/tasks.c **** 				{
3102:..\..\..\Source/tasks.c **** 					/* Now the scheduler is suspended, the expected idle
3103:..\..\..\Source/tasks.c **** 					time can be sampled again, and this time its value can
3104:..\..\..\Source/tasks.c **** 					be used. */
3105:..\..\..\Source/tasks.c **** 					configASSERT( xNextTaskUnblockTime >= xTickCount );
3106:..\..\..\Source/tasks.c **** 					xExpectedIdleTime = prvGetExpectedIdleTime();
3107:..\..\..\Source/tasks.c **** 
3108:..\..\..\Source/tasks.c **** 					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3109:..\..\..\Source/tasks.c **** 					{
3110:..\..\..\Source/tasks.c **** 						traceLOW_POWER_IDLE_BEGIN();
3111:..\..\..\Source/tasks.c **** 						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
3112:..\..\..\Source/tasks.c **** 						traceLOW_POWER_IDLE_END();
3113:..\..\..\Source/tasks.c **** 					}
3114:..\..\..\Source/tasks.c **** 					else
3115:..\..\..\Source/tasks.c **** 					{
3116:..\..\..\Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3117:..\..\..\Source/tasks.c **** 					}
3118:..\..\..\Source/tasks.c **** 				}
3119:..\..\..\Source/tasks.c **** 				( void ) xTaskResumeAll();
3120:..\..\..\Source/tasks.c **** 			}
3121:..\..\..\Source/tasks.c **** 			else
3122:..\..\..\Source/tasks.c **** 			{
3123:..\..\..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3124:..\..\..\Source/tasks.c **** 			}
3125:..\..\..\Source/tasks.c **** 		}
3126:..\..\..\Source/tasks.c **** 		#endif /* configUSE_TICKLESS_IDLE */
3127:..\..\..\Source/tasks.c **** 	}
 3333              		.loc 1 3127 0 discriminator 1
 3334 000c FCE7     		b	.L223
 3335              		.cfi_endproc
 3336              	.LFE99:
 3337              		.size	prvIdleTask, .-prvIdleTask
 3338 000e 00BF     		.section	.text.prvInitialiseTaskLists,"ax",%progbits
 3339              		.align	2
 3340              		.thumb
 3341              		.thumb_func
 3342              		.type	prvInitialiseTaskLists, %function
 3343              	prvInitialiseTaskLists:
 3344              	.LFB100:
3128:..\..\..\Source/tasks.c **** }
3129:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
3130:..\..\..\Source/tasks.c **** 
3131:..\..\..\Source/tasks.c **** #if( configUSE_TICKLESS_IDLE != 0 )
3132:..\..\..\Source/tasks.c **** 
3133:..\..\..\Source/tasks.c **** 	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
3134:..\..\..\Source/tasks.c **** 	{
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 120


3135:..\..\..\Source/tasks.c **** 	/* The idle task exists in addition to the application tasks. */
3136:..\..\..\Source/tasks.c **** 	const UBaseType_t uxNonApplicationTasks = 1;
3137:..\..\..\Source/tasks.c **** 	eSleepModeStatus eReturn = eStandardSleep;
3138:..\..\..\Source/tasks.c **** 
3139:..\..\..\Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
3140:..\..\..\Source/tasks.c **** 		{
3141:..\..\..\Source/tasks.c **** 			/* A task was made ready while the scheduler was suspended. */
3142:..\..\..\Source/tasks.c **** 			eReturn = eAbortSleep;
3143:..\..\..\Source/tasks.c **** 		}
3144:..\..\..\Source/tasks.c **** 		else if( xYieldPending != pdFALSE )
3145:..\..\..\Source/tasks.c **** 		{
3146:..\..\..\Source/tasks.c **** 			/* A yield was pended while the scheduler was suspended. */
3147:..\..\..\Source/tasks.c **** 			eReturn = eAbortSleep;
3148:..\..\..\Source/tasks.c **** 		}
3149:..\..\..\Source/tasks.c **** 		else
3150:..\..\..\Source/tasks.c **** 		{
3151:..\..\..\Source/tasks.c **** 			/* If all the tasks are in the suspended list (which might mean they
3152:..\..\..\Source/tasks.c **** 			have an infinite block time rather than actually being suspended)
3153:..\..\..\Source/tasks.c **** 			then it is safe to turn all clocks off and just wait for external
3154:..\..\..\Source/tasks.c **** 			interrupts. */
3155:..\..\..\Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicatio
3156:..\..\..\Source/tasks.c **** 			{
3157:..\..\..\Source/tasks.c **** 				eReturn = eNoTasksWaitingTimeout;
3158:..\..\..\Source/tasks.c **** 			}
3159:..\..\..\Source/tasks.c **** 			else
3160:..\..\..\Source/tasks.c **** 			{
3161:..\..\..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3162:..\..\..\Source/tasks.c **** 			}
3163:..\..\..\Source/tasks.c **** 		}
3164:..\..\..\Source/tasks.c **** 
3165:..\..\..\Source/tasks.c **** 		return eReturn;
3166:..\..\..\Source/tasks.c **** 	}
3167:..\..\..\Source/tasks.c **** 
3168:..\..\..\Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
3169:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
3170:..\..\..\Source/tasks.c **** 
3171:..\..\..\Source/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3172:..\..\..\Source/tasks.c **** 
3173:..\..\..\Source/tasks.c **** 	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue 
3174:..\..\..\Source/tasks.c **** 	{
3175:..\..\..\Source/tasks.c **** 	TCB_t *pxTCB;
3176:..\..\..\Source/tasks.c **** 
3177:..\..\..\Source/tasks.c **** 		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3178:..\..\..\Source/tasks.c **** 		{
3179:..\..\..\Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSet );
3180:..\..\..\Source/tasks.c **** 			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
3181:..\..\..\Source/tasks.c **** 		}
3182:..\..\..\Source/tasks.c **** 	}
3183:..\..\..\Source/tasks.c **** 
3184:..\..\..\Source/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3185:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
3186:..\..\..\Source/tasks.c **** 
3187:..\..\..\Source/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3188:..\..\..\Source/tasks.c **** 
3189:..\..\..\Source/tasks.c **** 	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
3190:..\..\..\Source/tasks.c **** 	{
3191:..\..\..\Source/tasks.c **** 	void *pvReturn = NULL;
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 121


3192:..\..\..\Source/tasks.c **** 	TCB_t *pxTCB;
3193:..\..\..\Source/tasks.c **** 
3194:..\..\..\Source/tasks.c **** 		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3195:..\..\..\Source/tasks.c **** 		{
3196:..\..\..\Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
3197:..\..\..\Source/tasks.c **** 			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
3198:..\..\..\Source/tasks.c **** 		}
3199:..\..\..\Source/tasks.c **** 		else
3200:..\..\..\Source/tasks.c **** 		{
3201:..\..\..\Source/tasks.c **** 			pvReturn = NULL;
3202:..\..\..\Source/tasks.c **** 		}
3203:..\..\..\Source/tasks.c **** 
3204:..\..\..\Source/tasks.c **** 		return pvReturn;
3205:..\..\..\Source/tasks.c **** 	}
3206:..\..\..\Source/tasks.c **** 
3207:..\..\..\Source/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3208:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
3209:..\..\..\Source/tasks.c **** 
3210:..\..\..\Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
3211:..\..\..\Source/tasks.c **** 
3212:..\..\..\Source/tasks.c **** 	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
3213:..\..\..\Source/tasks.c **** 	{
3214:..\..\..\Source/tasks.c **** 	TCB_t *pxTCB;
3215:..\..\..\Source/tasks.c **** 
3216:..\..\..\Source/tasks.c **** 		/* If null is passed in here then we are modifying the MPU settings of
3217:..\..\..\Source/tasks.c **** 		the calling task. */
3218:..\..\..\Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
3219:..\..\..\Source/tasks.c **** 
3220:..\..\..\Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
3221:..\..\..\Source/tasks.c **** 	}
3222:..\..\..\Source/tasks.c **** 
3223:..\..\..\Source/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
3224:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
3225:..\..\..\Source/tasks.c **** 
3226:..\..\..\Source/tasks.c **** static void prvInitialiseTaskLists( void )
3227:..\..\..\Source/tasks.c **** {
 3345              		.loc 1 3227 0
 3346              		.cfi_startproc
 3347              		@ args = 0, pretend = 0, frame = 8
 3348              		@ frame_needed = 1, uses_anonymous_args = 0
 3349 0000 80B5     		push	{r7, lr}
 3350              		.cfi_def_cfa_offset 8
 3351              		.cfi_offset 7, -8
 3352              		.cfi_offset 14, -4
 3353 0002 82B0     		sub	sp, sp, #8
 3354              		.cfi_def_cfa_offset 16
 3355 0004 00AF     		add	r7, sp, #0
 3356              		.cfi_def_cfa_register 7
3228:..\..\..\Source/tasks.c **** UBaseType_t uxPriority;
3229:..\..\..\Source/tasks.c **** 
3230:..\..\..\Source/tasks.c **** 	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriorit
 3357              		.loc 1 3230 0
 3358 0006 0023     		movs	r3, #0
 3359 0008 7B60     		str	r3, [r7, #4]
 3360 000a 0CE0     		b	.L225
 3361              	.L226:
3231:..\..\..\Source/tasks.c **** 	{
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 122


3232:..\..\..\Source/tasks.c **** 		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 3362              		.loc 1 3232 0 discriminator 3
 3363 000c 7A68     		ldr	r2, [r7, #4]
 3364 000e 1346     		mov	r3, r2
 3365 0010 9B00     		lsls	r3, r3, #2
 3366 0012 1344     		add	r3, r3, r2
 3367 0014 9B00     		lsls	r3, r3, #2
 3368 0016 114A     		ldr	r2, .L227
 3369 0018 1344     		add	r3, r3, r2
 3370 001a 1846     		mov	r0, r3
 3371 001c FFF7FEFF 		bl	vListInitialise
3230:..\..\..\Source/tasks.c **** 	{
 3372              		.loc 1 3230 0 discriminator 3
 3373 0020 7B68     		ldr	r3, [r7, #4]
 3374 0022 0133     		adds	r3, r3, #1
 3375 0024 7B60     		str	r3, [r7, #4]
 3376              	.L225:
3230:..\..\..\Source/tasks.c **** 	{
 3377              		.loc 1 3230 0 is_stmt 0 discriminator 1
 3378 0026 7B68     		ldr	r3, [r7, #4]
 3379 0028 042B     		cmp	r3, #4
 3380 002a EFD9     		bls	.L226
3233:..\..\..\Source/tasks.c **** 	}
3234:..\..\..\Source/tasks.c **** 
3235:..\..\..\Source/tasks.c **** 	vListInitialise( &xDelayedTaskList1 );
 3381              		.loc 1 3235 0 is_stmt 1
 3382 002c 0C48     		ldr	r0, .L227+4
 3383 002e FFF7FEFF 		bl	vListInitialise
3236:..\..\..\Source/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
 3384              		.loc 1 3236 0
 3385 0032 0C48     		ldr	r0, .L227+8
 3386 0034 FFF7FEFF 		bl	vListInitialise
3237:..\..\..\Source/tasks.c **** 	vListInitialise( &xPendingReadyList );
 3387              		.loc 1 3237 0
 3388 0038 0B48     		ldr	r0, .L227+12
 3389 003a FFF7FEFF 		bl	vListInitialise
3238:..\..\..\Source/tasks.c **** 
3239:..\..\..\Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
3240:..\..\..\Source/tasks.c **** 	{
3241:..\..\..\Source/tasks.c **** 		vListInitialise( &xTasksWaitingTermination );
 3390              		.loc 1 3241 0
 3391 003e 0B48     		ldr	r0, .L227+16
 3392 0040 FFF7FEFF 		bl	vListInitialise
3242:..\..\..\Source/tasks.c **** 	}
3243:..\..\..\Source/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
3244:..\..\..\Source/tasks.c **** 
3245:..\..\..\Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
3246:..\..\..\Source/tasks.c **** 	{
3247:..\..\..\Source/tasks.c **** 		vListInitialise( &xSuspendedTaskList );
 3393              		.loc 1 3247 0
 3394 0044 0A48     		ldr	r0, .L227+20
 3395 0046 FFF7FEFF 		bl	vListInitialise
3248:..\..\..\Source/tasks.c **** 	}
3249:..\..\..\Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
3250:..\..\..\Source/tasks.c **** 
3251:..\..\..\Source/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
3252:..\..\..\Source/tasks.c **** 	using list2. */
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 123


3253:..\..\..\Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 3396              		.loc 1 3253 0
 3397 004a 0A4B     		ldr	r3, .L227+24
 3398 004c 044A     		ldr	r2, .L227+4
 3399 004e 1A60     		str	r2, [r3]
3254:..\..\..\Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 3400              		.loc 1 3254 0
 3401 0050 094B     		ldr	r3, .L227+28
 3402 0052 044A     		ldr	r2, .L227+8
 3403 0054 1A60     		str	r2, [r3]
3255:..\..\..\Source/tasks.c **** }
 3404              		.loc 1 3255 0
 3405 0056 0837     		adds	r7, r7, #8
 3406              		.cfi_def_cfa_offset 8
 3407 0058 BD46     		mov	sp, r7
 3408              		.cfi_def_cfa_register 13
 3409              		@ sp needed
 3410 005a 80BD     		pop	{r7, pc}
 3411              	.L228:
 3412              		.align	2
 3413              	.L227:
 3414 005c 04000000 		.word	pxReadyTasksLists
 3415 0060 68000000 		.word	xDelayedTaskList1
 3416 0064 7C000000 		.word	xDelayedTaskList2
 3417 0068 98000000 		.word	xPendingReadyList
 3418 006c AC000000 		.word	xTasksWaitingTermination
 3419 0070 C4000000 		.word	xSuspendedTaskList
 3420 0074 90000000 		.word	pxDelayedTaskList
 3421 0078 94000000 		.word	pxOverflowDelayedTaskList
 3422              		.cfi_endproc
 3423              	.LFE100:
 3424              		.size	prvInitialiseTaskLists, .-prvInitialiseTaskLists
 3425              		.section	.text.prvCheckTasksWaitingTermination,"ax",%progbits
 3426              		.align	2
 3427              		.thumb
 3428              		.thumb_func
 3429              		.type	prvCheckTasksWaitingTermination, %function
 3430              	prvCheckTasksWaitingTermination:
 3431              	.LFB101:
3256:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
3257:..\..\..\Source/tasks.c **** 
3258:..\..\..\Source/tasks.c **** static void prvCheckTasksWaitingTermination( void )
3259:..\..\..\Source/tasks.c **** {
 3432              		.loc 1 3259 0
 3433              		.cfi_startproc
 3434              		@ args = 0, pretend = 0, frame = 8
 3435              		@ frame_needed = 1, uses_anonymous_args = 0
 3436 0000 80B5     		push	{r7, lr}
 3437              		.cfi_def_cfa_offset 8
 3438              		.cfi_offset 7, -8
 3439              		.cfi_offset 14, -4
 3440 0002 82B0     		sub	sp, sp, #8
 3441              		.cfi_def_cfa_offset 16
 3442 0004 00AF     		add	r7, sp, #0
 3443              		.cfi_def_cfa_register 7
 3444              	.LBB50:
3260:..\..\..\Source/tasks.c **** 
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 124


3261:..\..\..\Source/tasks.c **** 	/** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
3262:..\..\..\Source/tasks.c **** 
3263:..\..\..\Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
3264:..\..\..\Source/tasks.c **** 	{
3265:..\..\..\Source/tasks.c **** 		BaseType_t xListIsEmpty;
3266:..\..\..\Source/tasks.c **** 
3267:..\..\..\Source/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
3268:..\..\..\Source/tasks.c **** 		too often in the idle task. */
3269:..\..\..\Source/tasks.c **** 		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 3445              		.loc 1 3269 0
 3446 0006 28E0     		b	.L230
 3447              	.L231:
3270:..\..\..\Source/tasks.c **** 		{
3271:..\..\..\Source/tasks.c **** 			vTaskSuspendAll();
 3448              		.loc 1 3271 0
 3449 0008 FFF7FEFF 		bl	vTaskSuspendAll
3272:..\..\..\Source/tasks.c **** 			{
3273:..\..\..\Source/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 3450              		.loc 1 3273 0
 3451 000c 164B     		ldr	r3, .L232
 3452 000e 1B68     		ldr	r3, [r3]
 3453 0010 002B     		cmp	r3, #0
 3454 0012 0CBF     		ite	eq
 3455 0014 0123     		moveq	r3, #1
 3456 0016 0023     		movne	r3, #0
 3457 0018 DBB2     		uxtb	r3, r3
 3458 001a 7B60     		str	r3, [r7, #4]
3274:..\..\..\Source/tasks.c **** 			}
3275:..\..\..\Source/tasks.c **** 			( void ) xTaskResumeAll();
 3459              		.loc 1 3275 0
 3460 001c FFF7FEFF 		bl	xTaskResumeAll
3276:..\..\..\Source/tasks.c **** 
3277:..\..\..\Source/tasks.c **** 			if( xListIsEmpty == pdFALSE )
 3461              		.loc 1 3277 0
 3462 0020 7B68     		ldr	r3, [r7, #4]
 3463 0022 002B     		cmp	r3, #0
 3464 0024 19D1     		bne	.L230
 3465              	.LBB51:
3278:..\..\..\Source/tasks.c **** 			{
3279:..\..\..\Source/tasks.c **** 				TCB_t *pxTCB;
3280:..\..\..\Source/tasks.c **** 
3281:..\..\..\Source/tasks.c **** 				taskENTER_CRITICAL();
 3466              		.loc 1 3281 0
 3467 0026 FFF7FEFF 		bl	vPortEnterCritical
3282:..\..\..\Source/tasks.c **** 				{
3283:..\..\..\Source/tasks.c **** 					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 3468              		.loc 1 3283 0
 3469 002a 0F4B     		ldr	r3, .L232
 3470 002c DB68     		ldr	r3, [r3, #12]
 3471 002e DB68     		ldr	r3, [r3, #12]
 3472 0030 3B60     		str	r3, [r7]
3284:..\..\..\Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 3473              		.loc 1 3284 0
 3474 0032 3B68     		ldr	r3, [r7]
 3475 0034 0433     		adds	r3, r3, #4
 3476 0036 1846     		mov	r0, r3
 3477 0038 FFF7FEFF 		bl	uxListRemove
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 125


3285:..\..\..\Source/tasks.c **** 					--uxCurrentNumberOfTasks;
 3478              		.loc 1 3285 0
 3479 003c 0B4B     		ldr	r3, .L232+4
 3480 003e 1B68     		ldr	r3, [r3]
 3481 0040 013B     		subs	r3, r3, #1
 3482 0042 0A4A     		ldr	r2, .L232+4
 3483 0044 1360     		str	r3, [r2]
3286:..\..\..\Source/tasks.c **** 					--uxDeletedTasksWaitingCleanUp;
 3484              		.loc 1 3286 0
 3485 0046 0A4B     		ldr	r3, .L232+8
 3486 0048 1B68     		ldr	r3, [r3]
 3487 004a 013B     		subs	r3, r3, #1
 3488 004c 084A     		ldr	r2, .L232+8
 3489 004e 1360     		str	r3, [r2]
3287:..\..\..\Source/tasks.c **** 				}
3288:..\..\..\Source/tasks.c **** 				taskEXIT_CRITICAL();
 3490              		.loc 1 3288 0
 3491 0050 FFF7FEFF 		bl	vPortExitCritical
3289:..\..\..\Source/tasks.c **** 
3290:..\..\..\Source/tasks.c **** 				prvDeleteTCB( pxTCB );
 3492              		.loc 1 3290 0
 3493 0054 3868     		ldr	r0, [r7]
 3494 0056 FFF7FEFF 		bl	prvDeleteTCB
 3495              	.L230:
 3496              	.LBE51:
3269:..\..\..\Source/tasks.c **** 		{
 3497              		.loc 1 3269 0
 3498 005a 054B     		ldr	r3, .L232+8
 3499 005c 1B68     		ldr	r3, [r3]
 3500 005e 002B     		cmp	r3, #0
 3501 0060 D2D1     		bne	.L231
 3502              	.LBE50:
3291:..\..\..\Source/tasks.c **** 			}
3292:..\..\..\Source/tasks.c **** 			else
3293:..\..\..\Source/tasks.c **** 			{
3294:..\..\..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3295:..\..\..\Source/tasks.c **** 			}
3296:..\..\..\Source/tasks.c **** 		}
3297:..\..\..\Source/tasks.c **** 	}
3298:..\..\..\Source/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
3299:..\..\..\Source/tasks.c **** }
 3503              		.loc 1 3299 0
 3504 0062 0837     		adds	r7, r7, #8
 3505              		.cfi_def_cfa_offset 8
 3506 0064 BD46     		mov	sp, r7
 3507              		.cfi_def_cfa_register 13
 3508              		@ sp needed
 3509 0066 80BD     		pop	{r7, pc}
 3510              	.L233:
 3511              		.align	2
 3512              	.L232:
 3513 0068 AC000000 		.word	xTasksWaitingTermination
 3514 006c D8000000 		.word	uxCurrentNumberOfTasks
 3515 0070 C0000000 		.word	uxDeletedTasksWaitingCleanUp
 3516              		.cfi_endproc
 3517              	.LFE101:
 3518              		.size	prvCheckTasksWaitingTermination, .-prvCheckTasksWaitingTermination
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 126


 3519              		.section	.text.prvTaskCheckFreeStackSpace,"ax",%progbits
 3520              		.align	2
 3521              		.thumb
 3522              		.thumb_func
 3523              		.type	prvTaskCheckFreeStackSpace, %function
 3524              	prvTaskCheckFreeStackSpace:
 3525              	.LFB102:
3300:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
3301:..\..\..\Source/tasks.c **** 
3302:..\..\..\Source/tasks.c **** #if( configUSE_TRACE_FACILITY == 1 )
3303:..\..\..\Source/tasks.c **** 
3304:..\..\..\Source/tasks.c **** 	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, 
3305:..\..\..\Source/tasks.c **** 	{
3306:..\..\..\Source/tasks.c **** 	TCB_t *pxTCB;
3307:..\..\..\Source/tasks.c **** 
3308:..\..\..\Source/tasks.c **** 		/* xTask is NULL then get the state of the calling task. */
3309:..\..\..\Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
3310:..\..\..\Source/tasks.c **** 
3311:..\..\..\Source/tasks.c **** 		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
3312:..\..\..\Source/tasks.c **** 		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
3313:..\..\..\Source/tasks.c **** 		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
3314:..\..\..\Source/tasks.c **** 		pxTaskStatus->pxStackBase = pxTCB->pxStack;
3315:..\..\..\Source/tasks.c **** 		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
3316:..\..\..\Source/tasks.c **** 
3317:..\..\..\Source/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
3318:..\..\..\Source/tasks.c **** 		{
3319:..\..\..\Source/tasks.c **** 			/* If the task is in the suspended list then there is a chance it is
3320:..\..\..\Source/tasks.c **** 			actually just blocked indefinitely - so really it should be reported as
3321:..\..\..\Source/tasks.c **** 			being in the Blocked state. */
3322:..\..\..\Source/tasks.c **** 			if( pxTaskStatus->eCurrentState == eSuspended )
3323:..\..\..\Source/tasks.c **** 			{
3324:..\..\..\Source/tasks.c **** 				vTaskSuspendAll();
3325:..\..\..\Source/tasks.c **** 				{
3326:..\..\..\Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
3327:..\..\..\Source/tasks.c **** 					{
3328:..\..\..\Source/tasks.c **** 						pxTaskStatus->eCurrentState = eBlocked;
3329:..\..\..\Source/tasks.c **** 					}
3330:..\..\..\Source/tasks.c **** 				}
3331:..\..\..\Source/tasks.c **** 				xTaskResumeAll();
3332:..\..\..\Source/tasks.c **** 			}
3333:..\..\..\Source/tasks.c **** 		}
3334:..\..\..\Source/tasks.c **** 		#endif /* INCLUDE_vTaskSuspend */
3335:..\..\..\Source/tasks.c **** 
3336:..\..\..\Source/tasks.c **** 		#if ( configUSE_MUTEXES == 1 )
3337:..\..\..\Source/tasks.c **** 		{
3338:..\..\..\Source/tasks.c **** 			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
3339:..\..\..\Source/tasks.c **** 		}
3340:..\..\..\Source/tasks.c **** 		#else
3341:..\..\..\Source/tasks.c **** 		{
3342:..\..\..\Source/tasks.c **** 			pxTaskStatus->uxBasePriority = 0;
3343:..\..\..\Source/tasks.c **** 		}
3344:..\..\..\Source/tasks.c **** 		#endif
3345:..\..\..\Source/tasks.c **** 
3346:..\..\..\Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
3347:..\..\..\Source/tasks.c **** 		{
3348:..\..\..\Source/tasks.c **** 			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
3349:..\..\..\Source/tasks.c **** 		}
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 127


3350:..\..\..\Source/tasks.c **** 		#else
3351:..\..\..\Source/tasks.c **** 		{
3352:..\..\..\Source/tasks.c **** 			pxTaskStatus->ulRunTimeCounter = 0;
3353:..\..\..\Source/tasks.c **** 		}
3354:..\..\..\Source/tasks.c **** 		#endif
3355:..\..\..\Source/tasks.c **** 
3356:..\..\..\Source/tasks.c **** 		/* Obtaining the task state is a little fiddly, so is only done if the value
3357:..\..\..\Source/tasks.c **** 		of eState passed into this function is eInvalid - otherwise the state is
3358:..\..\..\Source/tasks.c **** 		just set to whatever is passed in. */
3359:..\..\..\Source/tasks.c **** 		if( eState != eInvalid )
3360:..\..\..\Source/tasks.c **** 		{
3361:..\..\..\Source/tasks.c **** 			pxTaskStatus->eCurrentState = eState;
3362:..\..\..\Source/tasks.c **** 		}
3363:..\..\..\Source/tasks.c **** 		else
3364:..\..\..\Source/tasks.c **** 		{
3365:..\..\..\Source/tasks.c **** 			pxTaskStatus->eCurrentState = eTaskGetState( xTask );
3366:..\..\..\Source/tasks.c **** 		}
3367:..\..\..\Source/tasks.c **** 
3368:..\..\..\Source/tasks.c **** 		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
3369:..\..\..\Source/tasks.c **** 		parameter is provided to allow it to be skipped. */
3370:..\..\..\Source/tasks.c **** 		if( xGetFreeStackSpace != pdFALSE )
3371:..\..\..\Source/tasks.c **** 		{
3372:..\..\..\Source/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
3373:..\..\..\Source/tasks.c **** 			{
3374:..\..\..\Source/tasks.c **** 				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfSt
3375:..\..\..\Source/tasks.c **** 			}
3376:..\..\..\Source/tasks.c **** 			#else
3377:..\..\..\Source/tasks.c **** 			{
3378:..\..\..\Source/tasks.c **** 				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack )
3379:..\..\..\Source/tasks.c **** 			}
3380:..\..\..\Source/tasks.c **** 			#endif
3381:..\..\..\Source/tasks.c **** 		}
3382:..\..\..\Source/tasks.c **** 		else
3383:..\..\..\Source/tasks.c **** 		{
3384:..\..\..\Source/tasks.c **** 			pxTaskStatus->usStackHighWaterMark = 0;
3385:..\..\..\Source/tasks.c **** 		}
3386:..\..\..\Source/tasks.c **** 	}
3387:..\..\..\Source/tasks.c **** 
3388:..\..\..\Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3389:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
3390:..\..\..\Source/tasks.c **** 
3391:..\..\..\Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3392:..\..\..\Source/tasks.c **** 
3393:..\..\..\Source/tasks.c **** 	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, 
3394:..\..\..\Source/tasks.c **** 	{
3395:..\..\..\Source/tasks.c **** 	volatile TCB_t *pxNextTCB, *pxFirstTCB;
3396:..\..\..\Source/tasks.c **** 	UBaseType_t uxTask = 0;
3397:..\..\..\Source/tasks.c **** 
3398:..\..\..\Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
3399:..\..\..\Source/tasks.c **** 		{
3400:..\..\..\Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
3401:..\..\..\Source/tasks.c **** 
3402:..\..\..\Source/tasks.c **** 			/* Populate an TaskStatus_t structure within the
3403:..\..\..\Source/tasks.c **** 			pxTaskStatusArray array for each task that is referenced from
3404:..\..\..\Source/tasks.c **** 			pxList.  See the definition of TaskStatus_t in task.h for the
3405:..\..\..\Source/tasks.c **** 			meaning of each TaskStatus_t structure member. */
3406:..\..\..\Source/tasks.c **** 			do
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 128


3407:..\..\..\Source/tasks.c **** 			{
3408:..\..\..\Source/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
3409:..\..\..\Source/tasks.c **** 				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
3410:..\..\..\Source/tasks.c **** 				uxTask++;
3411:..\..\..\Source/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
3412:..\..\..\Source/tasks.c **** 		}
3413:..\..\..\Source/tasks.c **** 		else
3414:..\..\..\Source/tasks.c **** 		{
3415:..\..\..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3416:..\..\..\Source/tasks.c **** 		}
3417:..\..\..\Source/tasks.c **** 
3418:..\..\..\Source/tasks.c **** 		return uxTask;
3419:..\..\..\Source/tasks.c **** 	}
3420:..\..\..\Source/tasks.c **** 
3421:..\..\..\Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3422:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
3423:..\..\..\Source/tasks.c **** 
3424:..\..\..\Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
3425:..\..\..\Source/tasks.c **** 
3426:..\..\..\Source/tasks.c **** 	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
3427:..\..\..\Source/tasks.c **** 	{
 3526              		.loc 1 3427 0
 3527              		.cfi_startproc
 3528              		@ args = 0, pretend = 0, frame = 16
 3529              		@ frame_needed = 1, uses_anonymous_args = 0
 3530              		@ link register save eliminated.
 3531 0000 80B4     		push	{r7}
 3532              		.cfi_def_cfa_offset 4
 3533              		.cfi_offset 7, -4
 3534 0002 85B0     		sub	sp, sp, #20
 3535              		.cfi_def_cfa_offset 24
 3536 0004 00AF     		add	r7, sp, #0
 3537              		.cfi_def_cfa_register 7
 3538 0006 7860     		str	r0, [r7, #4]
3428:..\..\..\Source/tasks.c **** 	uint32_t ulCount = 0U;
 3539              		.loc 1 3428 0
 3540 0008 0023     		movs	r3, #0
 3541 000a FB60     		str	r3, [r7, #12]
3429:..\..\..\Source/tasks.c **** 
3430:..\..\..\Source/tasks.c **** 		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 3542              		.loc 1 3430 0
 3543 000c 05E0     		b	.L235
 3544              	.L236:
3431:..\..\..\Source/tasks.c **** 		{
3432:..\..\..\Source/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
 3545              		.loc 1 3432 0
 3546 000e 7B68     		ldr	r3, [r7, #4]
 3547 0010 0133     		adds	r3, r3, #1
 3548 0012 7B60     		str	r3, [r7, #4]
3433:..\..\..\Source/tasks.c **** 			ulCount++;
 3549              		.loc 1 3433 0
 3550 0014 FB68     		ldr	r3, [r7, #12]
 3551 0016 0133     		adds	r3, r3, #1
 3552 0018 FB60     		str	r3, [r7, #12]
 3553              	.L235:
3430:..\..\..\Source/tasks.c **** 		{
 3554              		.loc 1 3430 0
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 129


 3555 001a 7B68     		ldr	r3, [r7, #4]
 3556 001c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 3557 001e A52B     		cmp	r3, #165
 3558 0020 F5D0     		beq	.L236
3434:..\..\..\Source/tasks.c **** 		}
3435:..\..\..\Source/tasks.c **** 
3436:..\..\..\Source/tasks.c **** 		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller a
 3559              		.loc 1 3436 0
 3560 0022 FB68     		ldr	r3, [r7, #12]
 3561 0024 9B08     		lsrs	r3, r3, #2
 3562 0026 FB60     		str	r3, [r7, #12]
3437:..\..\..\Source/tasks.c **** 
3438:..\..\..\Source/tasks.c **** 		return ( uint16_t ) ulCount;
 3563              		.loc 1 3438 0
 3564 0028 FB68     		ldr	r3, [r7, #12]
 3565 002a 9BB2     		uxth	r3, r3
3439:..\..\..\Source/tasks.c **** 	}
 3566              		.loc 1 3439 0
 3567 002c 1846     		mov	r0, r3
 3568 002e 1437     		adds	r7, r7, #20
 3569              		.cfi_def_cfa_offset 4
 3570 0030 BD46     		mov	sp, r7
 3571              		.cfi_def_cfa_register 13
 3572              		@ sp needed
 3573 0032 5DF8047B 		ldr	r7, [sp], #4
 3574              		.cfi_restore 7
 3575              		.cfi_def_cfa_offset 0
 3576 0036 7047     		bx	lr
 3577              		.cfi_endproc
 3578              	.LFE102:
 3579              		.size	prvTaskCheckFreeStackSpace, .-prvTaskCheckFreeStackSpace
 3580              		.section	.text.uxTaskGetStackHighWaterMark,"ax",%progbits
 3581              		.align	2
 3582              		.global	uxTaskGetStackHighWaterMark
 3583              		.thumb
 3584              		.thumb_func
 3585              		.type	uxTaskGetStackHighWaterMark, %function
 3586              	uxTaskGetStackHighWaterMark:
 3587              	.LFB103:
3440:..\..\..\Source/tasks.c **** 
3441:..\..\..\Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
3442:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
3443:..\..\..\Source/tasks.c **** 
3444:..\..\..\Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
3445:..\..\..\Source/tasks.c **** 
3446:..\..\..\Source/tasks.c **** 	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
3447:..\..\..\Source/tasks.c **** 	{
 3588              		.loc 1 3447 0
 3589              		.cfi_startproc
 3590              		@ args = 0, pretend = 0, frame = 24
 3591              		@ frame_needed = 1, uses_anonymous_args = 0
 3592 0000 80B5     		push	{r7, lr}
 3593              		.cfi_def_cfa_offset 8
 3594              		.cfi_offset 7, -8
 3595              		.cfi_offset 14, -4
 3596 0002 86B0     		sub	sp, sp, #24
 3597              		.cfi_def_cfa_offset 32
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 130


 3598 0004 00AF     		add	r7, sp, #0
 3599              		.cfi_def_cfa_register 7
 3600 0006 7860     		str	r0, [r7, #4]
3448:..\..\..\Source/tasks.c **** 	TCB_t *pxTCB;
3449:..\..\..\Source/tasks.c **** 	uint8_t *pucEndOfStack;
3450:..\..\..\Source/tasks.c **** 	UBaseType_t uxReturn;
3451:..\..\..\Source/tasks.c **** 
3452:..\..\..\Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
 3601              		.loc 1 3452 0
 3602 0008 7B68     		ldr	r3, [r7, #4]
 3603 000a 002B     		cmp	r3, #0
 3604 000c 02D1     		bne	.L239
 3605              		.loc 1 3452 0 is_stmt 0 discriminator 1
 3606 000e 094B     		ldr	r3, .L242
 3607 0010 1B68     		ldr	r3, [r3]
 3608 0012 00E0     		b	.L240
 3609              	.L239:
 3610              		.loc 1 3452 0 discriminator 2
 3611 0014 7B68     		ldr	r3, [r7, #4]
 3612              	.L240:
 3613              		.loc 1 3452 0 discriminator 4
 3614 0016 7B61     		str	r3, [r7, #20]
3453:..\..\..\Source/tasks.c **** 
3454:..\..\..\Source/tasks.c **** 		#if portSTACK_GROWTH < 0
3455:..\..\..\Source/tasks.c **** 		{
3456:..\..\..\Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
 3615              		.loc 1 3456 0 is_stmt 1 discriminator 4
 3616 0018 7B69     		ldr	r3, [r7, #20]
 3617 001a 1B6B     		ldr	r3, [r3, #48]
 3618 001c 3B61     		str	r3, [r7, #16]
3457:..\..\..\Source/tasks.c **** 		}
3458:..\..\..\Source/tasks.c **** 		#else
3459:..\..\..\Source/tasks.c **** 		{
3460:..\..\..\Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3461:..\..\..\Source/tasks.c **** 		}
3462:..\..\..\Source/tasks.c **** 		#endif
3463:..\..\..\Source/tasks.c **** 
3464:..\..\..\Source/tasks.c **** 		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
 3619              		.loc 1 3464 0 discriminator 4
 3620 001e 3869     		ldr	r0, [r7, #16]
 3621 0020 FFF7FEFF 		bl	prvTaskCheckFreeStackSpace
 3622 0024 0346     		mov	r3, r0
 3623 0026 FB60     		str	r3, [r7, #12]
3465:..\..\..\Source/tasks.c **** 
3466:..\..\..\Source/tasks.c **** 		return uxReturn;
 3624              		.loc 1 3466 0 discriminator 4
 3625 0028 FB68     		ldr	r3, [r7, #12]
3467:..\..\..\Source/tasks.c **** 	}
 3626              		.loc 1 3467 0 discriminator 4
 3627 002a 1846     		mov	r0, r3
 3628 002c 1837     		adds	r7, r7, #24
 3629              		.cfi_def_cfa_offset 8
 3630 002e BD46     		mov	sp, r7
 3631              		.cfi_def_cfa_register 13
 3632              		@ sp needed
 3633 0030 80BD     		pop	{r7, pc}
 3634              	.L243:
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 131


 3635 0032 00BF     		.align	2
 3636              	.L242:
 3637 0034 00000000 		.word	pxCurrentTCB
 3638              		.cfi_endproc
 3639              	.LFE103:
 3640              		.size	uxTaskGetStackHighWaterMark, .-uxTaskGetStackHighWaterMark
 3641              		.section	.text.prvDeleteTCB,"ax",%progbits
 3642              		.align	2
 3643              		.thumb
 3644              		.thumb_func
 3645              		.type	prvDeleteTCB, %function
 3646              	prvDeleteTCB:
 3647              	.LFB104:
3468:..\..\..\Source/tasks.c **** 
3469:..\..\..\Source/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
3470:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
3471:..\..\..\Source/tasks.c **** 
3472:..\..\..\Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
3473:..\..\..\Source/tasks.c **** 
3474:..\..\..\Source/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB )
3475:..\..\..\Source/tasks.c **** 	{
 3648              		.loc 1 3475 0
 3649              		.cfi_startproc
 3650              		@ args = 0, pretend = 0, frame = 8
 3651              		@ frame_needed = 1, uses_anonymous_args = 0
 3652 0000 80B5     		push	{r7, lr}
 3653              		.cfi_def_cfa_offset 8
 3654              		.cfi_offset 7, -8
 3655              		.cfi_offset 14, -4
 3656 0002 82B0     		sub	sp, sp, #8
 3657              		.cfi_def_cfa_offset 16
 3658 0004 00AF     		add	r7, sp, #0
 3659              		.cfi_def_cfa_register 7
 3660 0006 7860     		str	r0, [r7, #4]
3476:..\..\..\Source/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
3477:..\..\..\Source/tasks.c **** 		above the vPortFree() calls.  The call is also used by ports/demos that
3478:..\..\..\Source/tasks.c **** 		want to allocate and clean RAM statically. */
3479:..\..\..\Source/tasks.c **** 		portCLEAN_UP_TCB( pxTCB );
3480:..\..\..\Source/tasks.c **** 
3481:..\..\..\Source/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up
3482:..\..\..\Source/tasks.c **** 		to the task to free any memory allocated at the application level. */
3483:..\..\..\Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
3484:..\..\..\Source/tasks.c **** 		{
3485:..\..\..\Source/tasks.c **** 			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
3486:..\..\..\Source/tasks.c **** 		}
3487:..\..\..\Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
3488:..\..\..\Source/tasks.c **** 
3489:..\..\..\Source/tasks.c **** 		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
3490:..\..\..\Source/tasks.c **** 		{
3491:..\..\..\Source/tasks.c **** 			/* The task can only have been allocated dynamically - free it
3492:..\..\..\Source/tasks.c **** 			again. */
3493:..\..\..\Source/tasks.c **** 			vPortFree( pxTCB->pxStack );
 3661              		.loc 1 3493 0
 3662 0008 7B68     		ldr	r3, [r7, #4]
 3663 000a 1B6B     		ldr	r3, [r3, #48]
 3664 000c 1846     		mov	r0, r3
 3665 000e FFF7FEFF 		bl	vPortFree
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 132


3494:..\..\..\Source/tasks.c **** 			vPortFree( pxTCB );
 3666              		.loc 1 3494 0
 3667 0012 7868     		ldr	r0, [r7, #4]
 3668 0014 FFF7FEFF 		bl	vPortFree
3495:..\..\..\Source/tasks.c **** 		}
3496:..\..\..\Source/tasks.c **** 		#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
3497:..\..\..\Source/tasks.c **** 		{
3498:..\..\..\Source/tasks.c **** 			/* The task could have been allocated statically or dynamically, so
3499:..\..\..\Source/tasks.c **** 			check before attempting to free the memory. */
3500:..\..\..\Source/tasks.c **** 			if( pxTCB->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
3501:..\..\..\Source/tasks.c **** 			{
3502:..\..\..\Source/tasks.c **** 				vPortFree( pxTCB->pxStack );
3503:..\..\..\Source/tasks.c **** 				vPortFree( pxTCB );
3504:..\..\..\Source/tasks.c **** 			}
3505:..\..\..\Source/tasks.c **** 			else
3506:..\..\..\Source/tasks.c **** 			{
3507:..\..\..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3508:..\..\..\Source/tasks.c **** 			}
3509:..\..\..\Source/tasks.c **** 		}
3510:..\..\..\Source/tasks.c **** 		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
3511:..\..\..\Source/tasks.c **** 	}
 3669              		.loc 1 3511 0
 3670 0018 0837     		adds	r7, r7, #8
 3671              		.cfi_def_cfa_offset 8
 3672 001a BD46     		mov	sp, r7
 3673              		.cfi_def_cfa_register 13
 3674              		@ sp needed
 3675 001c 80BD     		pop	{r7, pc}
 3676              		.cfi_endproc
 3677              	.LFE104:
 3678              		.size	prvDeleteTCB, .-prvDeleteTCB
 3679 001e 00BF     		.section	.text.prvResetNextTaskUnblockTime,"ax",%progbits
 3680              		.align	2
 3681              		.thumb
 3682              		.thumb_func
 3683              		.type	prvResetNextTaskUnblockTime, %function
 3684              	prvResetNextTaskUnblockTime:
 3685              	.LFB105:
3512:..\..\..\Source/tasks.c **** 
3513:..\..\..\Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
3514:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
3515:..\..\..\Source/tasks.c **** 
3516:..\..\..\Source/tasks.c **** static void prvResetNextTaskUnblockTime( void )
3517:..\..\..\Source/tasks.c **** {
 3686              		.loc 1 3517 0
 3687              		.cfi_startproc
 3688              		@ args = 0, pretend = 0, frame = 8
 3689              		@ frame_needed = 1, uses_anonymous_args = 0
 3690              		@ link register save eliminated.
 3691 0000 80B4     		push	{r7}
 3692              		.cfi_def_cfa_offset 4
 3693              		.cfi_offset 7, -4
 3694 0002 83B0     		sub	sp, sp, #12
 3695              		.cfi_def_cfa_offset 16
 3696 0004 00AF     		add	r7, sp, #0
 3697              		.cfi_def_cfa_register 7
3518:..\..\..\Source/tasks.c **** TCB_t *pxTCB;
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 133


3519:..\..\..\Source/tasks.c **** 
3520:..\..\..\Source/tasks.c **** 	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 3698              		.loc 1 3520 0
 3699 0006 0E4B     		ldr	r3, .L250
 3700 0008 1B68     		ldr	r3, [r3]
 3701 000a 1B68     		ldr	r3, [r3]
 3702 000c 002B     		cmp	r3, #0
 3703 000e 01D1     		bne	.L246
 3704              		.loc 1 3520 0 is_stmt 0 discriminator 1
 3705 0010 0123     		movs	r3, #1
 3706 0012 00E0     		b	.L247
 3707              	.L246:
 3708              		.loc 1 3520 0 discriminator 2
 3709 0014 0023     		movs	r3, #0
 3710              	.L247:
 3711              		.loc 1 3520 0 discriminator 4
 3712 0016 002B     		cmp	r3, #0
 3713 0018 04D0     		beq	.L248
3521:..\..\..\Source/tasks.c **** 	{
3522:..\..\..\Source/tasks.c **** 		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
3523:..\..\..\Source/tasks.c **** 		the maximum possible value so it is	extremely unlikely that the
3524:..\..\..\Source/tasks.c **** 		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
3525:..\..\..\Source/tasks.c **** 		there is an item in the delayed list. */
3526:..\..\..\Source/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
 3714              		.loc 1 3526 0 is_stmt 1
 3715 001a 0A4B     		ldr	r3, .L250+4
 3716 001c 4FF0FF32 		mov	r2, #-1
 3717 0020 1A60     		str	r2, [r3]
 3718 0022 08E0     		b	.L245
 3719              	.L248:
3527:..\..\..\Source/tasks.c **** 	}
3528:..\..\..\Source/tasks.c **** 	else
3529:..\..\..\Source/tasks.c **** 	{
3530:..\..\..\Source/tasks.c **** 		/* The new current delayed list is not empty, get the value of
3531:..\..\..\Source/tasks.c **** 		the item at the head of the delayed list.  This is the time at
3532:..\..\..\Source/tasks.c **** 		which the task at the head of the delayed list should be removed
3533:..\..\..\Source/tasks.c **** 		from the Blocked state. */
3534:..\..\..\Source/tasks.c **** 		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 3720              		.loc 1 3534 0
 3721 0024 064B     		ldr	r3, .L250
 3722 0026 1B68     		ldr	r3, [r3]
 3723 0028 DB68     		ldr	r3, [r3, #12]
 3724 002a DB68     		ldr	r3, [r3, #12]
 3725 002c 7B60     		str	r3, [r7, #4]
3535:..\..\..\Source/tasks.c **** 		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 3726              		.loc 1 3535 0
 3727 002e 7B68     		ldr	r3, [r7, #4]
 3728 0030 5B68     		ldr	r3, [r3, #4]
 3729 0032 044A     		ldr	r2, .L250+4
 3730 0034 1360     		str	r3, [r2]
 3731              	.L245:
3536:..\..\..\Source/tasks.c **** 	}
3537:..\..\..\Source/tasks.c **** }
 3732              		.loc 1 3537 0
 3733 0036 0C37     		adds	r7, r7, #12
 3734              		.cfi_def_cfa_offset 4
 3735 0038 BD46     		mov	sp, r7
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 134


 3736              		.cfi_def_cfa_register 13
 3737              		@ sp needed
 3738 003a 5DF8047B 		ldr	r7, [sp], #4
 3739              		.cfi_restore 7
 3740              		.cfi_def_cfa_offset 0
 3741 003e 7047     		bx	lr
 3742              	.L251:
 3743              		.align	2
 3744              	.L250:
 3745 0040 90000000 		.word	pxDelayedTaskList
 3746 0044 F8000000 		.word	xNextTaskUnblockTime
 3747              		.cfi_endproc
 3748              	.LFE105:
 3749              		.size	prvResetNextTaskUnblockTime, .-prvResetNextTaskUnblockTime
 3750              		.section	.text.xTaskGetCurrentTaskHandle,"ax",%progbits
 3751              		.align	2
 3752              		.global	xTaskGetCurrentTaskHandle
 3753              		.thumb
 3754              		.thumb_func
 3755              		.type	xTaskGetCurrentTaskHandle, %function
 3756              	xTaskGetCurrentTaskHandle:
 3757              	.LFB106:
3538:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
3539:..\..\..\Source/tasks.c **** 
3540:..\..\..\Source/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
3541:..\..\..\Source/tasks.c **** 
3542:..\..\..\Source/tasks.c **** 	TaskHandle_t xTaskGetCurrentTaskHandle( void )
3543:..\..\..\Source/tasks.c **** 	{
 3758              		.loc 1 3543 0
 3759              		.cfi_startproc
 3760              		@ args = 0, pretend = 0, frame = 8
 3761              		@ frame_needed = 1, uses_anonymous_args = 0
 3762              		@ link register save eliminated.
 3763 0000 80B4     		push	{r7}
 3764              		.cfi_def_cfa_offset 4
 3765              		.cfi_offset 7, -4
 3766 0002 83B0     		sub	sp, sp, #12
 3767              		.cfi_def_cfa_offset 16
 3768 0004 00AF     		add	r7, sp, #0
 3769              		.cfi_def_cfa_register 7
3544:..\..\..\Source/tasks.c **** 	TaskHandle_t xReturn;
3545:..\..\..\Source/tasks.c **** 
3546:..\..\..\Source/tasks.c **** 		/* A critical section is not required as this is not called from
3547:..\..\..\Source/tasks.c **** 		an interrupt and the current TCB will always be the same for any
3548:..\..\..\Source/tasks.c **** 		individual execution thread. */
3549:..\..\..\Source/tasks.c **** 		xReturn = pxCurrentTCB;
 3770              		.loc 1 3549 0
 3771 0006 054B     		ldr	r3, .L254
 3772 0008 1B68     		ldr	r3, [r3]
 3773 000a 7B60     		str	r3, [r7, #4]
3550:..\..\..\Source/tasks.c **** 
3551:..\..\..\Source/tasks.c **** 		return xReturn;
 3774              		.loc 1 3551 0
 3775 000c 7B68     		ldr	r3, [r7, #4]
3552:..\..\..\Source/tasks.c **** 	}
 3776              		.loc 1 3552 0
 3777 000e 1846     		mov	r0, r3
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 135


 3778 0010 0C37     		adds	r7, r7, #12
 3779              		.cfi_def_cfa_offset 4
 3780 0012 BD46     		mov	sp, r7
 3781              		.cfi_def_cfa_register 13
 3782              		@ sp needed
 3783 0014 5DF8047B 		ldr	r7, [sp], #4
 3784              		.cfi_restore 7
 3785              		.cfi_def_cfa_offset 0
 3786 0018 7047     		bx	lr
 3787              	.L255:
 3788 001a 00BF     		.align	2
 3789              	.L254:
 3790 001c 00000000 		.word	pxCurrentTCB
 3791              		.cfi_endproc
 3792              	.LFE106:
 3793              		.size	xTaskGetCurrentTaskHandle, .-xTaskGetCurrentTaskHandle
 3794              		.section	.text.vTaskPriorityInherit,"ax",%progbits
 3795              		.align	2
 3796              		.global	vTaskPriorityInherit
 3797              		.thumb
 3798              		.thumb_func
 3799              		.type	vTaskPriorityInherit, %function
 3800              	vTaskPriorityInherit:
 3801              	.LFB107:
3553:..\..\..\Source/tasks.c **** 
3554:..\..\..\Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
3555:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
3556:..\..\..\Source/tasks.c **** 
3557:..\..\..\Source/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
3558:..\..\..\Source/tasks.c **** 
3559:..\..\..\Source/tasks.c **** 	BaseType_t xTaskGetSchedulerState( void )
3560:..\..\..\Source/tasks.c **** 	{
3561:..\..\..\Source/tasks.c **** 	BaseType_t xReturn;
3562:..\..\..\Source/tasks.c **** 
3563:..\..\..\Source/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
3564:..\..\..\Source/tasks.c **** 		{
3565:..\..\..\Source/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
3566:..\..\..\Source/tasks.c **** 		}
3567:..\..\..\Source/tasks.c **** 		else
3568:..\..\..\Source/tasks.c **** 		{
3569:..\..\..\Source/tasks.c **** 			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
3570:..\..\..\Source/tasks.c **** 			{
3571:..\..\..\Source/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
3572:..\..\..\Source/tasks.c **** 			}
3573:..\..\..\Source/tasks.c **** 			else
3574:..\..\..\Source/tasks.c **** 			{
3575:..\..\..\Source/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
3576:..\..\..\Source/tasks.c **** 			}
3577:..\..\..\Source/tasks.c **** 		}
3578:..\..\..\Source/tasks.c **** 
3579:..\..\..\Source/tasks.c **** 		return xReturn;
3580:..\..\..\Source/tasks.c **** 	}
3581:..\..\..\Source/tasks.c **** 
3582:..\..\..\Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
3583:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
3584:..\..\..\Source/tasks.c **** 
3585:..\..\..\Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 136


3586:..\..\..\Source/tasks.c **** 
3587:..\..\..\Source/tasks.c **** 	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
3588:..\..\..\Source/tasks.c **** 	{
 3802              		.loc 1 3588 0
 3803              		.cfi_startproc
 3804              		@ args = 0, pretend = 0, frame = 16
 3805              		@ frame_needed = 1, uses_anonymous_args = 0
 3806 0000 80B5     		push	{r7, lr}
 3807              		.cfi_def_cfa_offset 8
 3808              		.cfi_offset 7, -8
 3809              		.cfi_offset 14, -4
 3810 0002 84B0     		sub	sp, sp, #16
 3811              		.cfi_def_cfa_offset 24
 3812 0004 00AF     		add	r7, sp, #0
 3813              		.cfi_def_cfa_register 7
 3814 0006 7860     		str	r0, [r7, #4]
3589:..\..\..\Source/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
 3815              		.loc 1 3589 0
 3816 0008 7B68     		ldr	r3, [r7, #4]
 3817 000a FB60     		str	r3, [r7, #12]
3590:..\..\..\Source/tasks.c **** 
3591:..\..\..\Source/tasks.c **** 		/* If the mutex was given back by an interrupt while the queue was
3592:..\..\..\Source/tasks.c **** 		locked then the mutex holder might now be NULL. */
3593:..\..\..\Source/tasks.c **** 		if( pxMutexHolder != NULL )
 3818              		.loc 1 3593 0
 3819 000c 7B68     		ldr	r3, [r7, #4]
 3820 000e 002B     		cmp	r3, #0
 3821 0010 64D0     		beq	.L256
3594:..\..\..\Source/tasks.c **** 		{
3595:..\..\..\Source/tasks.c **** 			/* If the holder of the mutex has a priority below the priority of
3596:..\..\..\Source/tasks.c **** 			the task attempting to obtain the mutex then it will temporarily
3597:..\..\..\Source/tasks.c **** 			inherit the priority of the task attempting to obtain the mutex. */
3598:..\..\..\Source/tasks.c **** 			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 3822              		.loc 1 3598 0
 3823 0012 FB68     		ldr	r3, [r7, #12]
 3824 0014 DA6A     		ldr	r2, [r3, #44]
 3825 0016 334B     		ldr	r3, .L265
 3826 0018 1B68     		ldr	r3, [r3]
 3827 001a DB6A     		ldr	r3, [r3, #44]
 3828 001c 9A42     		cmp	r2, r3
 3829 001e 5DD2     		bcs	.L256
3599:..\..\..\Source/tasks.c **** 			{
3600:..\..\..\Source/tasks.c **** 				/* Adjust the mutex holder state to account for its new
3601:..\..\..\Source/tasks.c **** 				priority.  Only reset the event list item value if the value is
3602:..\..\..\Source/tasks.c **** 				not	being used for anything else. */
3603:..\..\..\Source/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE 
 3830              		.loc 1 3603 0
 3831 0020 FB68     		ldr	r3, [r7, #12]
 3832 0022 9B69     		ldr	r3, [r3, #24]
 3833 0024 002B     		cmp	r3, #0
 3834 0026 06DB     		blt	.L258
3604:..\..\..\Source/tasks.c **** 				{
3605:..\..\..\Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( T
 3835              		.loc 1 3605 0
 3836 0028 2E4B     		ldr	r3, .L265
 3837 002a 1B68     		ldr	r3, [r3]
 3838 002c DB6A     		ldr	r3, [r3, #44]
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 137


 3839 002e C3F10502 		rsb	r2, r3, #5
 3840 0032 FB68     		ldr	r3, [r7, #12]
 3841 0034 9A61     		str	r2, [r3, #24]
 3842              	.L258:
3606:..\..\..\Source/tasks.c **** 				}
3607:..\..\..\Source/tasks.c **** 				else
3608:..\..\..\Source/tasks.c **** 				{
3609:..\..\..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3610:..\..\..\Source/tasks.c **** 				}
3611:..\..\..\Source/tasks.c **** 
3612:..\..\..\Source/tasks.c **** 				/* If the task being modified is in the ready state it will need
3613:..\..\..\Source/tasks.c **** 				to be moved into a new list. */
3614:..\..\..\Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListI
 3843              		.loc 1 3614 0
 3844 0036 FB68     		ldr	r3, [r7, #12]
 3845 0038 5969     		ldr	r1, [r3, #20]
 3846 003a FB68     		ldr	r3, [r7, #12]
 3847 003c DA6A     		ldr	r2, [r3, #44]
 3848 003e 1346     		mov	r3, r2
 3849 0040 9B00     		lsls	r3, r3, #2
 3850 0042 1344     		add	r3, r3, r2
 3851 0044 9B00     		lsls	r3, r3, #2
 3852 0046 284A     		ldr	r2, .L265+4
 3853 0048 1344     		add	r3, r3, r2
 3854 004a 9942     		cmp	r1, r3
 3855 004c 01D1     		bne	.L259
 3856              		.loc 1 3614 0 is_stmt 0 discriminator 1
 3857 004e 0123     		movs	r3, #1
 3858 0050 00E0     		b	.L260
 3859              	.L259:
 3860              		.loc 1 3614 0 discriminator 2
 3861 0052 0023     		movs	r3, #0
 3862              	.L260:
 3863              		.loc 1 3614 0 discriminator 4
 3864 0054 002B     		cmp	r3, #0
 3865 0056 3CD0     		beq	.L261
3615:..\..\..\Source/tasks.c **** 				{
3616:..\..\..\Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 3866              		.loc 1 3616 0 is_stmt 1
 3867 0058 FB68     		ldr	r3, [r7, #12]
 3868 005a 0433     		adds	r3, r3, #4
 3869 005c 1846     		mov	r0, r3
 3870 005e FFF7FEFF 		bl	uxListRemove
 3871 0062 0346     		mov	r3, r0
 3872 0064 002B     		cmp	r3, #0
 3873 0066 15D1     		bne	.L262
3617:..\..\..\Source/tasks.c **** 					{
3618:..\..\..\Source/tasks.c **** 						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 3874              		.loc 1 3618 0
 3875 0068 FB68     		ldr	r3, [r7, #12]
 3876 006a DA6A     		ldr	r2, [r3, #44]
 3877 006c 1E49     		ldr	r1, .L265+4
 3878 006e 1346     		mov	r3, r2
 3879 0070 9B00     		lsls	r3, r3, #2
 3880 0072 1344     		add	r3, r3, r2
 3881 0074 9B00     		lsls	r3, r3, #2
 3882 0076 0B44     		add	r3, r3, r1
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 138


 3883 0078 1B68     		ldr	r3, [r3]
 3884 007a 002B     		cmp	r3, #0
 3885 007c 0AD1     		bne	.L262
 3886              		.loc 1 3618 0 is_stmt 0 discriminator 1
 3887 007e FB68     		ldr	r3, [r7, #12]
 3888 0080 DB6A     		ldr	r3, [r3, #44]
 3889 0082 1A46     		mov	r2, r3
 3890 0084 0123     		movs	r3, #1
 3891 0086 9340     		lsls	r3, r3, r2
 3892 0088 DA43     		mvns	r2, r3
 3893 008a 184B     		ldr	r3, .L265+8
 3894 008c 1B68     		ldr	r3, [r3]
 3895 008e 1340     		ands	r3, r3, r2
 3896 0090 164A     		ldr	r2, .L265+8
 3897 0092 1360     		str	r3, [r2]
 3898              	.L262:
3619:..\..\..\Source/tasks.c **** 					}
3620:..\..\..\Source/tasks.c **** 					else
3621:..\..\..\Source/tasks.c **** 					{
3622:..\..\..\Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3623:..\..\..\Source/tasks.c **** 					}
3624:..\..\..\Source/tasks.c **** 
3625:..\..\..\Source/tasks.c **** 					/* Inherit the priority before being moved into the new list. */
3626:..\..\..\Source/tasks.c **** 					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 3899              		.loc 1 3626 0 is_stmt 1
 3900 0094 134B     		ldr	r3, .L265
 3901 0096 1B68     		ldr	r3, [r3]
 3902 0098 DA6A     		ldr	r2, [r3, #44]
 3903 009a FB68     		ldr	r3, [r7, #12]
 3904 009c DA62     		str	r2, [r3, #44]
3627:..\..\..\Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 3905              		.loc 1 3627 0
 3906 009e FB68     		ldr	r3, [r7, #12]
 3907 00a0 DB6A     		ldr	r3, [r3, #44]
 3908 00a2 1A46     		mov	r2, r3
 3909 00a4 0123     		movs	r3, #1
 3910 00a6 03FA02F2 		lsl	r2, r3, r2
 3911 00aa 104B     		ldr	r3, .L265+8
 3912 00ac 1B68     		ldr	r3, [r3]
 3913 00ae 1343     		orrs	r3, r3, r2
 3914 00b0 0E4A     		ldr	r2, .L265+8
 3915 00b2 1360     		str	r3, [r2]
 3916 00b4 FB68     		ldr	r3, [r7, #12]
 3917 00b6 DA6A     		ldr	r2, [r3, #44]
 3918 00b8 1346     		mov	r3, r2
 3919 00ba 9B00     		lsls	r3, r3, #2
 3920 00bc 1344     		add	r3, r3, r2
 3921 00be 9B00     		lsls	r3, r3, #2
 3922 00c0 094A     		ldr	r2, .L265+4
 3923 00c2 1A44     		add	r2, r2, r3
 3924 00c4 FB68     		ldr	r3, [r7, #12]
 3925 00c6 0433     		adds	r3, r3, #4
 3926 00c8 1046     		mov	r0, r2
 3927 00ca 1946     		mov	r1, r3
 3928 00cc FFF7FEFF 		bl	vListInsertEnd
 3929 00d0 04E0     		b	.L256
 3930              	.L261:
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 139


3628:..\..\..\Source/tasks.c **** 				}
3629:..\..\..\Source/tasks.c **** 				else
3630:..\..\..\Source/tasks.c **** 				{
3631:..\..\..\Source/tasks.c **** 					/* Just inherit the priority. */
3632:..\..\..\Source/tasks.c **** 					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 3931              		.loc 1 3632 0
 3932 00d2 044B     		ldr	r3, .L265
 3933 00d4 1B68     		ldr	r3, [r3]
 3934 00d6 DA6A     		ldr	r2, [r3, #44]
 3935 00d8 FB68     		ldr	r3, [r7, #12]
 3936 00da DA62     		str	r2, [r3, #44]
 3937              	.L256:
3633:..\..\..\Source/tasks.c **** 				}
3634:..\..\..\Source/tasks.c **** 
3635:..\..\..\Source/tasks.c **** 				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
3636:..\..\..\Source/tasks.c **** 			}
3637:..\..\..\Source/tasks.c **** 			else
3638:..\..\..\Source/tasks.c **** 			{
3639:..\..\..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3640:..\..\..\Source/tasks.c **** 			}
3641:..\..\..\Source/tasks.c **** 		}
3642:..\..\..\Source/tasks.c **** 		else
3643:..\..\..\Source/tasks.c **** 		{
3644:..\..\..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3645:..\..\..\Source/tasks.c **** 		}
3646:..\..\..\Source/tasks.c **** 	}
 3938              		.loc 1 3646 0
 3939 00dc 1037     		adds	r7, r7, #16
 3940              		.cfi_def_cfa_offset 8
 3941 00de BD46     		mov	sp, r7
 3942              		.cfi_def_cfa_register 13
 3943              		@ sp needed
 3944 00e0 80BD     		pop	{r7, pc}
 3945              	.L266:
 3946 00e2 00BF     		.align	2
 3947              	.L265:
 3948 00e4 00000000 		.word	pxCurrentTCB
 3949 00e8 04000000 		.word	pxReadyTasksLists
 3950 00ec E0000000 		.word	uxTopReadyPriority
 3951              		.cfi_endproc
 3952              	.LFE107:
 3953              		.size	vTaskPriorityInherit, .-vTaskPriorityInherit
 3954              		.section	.text.xTaskPriorityDisinherit,"ax",%progbits
 3955              		.align	2
 3956              		.global	xTaskPriorityDisinherit
 3957              		.thumb
 3958              		.thumb_func
 3959              		.type	xTaskPriorityDisinherit, %function
 3960              	xTaskPriorityDisinherit:
 3961              	.LFB108:
3647:..\..\..\Source/tasks.c **** 
3648:..\..\..\Source/tasks.c **** #endif /* configUSE_MUTEXES */
3649:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
3650:..\..\..\Source/tasks.c **** 
3651:..\..\..\Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3652:..\..\..\Source/tasks.c **** 
3653:..\..\..\Source/tasks.c **** 	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 140


3654:..\..\..\Source/tasks.c **** 	{
 3962              		.loc 1 3654 0
 3963              		.cfi_startproc
 3964              		@ args = 0, pretend = 0, frame = 16
 3965              		@ frame_needed = 1, uses_anonymous_args = 0
 3966 0000 80B5     		push	{r7, lr}
 3967              		.cfi_def_cfa_offset 8
 3968              		.cfi_offset 7, -8
 3969              		.cfi_offset 14, -4
 3970 0002 84B0     		sub	sp, sp, #16
 3971              		.cfi_def_cfa_offset 24
 3972 0004 00AF     		add	r7, sp, #0
 3973              		.cfi_def_cfa_register 7
 3974 0006 7860     		str	r0, [r7, #4]
3655:..\..\..\Source/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
 3975              		.loc 1 3655 0
 3976 0008 7B68     		ldr	r3, [r7, #4]
 3977 000a BB60     		str	r3, [r7, #8]
3656:..\..\..\Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
 3978              		.loc 1 3656 0
 3979 000c 0023     		movs	r3, #0
 3980 000e FB60     		str	r3, [r7, #12]
3657:..\..\..\Source/tasks.c **** 
3658:..\..\..\Source/tasks.c **** 		if( pxMutexHolder != NULL )
 3981              		.loc 1 3658 0
 3982 0010 7B68     		ldr	r3, [r7, #4]
 3983 0012 002B     		cmp	r3, #0
 3984 0014 51D0     		beq	.L268
3659:..\..\..\Source/tasks.c **** 		{
3660:..\..\..\Source/tasks.c **** 			/* A task can only have an inherited priority if it holds the mutex.
3661:..\..\..\Source/tasks.c **** 			If the mutex is held by a task then it cannot be given from an
3662:..\..\..\Source/tasks.c **** 			interrupt, and if a mutex is given by the holding task then it must
3663:..\..\..\Source/tasks.c **** 			be the running state task. */
3664:..\..\..\Source/tasks.c **** 			configASSERT( pxTCB == pxCurrentTCB );
3665:..\..\..\Source/tasks.c **** 
3666:..\..\..\Source/tasks.c **** 			configASSERT( pxTCB->uxMutexesHeld );
3667:..\..\..\Source/tasks.c **** 			( pxTCB->uxMutexesHeld )--;
 3985              		.loc 1 3667 0
 3986 0016 BB68     		ldr	r3, [r7, #8]
 3987 0018 5B6C     		ldr	r3, [r3, #68]
 3988 001a 5A1E     		subs	r2, r3, #1
 3989 001c BB68     		ldr	r3, [r7, #8]
 3990 001e 5A64     		str	r2, [r3, #68]
3668:..\..\..\Source/tasks.c **** 
3669:..\..\..\Source/tasks.c **** 			/* Has the holder of the mutex inherited the priority of another
3670:..\..\..\Source/tasks.c **** 			task? */
3671:..\..\..\Source/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 3991              		.loc 1 3671 0
 3992 0020 BB68     		ldr	r3, [r7, #8]
 3993 0022 DA6A     		ldr	r2, [r3, #44]
 3994 0024 BB68     		ldr	r3, [r7, #8]
 3995 0026 1B6C     		ldr	r3, [r3, #64]
 3996 0028 9A42     		cmp	r2, r3
 3997 002a 46D0     		beq	.L268
3672:..\..\..\Source/tasks.c **** 			{
3673:..\..\..\Source/tasks.c **** 				/* Only disinherit if no other mutexes are held. */
3674:..\..\..\Source/tasks.c **** 				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 141


 3998              		.loc 1 3674 0
 3999 002c BB68     		ldr	r3, [r7, #8]
 4000 002e 5B6C     		ldr	r3, [r3, #68]
 4001 0030 002B     		cmp	r3, #0
 4002 0032 42D1     		bne	.L268
3675:..\..\..\Source/tasks.c **** 				{
3676:..\..\..\Source/tasks.c **** 					/* A task can only have an inherited priority if it holds
3677:..\..\..\Source/tasks.c **** 					the mutex.  If the mutex is held by a task then it cannot be
3678:..\..\..\Source/tasks.c **** 					given from an interrupt, and if a mutex is given by the
3679:..\..\..\Source/tasks.c **** 					holding	task then it must be the running state task.  Remove
3680:..\..\..\Source/tasks.c **** 					the	holding task from the ready	list. */
3681:..\..\..\Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4003              		.loc 1 3681 0
 4004 0034 BB68     		ldr	r3, [r7, #8]
 4005 0036 0433     		adds	r3, r3, #4
 4006 0038 1846     		mov	r0, r3
 4007 003a FFF7FEFF 		bl	uxListRemove
 4008 003e 0346     		mov	r3, r0
 4009 0040 002B     		cmp	r3, #0
 4010 0042 15D1     		bne	.L269
3682:..\..\..\Source/tasks.c **** 					{
3683:..\..\..\Source/tasks.c **** 						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 4011              		.loc 1 3683 0
 4012 0044 BB68     		ldr	r3, [r7, #8]
 4013 0046 DA6A     		ldr	r2, [r3, #44]
 4014 0048 1E49     		ldr	r1, .L272
 4015 004a 1346     		mov	r3, r2
 4016 004c 9B00     		lsls	r3, r3, #2
 4017 004e 1344     		add	r3, r3, r2
 4018 0050 9B00     		lsls	r3, r3, #2
 4019 0052 0B44     		add	r3, r3, r1
 4020 0054 1B68     		ldr	r3, [r3]
 4021 0056 002B     		cmp	r3, #0
 4022 0058 0AD1     		bne	.L269
 4023              		.loc 1 3683 0 is_stmt 0 discriminator 1
 4024 005a BB68     		ldr	r3, [r7, #8]
 4025 005c DB6A     		ldr	r3, [r3, #44]
 4026 005e 1A46     		mov	r2, r3
 4027 0060 0123     		movs	r3, #1
 4028 0062 9340     		lsls	r3, r3, r2
 4029 0064 DA43     		mvns	r2, r3
 4030 0066 184B     		ldr	r3, .L272+4
 4031 0068 1B68     		ldr	r3, [r3]
 4032 006a 1340     		ands	r3, r3, r2
 4033 006c 164A     		ldr	r2, .L272+4
 4034 006e 1360     		str	r3, [r2]
 4035              	.L269:
3684:..\..\..\Source/tasks.c **** 					}
3685:..\..\..\Source/tasks.c **** 					else
3686:..\..\..\Source/tasks.c **** 					{
3687:..\..\..\Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3688:..\..\..\Source/tasks.c **** 					}
3689:..\..\..\Source/tasks.c **** 
3690:..\..\..\Source/tasks.c **** 					/* Disinherit the priority before adding the task into the
3691:..\..\..\Source/tasks.c **** 					new	ready list. */
3692:..\..\..\Source/tasks.c **** 					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
3693:..\..\..\Source/tasks.c **** 					pxTCB->uxPriority = pxTCB->uxBasePriority;
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 142


 4036              		.loc 1 3693 0 is_stmt 1
 4037 0070 BB68     		ldr	r3, [r7, #8]
 4038 0072 1A6C     		ldr	r2, [r3, #64]
 4039 0074 BB68     		ldr	r3, [r7, #8]
 4040 0076 DA62     		str	r2, [r3, #44]
3694:..\..\..\Source/tasks.c **** 
3695:..\..\..\Source/tasks.c **** 					/* Reset the event list item value.  It cannot be in use for
3696:..\..\..\Source/tasks.c **** 					any other purpose if this task is running, and it must be
3697:..\..\..\Source/tasks.c **** 					running to give back the mutex. */
3698:..\..\..\Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( T
 4041              		.loc 1 3698 0
 4042 0078 BB68     		ldr	r3, [r7, #8]
 4043 007a DB6A     		ldr	r3, [r3, #44]
 4044 007c C3F10502 		rsb	r2, r3, #5
 4045 0080 BB68     		ldr	r3, [r7, #8]
 4046 0082 9A61     		str	r2, [r3, #24]
3699:..\..\..\Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 4047              		.loc 1 3699 0
 4048 0084 BB68     		ldr	r3, [r7, #8]
 4049 0086 DB6A     		ldr	r3, [r3, #44]
 4050 0088 1A46     		mov	r2, r3
 4051 008a 0123     		movs	r3, #1
 4052 008c 03FA02F2 		lsl	r2, r3, r2
 4053 0090 0D4B     		ldr	r3, .L272+4
 4054 0092 1B68     		ldr	r3, [r3]
 4055 0094 1343     		orrs	r3, r3, r2
 4056 0096 0C4A     		ldr	r2, .L272+4
 4057 0098 1360     		str	r3, [r2]
 4058 009a BB68     		ldr	r3, [r7, #8]
 4059 009c DA6A     		ldr	r2, [r3, #44]
 4060 009e 1346     		mov	r3, r2
 4061 00a0 9B00     		lsls	r3, r3, #2
 4062 00a2 1344     		add	r3, r3, r2
 4063 00a4 9B00     		lsls	r3, r3, #2
 4064 00a6 074A     		ldr	r2, .L272
 4065 00a8 1A44     		add	r2, r2, r3
 4066 00aa BB68     		ldr	r3, [r7, #8]
 4067 00ac 0433     		adds	r3, r3, #4
 4068 00ae 1046     		mov	r0, r2
 4069 00b0 1946     		mov	r1, r3
 4070 00b2 FFF7FEFF 		bl	vListInsertEnd
3700:..\..\..\Source/tasks.c **** 
3701:..\..\..\Source/tasks.c **** 					/* Return true to indicate that a context switch is required.
3702:..\..\..\Source/tasks.c **** 					This is only actually required in the corner case whereby
3703:..\..\..\Source/tasks.c **** 					multiple mutexes were held and the mutexes were given back
3704:..\..\..\Source/tasks.c **** 					in an order different to that in which they were taken.
3705:..\..\..\Source/tasks.c **** 					If a context switch did not occur when the first mutex was
3706:..\..\..\Source/tasks.c **** 					returned, even if a task was waiting on it, then a context
3707:..\..\..\Source/tasks.c **** 					switch should occur when the last mutex is returned whether
3708:..\..\..\Source/tasks.c **** 					a task is waiting on it or not. */
3709:..\..\..\Source/tasks.c **** 					xReturn = pdTRUE;
 4071              		.loc 1 3709 0
 4072 00b6 0123     		movs	r3, #1
 4073 00b8 FB60     		str	r3, [r7, #12]
 4074              	.L268:
3710:..\..\..\Source/tasks.c **** 				}
3711:..\..\..\Source/tasks.c **** 				else
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 143


3712:..\..\..\Source/tasks.c **** 				{
3713:..\..\..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3714:..\..\..\Source/tasks.c **** 				}
3715:..\..\..\Source/tasks.c **** 			}
3716:..\..\..\Source/tasks.c **** 			else
3717:..\..\..\Source/tasks.c **** 			{
3718:..\..\..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3719:..\..\..\Source/tasks.c **** 			}
3720:..\..\..\Source/tasks.c **** 		}
3721:..\..\..\Source/tasks.c **** 		else
3722:..\..\..\Source/tasks.c **** 		{
3723:..\..\..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3724:..\..\..\Source/tasks.c **** 		}
3725:..\..\..\Source/tasks.c **** 
3726:..\..\..\Source/tasks.c **** 		return xReturn;
 4075              		.loc 1 3726 0
 4076 00ba FB68     		ldr	r3, [r7, #12]
3727:..\..\..\Source/tasks.c **** 	}
 4077              		.loc 1 3727 0
 4078 00bc 1846     		mov	r0, r3
 4079 00be 1037     		adds	r7, r7, #16
 4080              		.cfi_def_cfa_offset 8
 4081 00c0 BD46     		mov	sp, r7
 4082              		.cfi_def_cfa_register 13
 4083              		@ sp needed
 4084 00c2 80BD     		pop	{r7, pc}
 4085              	.L273:
 4086              		.align	2
 4087              	.L272:
 4088 00c4 04000000 		.word	pxReadyTasksLists
 4089 00c8 E0000000 		.word	uxTopReadyPriority
 4090              		.cfi_endproc
 4091              	.LFE108:
 4092              		.size	xTaskPriorityDisinherit, .-xTaskPriorityDisinherit
 4093              		.section	.text.uxTaskResetEventItemValue,"ax",%progbits
 4094              		.align	2
 4095              		.global	uxTaskResetEventItemValue
 4096              		.thumb
 4097              		.thumb_func
 4098              		.type	uxTaskResetEventItemValue, %function
 4099              	uxTaskResetEventItemValue:
 4100              	.LFB109:
3728:..\..\..\Source/tasks.c **** 
3729:..\..\..\Source/tasks.c **** #endif /* configUSE_MUTEXES */
3730:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
3731:..\..\..\Source/tasks.c **** 
3732:..\..\..\Source/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
3733:..\..\..\Source/tasks.c **** 
3734:..\..\..\Source/tasks.c **** 	void vTaskEnterCritical( void )
3735:..\..\..\Source/tasks.c **** 	{
3736:..\..\..\Source/tasks.c **** 		portDISABLE_INTERRUPTS();
3737:..\..\..\Source/tasks.c **** 
3738:..\..\..\Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
3739:..\..\..\Source/tasks.c **** 		{
3740:..\..\..\Source/tasks.c **** 			( pxCurrentTCB->uxCriticalNesting )++;
3741:..\..\..\Source/tasks.c **** 
3742:..\..\..\Source/tasks.c **** 			/* This is not the interrupt safe version of the enter critical
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 144


3743:..\..\..\Source/tasks.c **** 			function so	assert() if it is being called from an interrupt
3744:..\..\..\Source/tasks.c **** 			context.  Only API functions that end in "FromISR" can be used in an
3745:..\..\..\Source/tasks.c **** 			interrupt.  Only assert if the critical nesting count is 1 to
3746:..\..\..\Source/tasks.c **** 			protect against recursive calls if the assert function also uses a
3747:..\..\..\Source/tasks.c **** 			critical section. */
3748:..\..\..\Source/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting == 1 )
3749:..\..\..\Source/tasks.c **** 			{
3750:..\..\..\Source/tasks.c **** 				portASSERT_IF_IN_ISR();
3751:..\..\..\Source/tasks.c **** 			}
3752:..\..\..\Source/tasks.c **** 		}
3753:..\..\..\Source/tasks.c **** 		else
3754:..\..\..\Source/tasks.c **** 		{
3755:..\..\..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3756:..\..\..\Source/tasks.c **** 		}
3757:..\..\..\Source/tasks.c **** 	}
3758:..\..\..\Source/tasks.c **** 
3759:..\..\..\Source/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
3760:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
3761:..\..\..\Source/tasks.c **** 
3762:..\..\..\Source/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
3763:..\..\..\Source/tasks.c **** 
3764:..\..\..\Source/tasks.c **** 	void vTaskExitCritical( void )
3765:..\..\..\Source/tasks.c **** 	{
3766:..\..\..\Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
3767:..\..\..\Source/tasks.c **** 		{
3768:..\..\..\Source/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting > 0U )
3769:..\..\..\Source/tasks.c **** 			{
3770:..\..\..\Source/tasks.c **** 				( pxCurrentTCB->uxCriticalNesting )--;
3771:..\..\..\Source/tasks.c **** 
3772:..\..\..\Source/tasks.c **** 				if( pxCurrentTCB->uxCriticalNesting == 0U )
3773:..\..\..\Source/tasks.c **** 				{
3774:..\..\..\Source/tasks.c **** 					portENABLE_INTERRUPTS();
3775:..\..\..\Source/tasks.c **** 				}
3776:..\..\..\Source/tasks.c **** 				else
3777:..\..\..\Source/tasks.c **** 				{
3778:..\..\..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3779:..\..\..\Source/tasks.c **** 				}
3780:..\..\..\Source/tasks.c **** 			}
3781:..\..\..\Source/tasks.c **** 			else
3782:..\..\..\Source/tasks.c **** 			{
3783:..\..\..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3784:..\..\..\Source/tasks.c **** 			}
3785:..\..\..\Source/tasks.c **** 		}
3786:..\..\..\Source/tasks.c **** 		else
3787:..\..\..\Source/tasks.c **** 		{
3788:..\..\..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3789:..\..\..\Source/tasks.c **** 		}
3790:..\..\..\Source/tasks.c **** 	}
3791:..\..\..\Source/tasks.c **** 
3792:..\..\..\Source/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
3793:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
3794:..\..\..\Source/tasks.c **** 
3795:..\..\..\Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
3796:..\..\..\Source/tasks.c **** 
3797:..\..\..\Source/tasks.c **** 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
3798:..\..\..\Source/tasks.c **** 	{
3799:..\..\..\Source/tasks.c **** 	size_t x;
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 145


3800:..\..\..\Source/tasks.c **** 
3801:..\..\..\Source/tasks.c **** 		/* Start by copying the entire string. */
3802:..\..\..\Source/tasks.c **** 		strcpy( pcBuffer, pcTaskName );
3803:..\..\..\Source/tasks.c **** 
3804:..\..\..\Source/tasks.c **** 		/* Pad the end of the string with spaces to ensure columns line up when
3805:..\..\..\Source/tasks.c **** 		printed out. */
3806:..\..\..\Source/tasks.c **** 		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
3807:..\..\..\Source/tasks.c **** 		{
3808:..\..\..\Source/tasks.c **** 			pcBuffer[ x ] = ' ';
3809:..\..\..\Source/tasks.c **** 		}
3810:..\..\..\Source/tasks.c **** 
3811:..\..\..\Source/tasks.c **** 		/* Terminate. */
3812:..\..\..\Source/tasks.c **** 		pcBuffer[ x ] = 0x00;
3813:..\..\..\Source/tasks.c **** 
3814:..\..\..\Source/tasks.c **** 		/* Return the new end of string. */
3815:..\..\..\Source/tasks.c **** 		return &( pcBuffer[ x ] );
3816:..\..\..\Source/tasks.c **** 	}
3817:..\..\..\Source/tasks.c **** 
3818:..\..\..\Source/tasks.c **** #endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
3819:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
3820:..\..\..\Source/tasks.c **** 
3821:..\..\..\Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
3822:..\..\..\Source/tasks.c **** 
3823:..\..\..\Source/tasks.c **** 	void vTaskList( char * pcWriteBuffer )
3824:..\..\..\Source/tasks.c **** 	{
3825:..\..\..\Source/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
3826:..\..\..\Source/tasks.c **** 	volatile UBaseType_t uxArraySize, x;
3827:..\..\..\Source/tasks.c **** 	char cStatus;
3828:..\..\..\Source/tasks.c **** 
3829:..\..\..\Source/tasks.c **** 		/*
3830:..\..\..\Source/tasks.c **** 		 * PLEASE NOTE:
3831:..\..\..\Source/tasks.c **** 		 *
3832:..\..\..\Source/tasks.c **** 		 * This function is provided for convenience only, and is used by many
3833:..\..\..\Source/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
3834:..\..\..\Source/tasks.c **** 		 * scheduler.
3835:..\..\..\Source/tasks.c **** 		 *
3836:..\..\..\Source/tasks.c **** 		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
3837:..\..\..\Source/tasks.c **** 		 * uxTaskGetSystemState() output into a human readable table that
3838:..\..\..\Source/tasks.c **** 		 * displays task names, states and stack usage.
3839:..\..\..\Source/tasks.c **** 		 *
3840:..\..\..\Source/tasks.c **** 		 * vTaskList() has a dependency on the sprintf() C library function that
3841:..\..\..\Source/tasks.c **** 		 * might bloat the code size, use a lot of stack, and provide different
3842:..\..\..\Source/tasks.c **** 		 * results on different platforms.  An alternative, tiny, third party,
3843:..\..\..\Source/tasks.c **** 		 * and limited functionality implementation of sprintf() is provided in
3844:..\..\..\Source/tasks.c **** 		 * many of the FreeRTOS/Demo sub-directories in a file called
3845:..\..\..\Source/tasks.c **** 		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
3846:..\..\..\Source/tasks.c **** 		 * snprintf() implementation!).
3847:..\..\..\Source/tasks.c **** 		 *
3848:..\..\..\Source/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
3849:..\..\..\Source/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
3850:..\..\..\Source/tasks.c **** 		 * through a call to vTaskList().
3851:..\..\..\Source/tasks.c **** 		 */
3852:..\..\..\Source/tasks.c **** 
3853:..\..\..\Source/tasks.c **** 
3854:..\..\..\Source/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
3855:..\..\..\Source/tasks.c **** 		*pcWriteBuffer = 0x00;
3856:..\..\..\Source/tasks.c **** 
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 146


3857:..\..\..\Source/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
3858:..\..\..\Source/tasks.c **** 		function is executing. */
3859:..\..\..\Source/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
3860:..\..\..\Source/tasks.c **** 
3861:..\..\..\Source/tasks.c **** 		/* Allocate an array index for each task.  NOTE!  if
3862:..\..\..\Source/tasks.c **** 		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
3863:..\..\..\Source/tasks.c **** 		equate to NULL. */
3864:..\..\..\Source/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
3865:..\..\..\Source/tasks.c **** 
3866:..\..\..\Source/tasks.c **** 		if( pxTaskStatusArray != NULL )
3867:..\..\..\Source/tasks.c **** 		{
3868:..\..\..\Source/tasks.c **** 			/* Generate the (binary) data. */
3869:..\..\..\Source/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
3870:..\..\..\Source/tasks.c **** 
3871:..\..\..\Source/tasks.c **** 			/* Create a human readable table from the binary data. */
3872:..\..\..\Source/tasks.c **** 			for( x = 0; x < uxArraySize; x++ )
3873:..\..\..\Source/tasks.c **** 			{
3874:..\..\..\Source/tasks.c **** 				switch( pxTaskStatusArray[ x ].eCurrentState )
3875:..\..\..\Source/tasks.c **** 				{
3876:..\..\..\Source/tasks.c **** 					case eReady:		cStatus = tskREADY_CHAR;
3877:..\..\..\Source/tasks.c **** 										break;
3878:..\..\..\Source/tasks.c **** 
3879:..\..\..\Source/tasks.c **** 					case eBlocked:		cStatus = tskBLOCKED_CHAR;
3880:..\..\..\Source/tasks.c **** 										break;
3881:..\..\..\Source/tasks.c **** 
3882:..\..\..\Source/tasks.c **** 					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
3883:..\..\..\Source/tasks.c **** 										break;
3884:..\..\..\Source/tasks.c **** 
3885:..\..\..\Source/tasks.c **** 					case eDeleted:		cStatus = tskDELETED_CHAR;
3886:..\..\..\Source/tasks.c **** 										break;
3887:..\..\..\Source/tasks.c **** 
3888:..\..\..\Source/tasks.c **** 					default:			/* Should not get here, but it is included
3889:..\..\..\Source/tasks.c **** 										to prevent static checking errors. */
3890:..\..\..\Source/tasks.c **** 										cStatus = 0x00;
3891:..\..\..\Source/tasks.c **** 										break;
3892:..\..\..\Source/tasks.c **** 				}
3893:..\..\..\Source/tasks.c **** 
3894:..\..\..\Source/tasks.c **** 				/* Write the task name to the string, padding with spaces so it
3895:..\..\..\Source/tasks.c **** 				can be printed in tabular form more easily. */
3896:..\..\..\Source/tasks.c **** 				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
3897:..\..\..\Source/tasks.c **** 
3898:..\..\..\Source/tasks.c **** 				/* Write the rest of the string. */
3899:..\..\..\Source/tasks.c **** 				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x 
3900:..\..\..\Source/tasks.c **** 				pcWriteBuffer += strlen( pcWriteBuffer );
3901:..\..\..\Source/tasks.c **** 			}
3902:..\..\..\Source/tasks.c **** 
3903:..\..\..\Source/tasks.c **** 			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
3904:..\..\..\Source/tasks.c **** 			is 0 then vPortFree() will be #defined to nothing. */
3905:..\..\..\Source/tasks.c **** 			vPortFree( pxTaskStatusArray );
3906:..\..\..\Source/tasks.c **** 		}
3907:..\..\..\Source/tasks.c **** 		else
3908:..\..\..\Source/tasks.c **** 		{
3909:..\..\..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3910:..\..\..\Source/tasks.c **** 		}
3911:..\..\..\Source/tasks.c **** 	}
3912:..\..\..\Source/tasks.c **** 
3913:..\..\..\Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 147


3914:..\..\..\Source/tasks.c **** /*----------------------------------------------------------*/
3915:..\..\..\Source/tasks.c **** 
3916:..\..\..\Source/tasks.c **** #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
3917:..\..\..\Source/tasks.c **** 
3918:..\..\..\Source/tasks.c **** 	void vTaskGetRunTimeStats( char *pcWriteBuffer )
3919:..\..\..\Source/tasks.c **** 	{
3920:..\..\..\Source/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
3921:..\..\..\Source/tasks.c **** 	volatile UBaseType_t uxArraySize, x;
3922:..\..\..\Source/tasks.c **** 	uint32_t ulTotalTime, ulStatsAsPercentage;
3923:..\..\..\Source/tasks.c **** 
3924:..\..\..\Source/tasks.c **** 		#if( configUSE_TRACE_FACILITY != 1 )
3925:..\..\..\Source/tasks.c **** 		{
3926:..\..\..\Source/tasks.c **** 			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTime
3927:..\..\..\Source/tasks.c **** 		}
3928:..\..\..\Source/tasks.c **** 		#endif
3929:..\..\..\Source/tasks.c **** 
3930:..\..\..\Source/tasks.c **** 		/*
3931:..\..\..\Source/tasks.c **** 		 * PLEASE NOTE:
3932:..\..\..\Source/tasks.c **** 		 *
3933:..\..\..\Source/tasks.c **** 		 * This function is provided for convenience only, and is used by many
3934:..\..\..\Source/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
3935:..\..\..\Source/tasks.c **** 		 * scheduler.
3936:..\..\..\Source/tasks.c **** 		 *
3937:..\..\..\Source/tasks.c **** 		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
3938:..\..\..\Source/tasks.c **** 		 * of the uxTaskGetSystemState() output into a human readable table that
3939:..\..\..\Source/tasks.c **** 		 * displays the amount of time each task has spent in the Running state
3940:..\..\..\Source/tasks.c **** 		 * in both absolute and percentage terms.
3941:..\..\..\Source/tasks.c **** 		 *
3942:..\..\..\Source/tasks.c **** 		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
3943:..\..\..\Source/tasks.c **** 		 * function that might bloat the code size, use a lot of stack, and
3944:..\..\..\Source/tasks.c **** 		 * provide different results on different platforms.  An alternative,
3945:..\..\..\Source/tasks.c **** 		 * tiny, third party, and limited functionality implementation of
3946:..\..\..\Source/tasks.c **** 		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
3947:..\..\..\Source/tasks.c **** 		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
3948:..\..\..\Source/tasks.c **** 		 * a full snprintf() implementation!).
3949:..\..\..\Source/tasks.c **** 		 *
3950:..\..\..\Source/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
3951:..\..\..\Source/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
3952:..\..\..\Source/tasks.c **** 		 * through a call to vTaskGetRunTimeStats().
3953:..\..\..\Source/tasks.c **** 		 */
3954:..\..\..\Source/tasks.c **** 
3955:..\..\..\Source/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
3956:..\..\..\Source/tasks.c **** 		*pcWriteBuffer = 0x00;
3957:..\..\..\Source/tasks.c **** 
3958:..\..\..\Source/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
3959:..\..\..\Source/tasks.c **** 		function is executing. */
3960:..\..\..\Source/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
3961:..\..\..\Source/tasks.c **** 
3962:..\..\..\Source/tasks.c **** 		/* Allocate an array index for each task.  NOTE!  If
3963:..\..\..\Source/tasks.c **** 		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
3964:..\..\..\Source/tasks.c **** 		equate to NULL. */
3965:..\..\..\Source/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
3966:..\..\..\Source/tasks.c **** 
3967:..\..\..\Source/tasks.c **** 		if( pxTaskStatusArray != NULL )
3968:..\..\..\Source/tasks.c **** 		{
3969:..\..\..\Source/tasks.c **** 			/* Generate the (binary) data. */
3970:..\..\..\Source/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 148


3971:..\..\..\Source/tasks.c **** 
3972:..\..\..\Source/tasks.c **** 			/* For percentage calculations. */
3973:..\..\..\Source/tasks.c **** 			ulTotalTime /= 100UL;
3974:..\..\..\Source/tasks.c **** 
3975:..\..\..\Source/tasks.c **** 			/* Avoid divide by zero errors. */
3976:..\..\..\Source/tasks.c **** 			if( ulTotalTime > 0 )
3977:..\..\..\Source/tasks.c **** 			{
3978:..\..\..\Source/tasks.c **** 				/* Create a human readable table from the binary data. */
3979:..\..\..\Source/tasks.c **** 				for( x = 0; x < uxArraySize; x++ )
3980:..\..\..\Source/tasks.c **** 				{
3981:..\..\..\Source/tasks.c **** 					/* What percentage of the total run time has the task used?
3982:..\..\..\Source/tasks.c **** 					This will always be rounded down to the nearest integer.
3983:..\..\..\Source/tasks.c **** 					ulTotalRunTimeDiv100 has already been divided by 100. */
3984:..\..\..\Source/tasks.c **** 					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
3985:..\..\..\Source/tasks.c **** 
3986:..\..\..\Source/tasks.c **** 					/* Write the task name to the string, padding with
3987:..\..\..\Source/tasks.c **** 					spaces so it can be printed in tabular form more
3988:..\..\..\Source/tasks.c **** 					easily. */
3989:..\..\..\Source/tasks.c **** 					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
3990:..\..\..\Source/tasks.c **** 
3991:..\..\..\Source/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
3992:..\..\..\Source/tasks.c **** 					{
3993:..\..\..\Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
3994:..\..\..\Source/tasks.c **** 						{
3995:..\..\..\Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulSta
3996:..\..\..\Source/tasks.c **** 						}
3997:..\..\..\Source/tasks.c **** 						#else
3998:..\..\..\Source/tasks.c **** 						{
3999:..\..\..\Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
4000:..\..\..\Source/tasks.c **** 							printf() library can be used. */
4001:..\..\..\Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTim
4002:..\..\..\Source/tasks.c **** 						}
4003:..\..\..\Source/tasks.c **** 						#endif
4004:..\..\..\Source/tasks.c **** 					}
4005:..\..\..\Source/tasks.c **** 					else
4006:..\..\..\Source/tasks.c **** 					{
4007:..\..\..\Source/tasks.c **** 						/* If the percentage is zero here then the task has
4008:..\..\..\Source/tasks.c **** 						consumed less than 1% of the total run time. */
4009:..\..\..\Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4010:..\..\..\Source/tasks.c **** 						{
4011:..\..\..\Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
4012:..\..\..\Source/tasks.c **** 						}
4013:..\..\..\Source/tasks.c **** 						#else
4014:..\..\..\Source/tasks.c **** 						{
4015:..\..\..\Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
4016:..\..\..\Source/tasks.c **** 							printf() library can be used. */
4017:..\..\..\Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTim
4018:..\..\..\Source/tasks.c **** 						}
4019:..\..\..\Source/tasks.c **** 						#endif
4020:..\..\..\Source/tasks.c **** 					}
4021:..\..\..\Source/tasks.c **** 
4022:..\..\..\Source/tasks.c **** 					pcWriteBuffer += strlen( pcWriteBuffer );
4023:..\..\..\Source/tasks.c **** 				}
4024:..\..\..\Source/tasks.c **** 			}
4025:..\..\..\Source/tasks.c **** 			else
4026:..\..\..\Source/tasks.c **** 			{
4027:..\..\..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 149


4028:..\..\..\Source/tasks.c **** 			}
4029:..\..\..\Source/tasks.c **** 
4030:..\..\..\Source/tasks.c **** 			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4031:..\..\..\Source/tasks.c **** 			is 0 then vPortFree() will be #defined to nothing. */
4032:..\..\..\Source/tasks.c **** 			vPortFree( pxTaskStatusArray );
4033:..\..\..\Source/tasks.c **** 		}
4034:..\..\..\Source/tasks.c **** 		else
4035:..\..\..\Source/tasks.c **** 		{
4036:..\..\..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4037:..\..\..\Source/tasks.c **** 		}
4038:..\..\..\Source/tasks.c **** 	}
4039:..\..\..\Source/tasks.c **** 
4040:..\..\..\Source/tasks.c **** #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) 
4041:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
4042:..\..\..\Source/tasks.c **** 
4043:..\..\..\Source/tasks.c **** TickType_t uxTaskResetEventItemValue( void )
4044:..\..\..\Source/tasks.c **** {
 4101              		.loc 1 4044 0
 4102              		.cfi_startproc
 4103              		@ args = 0, pretend = 0, frame = 8
 4104              		@ frame_needed = 1, uses_anonymous_args = 0
 4105              		@ link register save eliminated.
 4106 0000 80B4     		push	{r7}
 4107              		.cfi_def_cfa_offset 4
 4108              		.cfi_offset 7, -4
 4109 0002 83B0     		sub	sp, sp, #12
 4110              		.cfi_def_cfa_offset 16
 4111 0004 00AF     		add	r7, sp, #0
 4112              		.cfi_def_cfa_register 7
4045:..\..\..\Source/tasks.c **** TickType_t uxReturn;
4046:..\..\..\Source/tasks.c **** 
4047:..\..\..\Source/tasks.c **** 	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 4113              		.loc 1 4047 0
 4114 0006 094B     		ldr	r3, .L276
 4115 0008 1B68     		ldr	r3, [r3]
 4116 000a 9B69     		ldr	r3, [r3, #24]
 4117 000c 7B60     		str	r3, [r7, #4]
4048:..\..\..\Source/tasks.c **** 
4049:..\..\..\Source/tasks.c **** 	/* Reset the event list item to its normal value - so it can be used with
4050:..\..\..\Source/tasks.c **** 	queues and semaphores. */
4051:..\..\..\Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES 
 4118              		.loc 1 4051 0
 4119 000e 074B     		ldr	r3, .L276
 4120 0010 1B68     		ldr	r3, [r3]
 4121 0012 064A     		ldr	r2, .L276
 4122 0014 1268     		ldr	r2, [r2]
 4123 0016 D26A     		ldr	r2, [r2, #44]
 4124 0018 C2F10502 		rsb	r2, r2, #5
 4125 001c 9A61     		str	r2, [r3, #24]
4052:..\..\..\Source/tasks.c **** 
4053:..\..\..\Source/tasks.c **** 	return uxReturn;
 4126              		.loc 1 4053 0
 4127 001e 7B68     		ldr	r3, [r7, #4]
4054:..\..\..\Source/tasks.c **** }
 4128              		.loc 1 4054 0
 4129 0020 1846     		mov	r0, r3
 4130 0022 0C37     		adds	r7, r7, #12
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 150


 4131              		.cfi_def_cfa_offset 4
 4132 0024 BD46     		mov	sp, r7
 4133              		.cfi_def_cfa_register 13
 4134              		@ sp needed
 4135 0026 5DF8047B 		ldr	r7, [sp], #4
 4136              		.cfi_restore 7
 4137              		.cfi_def_cfa_offset 0
 4138 002a 7047     		bx	lr
 4139              	.L277:
 4140              		.align	2
 4141              	.L276:
 4142 002c 00000000 		.word	pxCurrentTCB
 4143              		.cfi_endproc
 4144              	.LFE109:
 4145              		.size	uxTaskResetEventItemValue, .-uxTaskResetEventItemValue
 4146              		.section	.text.pvTaskIncrementMutexHeldCount,"ax",%progbits
 4147              		.align	2
 4148              		.global	pvTaskIncrementMutexHeldCount
 4149              		.thumb
 4150              		.thumb_func
 4151              		.type	pvTaskIncrementMutexHeldCount, %function
 4152              	pvTaskIncrementMutexHeldCount:
 4153              	.LFB110:
4055:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
4056:..\..\..\Source/tasks.c **** 
4057:..\..\..\Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4058:..\..\..\Source/tasks.c **** 
4059:..\..\..\Source/tasks.c **** 	void *pvTaskIncrementMutexHeldCount( void )
4060:..\..\..\Source/tasks.c **** 	{
 4154              		.loc 1 4060 0
 4155              		.cfi_startproc
 4156              		@ args = 0, pretend = 0, frame = 0
 4157              		@ frame_needed = 1, uses_anonymous_args = 0
 4158              		@ link register save eliminated.
 4159 0000 80B4     		push	{r7}
 4160              		.cfi_def_cfa_offset 4
 4161              		.cfi_offset 7, -4
 4162 0002 00AF     		add	r7, sp, #0
 4163              		.cfi_def_cfa_register 7
4061:..\..\..\Source/tasks.c **** 		/* If xSemaphoreCreateMutex() is called before any tasks have been created
4062:..\..\..\Source/tasks.c **** 		then pxCurrentTCB will be NULL. */
4063:..\..\..\Source/tasks.c **** 		if( pxCurrentTCB != NULL )
 4164              		.loc 1 4063 0
 4165 0004 074B     		ldr	r3, .L281
 4166 0006 1B68     		ldr	r3, [r3]
 4167 0008 002B     		cmp	r3, #0
 4168 000a 04D0     		beq	.L279
4064:..\..\..\Source/tasks.c **** 		{
4065:..\..\..\Source/tasks.c **** 			( pxCurrentTCB->uxMutexesHeld )++;
 4169              		.loc 1 4065 0
 4170 000c 054B     		ldr	r3, .L281
 4171 000e 1B68     		ldr	r3, [r3]
 4172 0010 5A6C     		ldr	r2, [r3, #68]
 4173 0012 0132     		adds	r2, r2, #1
 4174 0014 5A64     		str	r2, [r3, #68]
 4175              	.L279:
4066:..\..\..\Source/tasks.c **** 		}
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 151


4067:..\..\..\Source/tasks.c **** 
4068:..\..\..\Source/tasks.c **** 		return pxCurrentTCB;
 4176              		.loc 1 4068 0
 4177 0016 034B     		ldr	r3, .L281
 4178 0018 1B68     		ldr	r3, [r3]
4069:..\..\..\Source/tasks.c **** 	}
 4179              		.loc 1 4069 0
 4180 001a 1846     		mov	r0, r3
 4181 001c BD46     		mov	sp, r7
 4182              		.cfi_def_cfa_register 13
 4183              		@ sp needed
 4184 001e 5DF8047B 		ldr	r7, [sp], #4
 4185              		.cfi_restore 7
 4186              		.cfi_def_cfa_offset 0
 4187 0022 7047     		bx	lr
 4188              	.L282:
 4189              		.align	2
 4190              	.L281:
 4191 0024 00000000 		.word	pxCurrentTCB
 4192              		.cfi_endproc
 4193              	.LFE110:
 4194              		.size	pvTaskIncrementMutexHeldCount, .-pvTaskIncrementMutexHeldCount
 4195              		.section	.text.ulTaskNotifyTake,"ax",%progbits
 4196              		.align	2
 4197              		.global	ulTaskNotifyTake
 4198              		.thumb
 4199              		.thumb_func
 4200              		.type	ulTaskNotifyTake, %function
 4201              	ulTaskNotifyTake:
 4202              	.LFB111:
4070:..\..\..\Source/tasks.c **** 
4071:..\..\..\Source/tasks.c **** #endif /* configUSE_MUTEXES */
4072:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
4073:..\..\..\Source/tasks.c **** 
4074:..\..\..\Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4075:..\..\..\Source/tasks.c **** 
4076:..\..\..\Source/tasks.c **** 	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
4077:..\..\..\Source/tasks.c **** 	{
 4203              		.loc 1 4077 0
 4204              		.cfi_startproc
 4205              		@ args = 0, pretend = 0, frame = 16
 4206              		@ frame_needed = 1, uses_anonymous_args = 0
 4207 0000 80B5     		push	{r7, lr}
 4208              		.cfi_def_cfa_offset 8
 4209              		.cfi_offset 7, -8
 4210              		.cfi_offset 14, -4
 4211 0002 84B0     		sub	sp, sp, #16
 4212              		.cfi_def_cfa_offset 24
 4213 0004 00AF     		add	r7, sp, #0
 4214              		.cfi_def_cfa_register 7
 4215 0006 7860     		str	r0, [r7, #4]
 4216 0008 3960     		str	r1, [r7]
4078:..\..\..\Source/tasks.c **** 	uint32_t ulReturn;
4079:..\..\..\Source/tasks.c **** 
4080:..\..\..\Source/tasks.c **** 		taskENTER_CRITICAL();
 4217              		.loc 1 4080 0
 4218 000a FFF7FEFF 		bl	vPortEnterCritical
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 152


4081:..\..\..\Source/tasks.c **** 		{
4082:..\..\..\Source/tasks.c **** 			/* Only block if the notification count is not already non-zero. */
4083:..\..\..\Source/tasks.c **** 			if( pxCurrentTCB->ulNotifiedValue == 0UL )
 4219              		.loc 1 4083 0
 4220 000e 1E4B     		ldr	r3, .L289
 4221 0010 1B68     		ldr	r3, [r3]
 4222 0012 9B6C     		ldr	r3, [r3, #72]
 4223 0014 002B     		cmp	r3, #0
 4224 0016 13D1     		bne	.L284
4084:..\..\..\Source/tasks.c **** 			{
4085:..\..\..\Source/tasks.c **** 				/* Mark this task as waiting for a notification. */
4086:..\..\..\Source/tasks.c **** 				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 4225              		.loc 1 4086 0
 4226 0018 1B4B     		ldr	r3, .L289
 4227 001a 1B68     		ldr	r3, [r3]
 4228 001c 0122     		movs	r2, #1
 4229 001e 83F84C20 		strb	r2, [r3, #76]
4087:..\..\..\Source/tasks.c **** 
4088:..\..\..\Source/tasks.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
 4230              		.loc 1 4088 0
 4231 0022 3B68     		ldr	r3, [r7]
 4232 0024 002B     		cmp	r3, #0
 4233 0026 0BD0     		beq	.L284
4089:..\..\..\Source/tasks.c **** 				{
4090:..\..\..\Source/tasks.c **** 					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 4234              		.loc 1 4090 0
 4235 0028 3868     		ldr	r0, [r7]
 4236 002a 0121     		movs	r1, #1
 4237 002c FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
4091:..\..\..\Source/tasks.c **** 					traceTASK_NOTIFY_TAKE_BLOCK();
4092:..\..\..\Source/tasks.c **** 
4093:..\..\..\Source/tasks.c **** 					/* All ports are written to allow a yield in a critical
4094:..\..\..\Source/tasks.c **** 					section (some will yield immediately, others wait until the
4095:..\..\..\Source/tasks.c **** 					critical section exits) - but it is not something that
4096:..\..\..\Source/tasks.c **** 					application code should ever do. */
4097:..\..\..\Source/tasks.c **** 					portYIELD_WITHIN_API();
 4238              		.loc 1 4097 0
 4239 0030 164B     		ldr	r3, .L289+4
 4240 0032 4FF08052 		mov	r2, #268435456
 4241 0036 1A60     		str	r2, [r3]
 4242              	@ 4097 "..\..\..\Source\tasks.c" 1
 4243 0038 BFF34F8F 		dsb
 4244              	@ 0 "" 2
 4245              	@ 4097 "..\..\..\Source\tasks.c" 1
 4246 003c BFF36F8F 		isb
 4247              	@ 0 "" 2
 4248              		.thumb
 4249              	.L284:
4098:..\..\..\Source/tasks.c **** 				}
4099:..\..\..\Source/tasks.c **** 				else
4100:..\..\..\Source/tasks.c **** 				{
4101:..\..\..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4102:..\..\..\Source/tasks.c **** 				}
4103:..\..\..\Source/tasks.c **** 			}
4104:..\..\..\Source/tasks.c **** 			else
4105:..\..\..\Source/tasks.c **** 			{
4106:..\..\..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 153


4107:..\..\..\Source/tasks.c **** 			}
4108:..\..\..\Source/tasks.c **** 		}
4109:..\..\..\Source/tasks.c **** 		taskEXIT_CRITICAL();
 4250              		.loc 1 4109 0
 4251 0040 FFF7FEFF 		bl	vPortExitCritical
4110:..\..\..\Source/tasks.c **** 
4111:..\..\..\Source/tasks.c **** 		taskENTER_CRITICAL();
 4252              		.loc 1 4111 0
 4253 0044 FFF7FEFF 		bl	vPortEnterCritical
4112:..\..\..\Source/tasks.c **** 		{
4113:..\..\..\Source/tasks.c **** 			traceTASK_NOTIFY_TAKE();
4114:..\..\..\Source/tasks.c **** 			ulReturn = pxCurrentTCB->ulNotifiedValue;
 4254              		.loc 1 4114 0
 4255 0048 0F4B     		ldr	r3, .L289
 4256 004a 1B68     		ldr	r3, [r3]
 4257 004c 9B6C     		ldr	r3, [r3, #72]
 4258 004e FB60     		str	r3, [r7, #12]
4115:..\..\..\Source/tasks.c **** 
4116:..\..\..\Source/tasks.c **** 			if( ulReturn != 0UL )
 4259              		.loc 1 4116 0
 4260 0050 FB68     		ldr	r3, [r7, #12]
 4261 0052 002B     		cmp	r3, #0
 4262 0054 0CD0     		beq	.L285
4117:..\..\..\Source/tasks.c **** 			{
4118:..\..\..\Source/tasks.c **** 				if( xClearCountOnExit != pdFALSE )
 4263              		.loc 1 4118 0
 4264 0056 7B68     		ldr	r3, [r7, #4]
 4265 0058 002B     		cmp	r3, #0
 4266 005a 04D0     		beq	.L286
4119:..\..\..\Source/tasks.c **** 				{
4120:..\..\..\Source/tasks.c **** 					pxCurrentTCB->ulNotifiedValue = 0UL;
 4267              		.loc 1 4120 0
 4268 005c 0A4B     		ldr	r3, .L289
 4269 005e 1B68     		ldr	r3, [r3]
 4270 0060 0022     		movs	r2, #0
 4271 0062 9A64     		str	r2, [r3, #72]
 4272 0064 04E0     		b	.L285
 4273              	.L286:
4121:..\..\..\Source/tasks.c **** 				}
4122:..\..\..\Source/tasks.c **** 				else
4123:..\..\..\Source/tasks.c **** 				{
4124:..\..\..\Source/tasks.c **** 					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
 4274              		.loc 1 4124 0
 4275 0066 084B     		ldr	r3, .L289
 4276 0068 1B68     		ldr	r3, [r3]
 4277 006a FA68     		ldr	r2, [r7, #12]
 4278 006c 013A     		subs	r2, r2, #1
 4279 006e 9A64     		str	r2, [r3, #72]
 4280              	.L285:
4125:..\..\..\Source/tasks.c **** 				}
4126:..\..\..\Source/tasks.c **** 			}
4127:..\..\..\Source/tasks.c **** 			else
4128:..\..\..\Source/tasks.c **** 			{
4129:..\..\..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4130:..\..\..\Source/tasks.c **** 			}
4131:..\..\..\Source/tasks.c **** 
4132:..\..\..\Source/tasks.c **** 			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 154


 4281              		.loc 1 4132 0
 4282 0070 054B     		ldr	r3, .L289
 4283 0072 1B68     		ldr	r3, [r3]
 4284 0074 0022     		movs	r2, #0
 4285 0076 83F84C20 		strb	r2, [r3, #76]
4133:..\..\..\Source/tasks.c **** 		}
4134:..\..\..\Source/tasks.c **** 		taskEXIT_CRITICAL();
 4286              		.loc 1 4134 0
 4287 007a FFF7FEFF 		bl	vPortExitCritical
4135:..\..\..\Source/tasks.c **** 
4136:..\..\..\Source/tasks.c **** 		return ulReturn;
 4288              		.loc 1 4136 0
 4289 007e FB68     		ldr	r3, [r7, #12]
4137:..\..\..\Source/tasks.c **** 	}
 4290              		.loc 1 4137 0
 4291 0080 1846     		mov	r0, r3
 4292 0082 1037     		adds	r7, r7, #16
 4293              		.cfi_def_cfa_offset 8
 4294 0084 BD46     		mov	sp, r7
 4295              		.cfi_def_cfa_register 13
 4296              		@ sp needed
 4297 0086 80BD     		pop	{r7, pc}
 4298              	.L290:
 4299              		.align	2
 4300              	.L289:
 4301 0088 00000000 		.word	pxCurrentTCB
 4302 008c 04ED00E0 		.word	-536810236
 4303              		.cfi_endproc
 4304              	.LFE111:
 4305              		.size	ulTaskNotifyTake, .-ulTaskNotifyTake
 4306              		.section	.text.xTaskNotifyWait,"ax",%progbits
 4307              		.align	2
 4308              		.global	xTaskNotifyWait
 4309              		.thumb
 4310              		.thumb_func
 4311              		.type	xTaskNotifyWait, %function
 4312              	xTaskNotifyWait:
 4313              	.LFB112:
4138:..\..\..\Source/tasks.c **** 
4139:..\..\..\Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4140:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
4141:..\..\..\Source/tasks.c **** 
4142:..\..\..\Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4143:..\..\..\Source/tasks.c **** 
4144:..\..\..\Source/tasks.c **** 	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t 
4145:..\..\..\Source/tasks.c **** 	{
 4314              		.loc 1 4145 0
 4315              		.cfi_startproc
 4316              		@ args = 0, pretend = 0, frame = 24
 4317              		@ frame_needed = 1, uses_anonymous_args = 0
 4318 0000 80B5     		push	{r7, lr}
 4319              		.cfi_def_cfa_offset 8
 4320              		.cfi_offset 7, -8
 4321              		.cfi_offset 14, -4
 4322 0002 86B0     		sub	sp, sp, #24
 4323              		.cfi_def_cfa_offset 32
 4324 0004 00AF     		add	r7, sp, #0
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 155


 4325              		.cfi_def_cfa_register 7
 4326 0006 F860     		str	r0, [r7, #12]
 4327 0008 B960     		str	r1, [r7, #8]
 4328 000a 7A60     		str	r2, [r7, #4]
 4329 000c 3B60     		str	r3, [r7]
4146:..\..\..\Source/tasks.c **** 	BaseType_t xReturn;
4147:..\..\..\Source/tasks.c **** 
4148:..\..\..\Source/tasks.c **** 		taskENTER_CRITICAL();
 4330              		.loc 1 4148 0
 4331 000e FFF7FEFF 		bl	vPortEnterCritical
4149:..\..\..\Source/tasks.c **** 		{
4150:..\..\..\Source/tasks.c **** 			/* Only block if a notification is not already pending. */
4151:..\..\..\Source/tasks.c **** 			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
 4332              		.loc 1 4151 0
 4333 0012 264B     		ldr	r3, .L297
 4334 0014 1B68     		ldr	r3, [r3]
 4335 0016 93F84C30 		ldrb	r3, [r3, #76]
 4336 001a DBB2     		uxtb	r3, r3
 4337 001c 022B     		cmp	r3, #2
 4338 001e 1AD0     		beq	.L292
4152:..\..\..\Source/tasks.c **** 			{
4153:..\..\..\Source/tasks.c **** 				/* Clear bits in the task's notification value as bits may get
4154:..\..\..\Source/tasks.c **** 				set	by the notifying task or interrupt.  This can be used to
4155:..\..\..\Source/tasks.c **** 				clear the value to zero. */
4156:..\..\..\Source/tasks.c **** 				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
 4339              		.loc 1 4156 0
 4340 0020 224B     		ldr	r3, .L297
 4341 0022 1B68     		ldr	r3, [r3]
 4342 0024 996C     		ldr	r1, [r3, #72]
 4343 0026 FA68     		ldr	r2, [r7, #12]
 4344 0028 D243     		mvns	r2, r2
 4345 002a 0A40     		ands	r2, r2, r1
 4346 002c 9A64     		str	r2, [r3, #72]
4157:..\..\..\Source/tasks.c **** 
4158:..\..\..\Source/tasks.c **** 				/* Mark this task as waiting for a notification. */
4159:..\..\..\Source/tasks.c **** 				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 4347              		.loc 1 4159 0
 4348 002e 1F4B     		ldr	r3, .L297
 4349 0030 1B68     		ldr	r3, [r3]
 4350 0032 0122     		movs	r2, #1
 4351 0034 83F84C20 		strb	r2, [r3, #76]
4160:..\..\..\Source/tasks.c **** 
4161:..\..\..\Source/tasks.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
 4352              		.loc 1 4161 0
 4353 0038 3B68     		ldr	r3, [r7]
 4354 003a 002B     		cmp	r3, #0
 4355 003c 0BD0     		beq	.L292
4162:..\..\..\Source/tasks.c **** 				{
4163:..\..\..\Source/tasks.c **** 					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 4356              		.loc 1 4163 0
 4357 003e 3868     		ldr	r0, [r7]
 4358 0040 0121     		movs	r1, #1
 4359 0042 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
4164:..\..\..\Source/tasks.c **** 					traceTASK_NOTIFY_WAIT_BLOCK();
4165:..\..\..\Source/tasks.c **** 
4166:..\..\..\Source/tasks.c **** 					/* All ports are written to allow a yield in a critical
4167:..\..\..\Source/tasks.c **** 					section (some will yield immediately, others wait until the
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 156


4168:..\..\..\Source/tasks.c **** 					critical section exits) - but it is not something that
4169:..\..\..\Source/tasks.c **** 					application code should ever do. */
4170:..\..\..\Source/tasks.c **** 					portYIELD_WITHIN_API();
 4360              		.loc 1 4170 0
 4361 0046 1A4B     		ldr	r3, .L297+4
 4362 0048 4FF08052 		mov	r2, #268435456
 4363 004c 1A60     		str	r2, [r3]
 4364              	@ 4170 "..\..\..\Source\tasks.c" 1
 4365 004e BFF34F8F 		dsb
 4366              	@ 0 "" 2
 4367              	@ 4170 "..\..\..\Source\tasks.c" 1
 4368 0052 BFF36F8F 		isb
 4369              	@ 0 "" 2
 4370              		.thumb
 4371              	.L292:
4171:..\..\..\Source/tasks.c **** 				}
4172:..\..\..\Source/tasks.c **** 				else
4173:..\..\..\Source/tasks.c **** 				{
4174:..\..\..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4175:..\..\..\Source/tasks.c **** 				}
4176:..\..\..\Source/tasks.c **** 			}
4177:..\..\..\Source/tasks.c **** 			else
4178:..\..\..\Source/tasks.c **** 			{
4179:..\..\..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4180:..\..\..\Source/tasks.c **** 			}
4181:..\..\..\Source/tasks.c **** 		}
4182:..\..\..\Source/tasks.c **** 		taskEXIT_CRITICAL();
 4372              		.loc 1 4182 0
 4373 0056 FFF7FEFF 		bl	vPortExitCritical
4183:..\..\..\Source/tasks.c **** 
4184:..\..\..\Source/tasks.c **** 		taskENTER_CRITICAL();
 4374              		.loc 1 4184 0
 4375 005a FFF7FEFF 		bl	vPortEnterCritical
4185:..\..\..\Source/tasks.c **** 		{
4186:..\..\..\Source/tasks.c **** 			traceTASK_NOTIFY_WAIT();
4187:..\..\..\Source/tasks.c **** 
4188:..\..\..\Source/tasks.c **** 			if( pulNotificationValue != NULL )
 4376              		.loc 1 4188 0
 4377 005e 7B68     		ldr	r3, [r7, #4]
 4378 0060 002B     		cmp	r3, #0
 4379 0062 04D0     		beq	.L293
4189:..\..\..\Source/tasks.c **** 			{
4190:..\..\..\Source/tasks.c **** 				/* Output the current notification value, which may or may not
4191:..\..\..\Source/tasks.c **** 				have changed. */
4192:..\..\..\Source/tasks.c **** 				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
 4380              		.loc 1 4192 0
 4381 0064 114B     		ldr	r3, .L297
 4382 0066 1B68     		ldr	r3, [r3]
 4383 0068 9A6C     		ldr	r2, [r3, #72]
 4384 006a 7B68     		ldr	r3, [r7, #4]
 4385 006c 1A60     		str	r2, [r3]
 4386              	.L293:
4193:..\..\..\Source/tasks.c **** 			}
4194:..\..\..\Source/tasks.c **** 
4195:..\..\..\Source/tasks.c **** 			/* If ucNotifyValue is set then either the task never entered the
4196:..\..\..\Source/tasks.c **** 			blocked state (because a notification was already pending) or the
4197:..\..\..\Source/tasks.c **** 			task unblocked because of a notification.  Otherwise the task
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 157


4198:..\..\..\Source/tasks.c **** 			unblocked because of a timeout. */
4199:..\..\..\Source/tasks.c **** 			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
 4387              		.loc 1 4199 0
 4388 006e 0F4B     		ldr	r3, .L297
 4389 0070 1B68     		ldr	r3, [r3]
 4390 0072 93F84C30 		ldrb	r3, [r3, #76]
 4391 0076 DBB2     		uxtb	r3, r3
 4392 0078 012B     		cmp	r3, #1
 4393 007a 02D1     		bne	.L294
4200:..\..\..\Source/tasks.c **** 			{
4201:..\..\..\Source/tasks.c **** 				/* A notification was not received. */
4202:..\..\..\Source/tasks.c **** 				xReturn = pdFALSE;
 4394              		.loc 1 4202 0
 4395 007c 0023     		movs	r3, #0
 4396 007e 7B61     		str	r3, [r7, #20]
 4397 0080 08E0     		b	.L295
 4398              	.L294:
4203:..\..\..\Source/tasks.c **** 			}
4204:..\..\..\Source/tasks.c **** 			else
4205:..\..\..\Source/tasks.c **** 			{
4206:..\..\..\Source/tasks.c **** 				/* A notification was already pending or a notification was
4207:..\..\..\Source/tasks.c **** 				received while the task was waiting. */
4208:..\..\..\Source/tasks.c **** 				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
 4399              		.loc 1 4208 0
 4400 0082 0A4B     		ldr	r3, .L297
 4401 0084 1B68     		ldr	r3, [r3]
 4402 0086 996C     		ldr	r1, [r3, #72]
 4403 0088 BA68     		ldr	r2, [r7, #8]
 4404 008a D243     		mvns	r2, r2
 4405 008c 0A40     		ands	r2, r2, r1
 4406 008e 9A64     		str	r2, [r3, #72]
4209:..\..\..\Source/tasks.c **** 				xReturn = pdTRUE;
 4407              		.loc 1 4209 0
 4408 0090 0123     		movs	r3, #1
 4409 0092 7B61     		str	r3, [r7, #20]
 4410              	.L295:
4210:..\..\..\Source/tasks.c **** 			}
4211:..\..\..\Source/tasks.c **** 
4212:..\..\..\Source/tasks.c **** 			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 4411              		.loc 1 4212 0
 4412 0094 054B     		ldr	r3, .L297
 4413 0096 1B68     		ldr	r3, [r3]
 4414 0098 0022     		movs	r2, #0
 4415 009a 83F84C20 		strb	r2, [r3, #76]
4213:..\..\..\Source/tasks.c **** 		}
4214:..\..\..\Source/tasks.c **** 		taskEXIT_CRITICAL();
 4416              		.loc 1 4214 0
 4417 009e FFF7FEFF 		bl	vPortExitCritical
4215:..\..\..\Source/tasks.c **** 
4216:..\..\..\Source/tasks.c **** 		return xReturn;
 4418              		.loc 1 4216 0
 4419 00a2 7B69     		ldr	r3, [r7, #20]
4217:..\..\..\Source/tasks.c **** 	}
 4420              		.loc 1 4217 0
 4421 00a4 1846     		mov	r0, r3
 4422 00a6 1837     		adds	r7, r7, #24
 4423              		.cfi_def_cfa_offset 8
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 158


 4424 00a8 BD46     		mov	sp, r7
 4425              		.cfi_def_cfa_register 13
 4426              		@ sp needed
 4427 00aa 80BD     		pop	{r7, pc}
 4428              	.L298:
 4429              		.align	2
 4430              	.L297:
 4431 00ac 00000000 		.word	pxCurrentTCB
 4432 00b0 04ED00E0 		.word	-536810236
 4433              		.cfi_endproc
 4434              	.LFE112:
 4435              		.size	xTaskNotifyWait, .-xTaskNotifyWait
 4436              		.section	.text.xTaskGenericNotify,"ax",%progbits
 4437              		.align	2
 4438              		.global	xTaskGenericNotify
 4439              		.thumb
 4440              		.thumb_func
 4441              		.type	xTaskGenericNotify, %function
 4442              	xTaskGenericNotify:
 4443              	.LFB113:
4218:..\..\..\Source/tasks.c **** 
4219:..\..\..\Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4220:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
4221:..\..\..\Source/tasks.c **** 
4222:..\..\..\Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4223:..\..\..\Source/tasks.c **** 
4224:..\..\..\Source/tasks.c **** 	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction
4225:..\..\..\Source/tasks.c **** 	{
 4444              		.loc 1 4225 0
 4445              		.cfi_startproc
 4446              		@ args = 0, pretend = 0, frame = 32
 4447              		@ frame_needed = 1, uses_anonymous_args = 0
 4448 0000 80B5     		push	{r7, lr}
 4449              		.cfi_def_cfa_offset 8
 4450              		.cfi_offset 7, -8
 4451              		.cfi_offset 14, -4
 4452 0002 88B0     		sub	sp, sp, #32
 4453              		.cfi_def_cfa_offset 40
 4454 0004 00AF     		add	r7, sp, #0
 4455              		.cfi_def_cfa_register 7
 4456 0006 F860     		str	r0, [r7, #12]
 4457 0008 B960     		str	r1, [r7, #8]
 4458 000a 3B60     		str	r3, [r7]
 4459 000c 1346     		mov	r3, r2
 4460 000e FB71     		strb	r3, [r7, #7]
4226:..\..\..\Source/tasks.c **** 	TCB_t * pxTCB;
4227:..\..\..\Source/tasks.c **** 	BaseType_t xReturn = pdPASS;
 4461              		.loc 1 4227 0
 4462 0010 0123     		movs	r3, #1
 4463 0012 FB61     		str	r3, [r7, #28]
4228:..\..\..\Source/tasks.c **** 	uint8_t ucOriginalNotifyState;
4229:..\..\..\Source/tasks.c **** 
4230:..\..\..\Source/tasks.c **** 		configASSERT( xTaskToNotify );
4231:..\..\..\Source/tasks.c **** 		pxTCB = ( TCB_t * ) xTaskToNotify;
 4464              		.loc 1 4231 0
 4465 0014 FB68     		ldr	r3, [r7, #12]
 4466 0016 BB61     		str	r3, [r7, #24]
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 159


4232:..\..\..\Source/tasks.c **** 
4233:..\..\..\Source/tasks.c **** 		taskENTER_CRITICAL();
 4467              		.loc 1 4233 0
 4468 0018 FFF7FEFF 		bl	vPortEnterCritical
4234:..\..\..\Source/tasks.c **** 		{
4235:..\..\..\Source/tasks.c **** 			if( pulPreviousNotificationValue != NULL )
 4469              		.loc 1 4235 0
 4470 001c 3B68     		ldr	r3, [r7]
 4471 001e 002B     		cmp	r3, #0
 4472 0020 03D0     		beq	.L300
4236:..\..\..\Source/tasks.c **** 			{
4237:..\..\..\Source/tasks.c **** 				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 4473              		.loc 1 4237 0
 4474 0022 BB69     		ldr	r3, [r7, #24]
 4475 0024 9A6C     		ldr	r2, [r3, #72]
 4476 0026 3B68     		ldr	r3, [r7]
 4477 0028 1A60     		str	r2, [r3]
 4478              	.L300:
4238:..\..\..\Source/tasks.c **** 			}
4239:..\..\..\Source/tasks.c **** 
4240:..\..\..\Source/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
 4479              		.loc 1 4240 0
 4480 002a BB69     		ldr	r3, [r7, #24]
 4481 002c 93F84C30 		ldrb	r3, [r3, #76]
 4482 0030 FB75     		strb	r3, [r7, #23]
4241:..\..\..\Source/tasks.c **** 
4242:..\..\..\Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 4483              		.loc 1 4242 0
 4484 0032 BB69     		ldr	r3, [r7, #24]
 4485 0034 0222     		movs	r2, #2
 4486 0036 83F84C20 		strb	r2, [r3, #76]
4243:..\..\..\Source/tasks.c **** 
4244:..\..\..\Source/tasks.c **** 			switch( eAction )
 4487              		.loc 1 4244 0
 4488 003a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4489 003c 042B     		cmp	r3, #4
 4490 003e 28D8     		bhi	.L301
 4491 0040 01A2     		adr	r2, .L303
 4492 0042 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 4493 0046 00BF     		.p2align 2
 4494              	.L303:
 4495 0048 93000000 		.word	.L301+1
 4496 004c 5D000000 		.word	.L304+1
 4497 0050 6B000000 		.word	.L305+1
 4498 0054 77000000 		.word	.L306+1
 4499 0058 7F000000 		.word	.L307+1
 4500              		.p2align 1
 4501              	.L304:
4245:..\..\..\Source/tasks.c **** 			{
4246:..\..\..\Source/tasks.c **** 				case eSetBits	:
4247:..\..\..\Source/tasks.c **** 					pxTCB->ulNotifiedValue |= ulValue;
 4502              		.loc 1 4247 0
 4503 005c BB69     		ldr	r3, [r7, #24]
 4504 005e 9A6C     		ldr	r2, [r3, #72]
 4505 0060 BB68     		ldr	r3, [r7, #8]
 4506 0062 1A43     		orrs	r2, r2, r3
 4507 0064 BB69     		ldr	r3, [r7, #24]
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 160


 4508 0066 9A64     		str	r2, [r3, #72]
4248:..\..\..\Source/tasks.c **** 					break;
 4509              		.loc 1 4248 0
 4510 0068 13E0     		b	.L301
 4511              	.L305:
4249:..\..\..\Source/tasks.c **** 
4250:..\..\..\Source/tasks.c **** 				case eIncrement	:
4251:..\..\..\Source/tasks.c **** 					( pxTCB->ulNotifiedValue )++;
 4512              		.loc 1 4251 0
 4513 006a BB69     		ldr	r3, [r7, #24]
 4514 006c 9B6C     		ldr	r3, [r3, #72]
 4515 006e 5A1C     		adds	r2, r3, #1
 4516 0070 BB69     		ldr	r3, [r7, #24]
 4517 0072 9A64     		str	r2, [r3, #72]
4252:..\..\..\Source/tasks.c **** 					break;
 4518              		.loc 1 4252 0
 4519 0074 0DE0     		b	.L301
 4520              	.L306:
4253:..\..\..\Source/tasks.c **** 
4254:..\..\..\Source/tasks.c **** 				case eSetValueWithOverwrite	:
4255:..\..\..\Source/tasks.c **** 					pxTCB->ulNotifiedValue = ulValue;
 4521              		.loc 1 4255 0
 4522 0076 BB69     		ldr	r3, [r7, #24]
 4523 0078 BA68     		ldr	r2, [r7, #8]
 4524 007a 9A64     		str	r2, [r3, #72]
4256:..\..\..\Source/tasks.c **** 					break;
 4525              		.loc 1 4256 0
 4526 007c 09E0     		b	.L301
 4527              	.L307:
4257:..\..\..\Source/tasks.c **** 
4258:..\..\..\Source/tasks.c **** 				case eSetValueWithoutOverwrite :
4259:..\..\..\Source/tasks.c **** 					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 4528              		.loc 1 4259 0
 4529 007e FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 4530 0080 022B     		cmp	r3, #2
 4531 0082 03D0     		beq	.L308
4260:..\..\..\Source/tasks.c **** 					{
4261:..\..\..\Source/tasks.c **** 						pxTCB->ulNotifiedValue = ulValue;
 4532              		.loc 1 4261 0
 4533 0084 BB69     		ldr	r3, [r7, #24]
 4534 0086 BA68     		ldr	r2, [r7, #8]
 4535 0088 9A64     		str	r2, [r3, #72]
4262:..\..\..\Source/tasks.c **** 					}
4263:..\..\..\Source/tasks.c **** 					else
4264:..\..\..\Source/tasks.c **** 					{
4265:..\..\..\Source/tasks.c **** 						/* The value could not be written to the task. */
4266:..\..\..\Source/tasks.c **** 						xReturn = pdFAIL;
4267:..\..\..\Source/tasks.c **** 					}
4268:..\..\..\Source/tasks.c **** 					break;
 4536              		.loc 1 4268 0
 4537 008a 01E0     		b	.L312
 4538              	.L308:
4266:..\..\..\Source/tasks.c **** 					}
 4539              		.loc 1 4266 0
 4540 008c 0023     		movs	r3, #0
 4541 008e FB61     		str	r3, [r7, #28]
 4542              	.L312:
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 161


 4543              		.loc 1 4268 0
 4544 0090 00BF     		nop
 4545              	.L301:
4269:..\..\..\Source/tasks.c **** 
4270:..\..\..\Source/tasks.c **** 				case eNoAction:
4271:..\..\..\Source/tasks.c **** 					/* The task is being notified without its notify value being
4272:..\..\..\Source/tasks.c **** 					updated. */
4273:..\..\..\Source/tasks.c **** 					break;
4274:..\..\..\Source/tasks.c **** 			}
4275:..\..\..\Source/tasks.c **** 
4276:..\..\..\Source/tasks.c **** 			traceTASK_NOTIFY();
4277:..\..\..\Source/tasks.c **** 
4278:..\..\..\Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4279:..\..\..\Source/tasks.c **** 			notification then unblock it now. */
4280:..\..\..\Source/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 4546              		.loc 1 4280 0
 4547 0092 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 4548 0094 012B     		cmp	r3, #1
 4549 0096 2CD1     		bne	.L310
4281:..\..\..\Source/tasks.c **** 			{
4282:..\..\..\Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 4550              		.loc 1 4282 0
 4551 0098 BB69     		ldr	r3, [r7, #24]
 4552 009a 0433     		adds	r3, r3, #4
 4553 009c 1846     		mov	r0, r3
 4554 009e FFF7FEFF 		bl	uxListRemove
4283:..\..\..\Source/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
 4555              		.loc 1 4283 0
 4556 00a2 BB69     		ldr	r3, [r7, #24]
 4557 00a4 DB6A     		ldr	r3, [r3, #44]
 4558 00a6 1A46     		mov	r2, r3
 4559 00a8 0123     		movs	r3, #1
 4560 00aa 03FA02F2 		lsl	r2, r3, r2
 4561 00ae 144B     		ldr	r3, .L313
 4562 00b0 1B68     		ldr	r3, [r3]
 4563 00b2 1343     		orrs	r3, r3, r2
 4564 00b4 124A     		ldr	r2, .L313
 4565 00b6 1360     		str	r3, [r2]
 4566 00b8 BB69     		ldr	r3, [r7, #24]
 4567 00ba DA6A     		ldr	r2, [r3, #44]
 4568 00bc 1346     		mov	r3, r2
 4569 00be 9B00     		lsls	r3, r3, #2
 4570 00c0 1344     		add	r3, r3, r2
 4571 00c2 9B00     		lsls	r3, r3, #2
 4572 00c4 0F4A     		ldr	r2, .L313+4
 4573 00c6 1A44     		add	r2, r2, r3
 4574 00c8 BB69     		ldr	r3, [r7, #24]
 4575 00ca 0433     		adds	r3, r3, #4
 4576 00cc 1046     		mov	r0, r2
 4577 00ce 1946     		mov	r1, r3
 4578 00d0 FFF7FEFF 		bl	vListInsertEnd
4284:..\..\..\Source/tasks.c **** 
4285:..\..\..\Source/tasks.c **** 				/* The task should not have been on an event list. */
4286:..\..\..\Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4287:..\..\..\Source/tasks.c **** 
4288:..\..\..\Source/tasks.c **** 				#if( configUSE_TICKLESS_IDLE != 0 )
4289:..\..\..\Source/tasks.c **** 				{
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 162


4290:..\..\..\Source/tasks.c **** 					/* If a task is blocked waiting for a notification then
4291:..\..\..\Source/tasks.c **** 					xNextTaskUnblockTime might be set to the blocked task's time
4292:..\..\..\Source/tasks.c **** 					out time.  If the task is unblocked for a reason other than
4293:..\..\..\Source/tasks.c **** 					a timeout xNextTaskUnblockTime is normally left unchanged,
4294:..\..\..\Source/tasks.c **** 					because it will automatically get reset to a new value when
4295:..\..\..\Source/tasks.c **** 					the tick count equals xNextTaskUnblockTime.  However if
4296:..\..\..\Source/tasks.c **** 					tickless idling is used it might be more important to enter
4297:..\..\..\Source/tasks.c **** 					sleep mode at the earliest possible time - so reset
4298:..\..\..\Source/tasks.c **** 					xNextTaskUnblockTime here to ensure it is updated at the
4299:..\..\..\Source/tasks.c **** 					earliest possible time. */
4300:..\..\..\Source/tasks.c **** 					prvResetNextTaskUnblockTime();
4301:..\..\..\Source/tasks.c **** 				}
4302:..\..\..\Source/tasks.c **** 				#endif
4303:..\..\..\Source/tasks.c **** 
4304:..\..\..\Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 4579              		.loc 1 4304 0
 4580 00d4 BB69     		ldr	r3, [r7, #24]
 4581 00d6 DA6A     		ldr	r2, [r3, #44]
 4582 00d8 0B4B     		ldr	r3, .L313+8
 4583 00da 1B68     		ldr	r3, [r3]
 4584 00dc DB6A     		ldr	r3, [r3, #44]
 4585 00de 9A42     		cmp	r2, r3
 4586 00e0 07D9     		bls	.L310
4305:..\..\..\Source/tasks.c **** 				{
4306:..\..\..\Source/tasks.c **** 					/* The notified task has a priority above the currently
4307:..\..\..\Source/tasks.c **** 					executing task so a yield is required. */
4308:..\..\..\Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
 4587              		.loc 1 4308 0
 4588 00e2 0A4B     		ldr	r3, .L313+12
 4589 00e4 4FF08052 		mov	r2, #268435456
 4590 00e8 1A60     		str	r2, [r3]
 4591              	@ 4308 "..\..\..\Source\tasks.c" 1
 4592 00ea BFF34F8F 		dsb
 4593              	@ 0 "" 2
 4594              	@ 4308 "..\..\..\Source\tasks.c" 1
 4595 00ee BFF36F8F 		isb
 4596              	@ 0 "" 2
 4597              		.thumb
 4598              	.L310:
4309:..\..\..\Source/tasks.c **** 				}
4310:..\..\..\Source/tasks.c **** 				else
4311:..\..\..\Source/tasks.c **** 				{
4312:..\..\..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4313:..\..\..\Source/tasks.c **** 				}
4314:..\..\..\Source/tasks.c **** 			}
4315:..\..\..\Source/tasks.c **** 			else
4316:..\..\..\Source/tasks.c **** 			{
4317:..\..\..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4318:..\..\..\Source/tasks.c **** 			}
4319:..\..\..\Source/tasks.c **** 		}
4320:..\..\..\Source/tasks.c **** 		taskEXIT_CRITICAL();
 4599              		.loc 1 4320 0
 4600 00f2 FFF7FEFF 		bl	vPortExitCritical
4321:..\..\..\Source/tasks.c **** 
4322:..\..\..\Source/tasks.c **** 		return xReturn;
 4601              		.loc 1 4322 0
 4602 00f6 FB69     		ldr	r3, [r7, #28]
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 163


4323:..\..\..\Source/tasks.c **** 	}
 4603              		.loc 1 4323 0
 4604 00f8 1846     		mov	r0, r3
 4605 00fa 2037     		adds	r7, r7, #32
 4606              		.cfi_def_cfa_offset 8
 4607 00fc BD46     		mov	sp, r7
 4608              		.cfi_def_cfa_register 13
 4609              		@ sp needed
 4610 00fe 80BD     		pop	{r7, pc}
 4611              	.L314:
 4612              		.align	2
 4613              	.L313:
 4614 0100 E0000000 		.word	uxTopReadyPriority
 4615 0104 04000000 		.word	pxReadyTasksLists
 4616 0108 00000000 		.word	pxCurrentTCB
 4617 010c 04ED00E0 		.word	-536810236
 4618              		.cfi_endproc
 4619              	.LFE113:
 4620              		.size	xTaskGenericNotify, .-xTaskGenericNotify
 4621              		.section	.text.xTaskGenericNotifyFromISR,"ax",%progbits
 4622              		.align	2
 4623              		.global	xTaskGenericNotifyFromISR
 4624              		.thumb
 4625              		.thumb_func
 4626              		.type	xTaskGenericNotifyFromISR, %function
 4627              	xTaskGenericNotifyFromISR:
 4628              	.LFB114:
4324:..\..\..\Source/tasks.c **** 
4325:..\..\..\Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4326:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
4327:..\..\..\Source/tasks.c **** 
4328:..\..\..\Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4329:..\..\..\Source/tasks.c **** 
4330:..\..\..\Source/tasks.c **** 	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction 
4331:..\..\..\Source/tasks.c **** 	{
 4629              		.loc 1 4331 0
 4630              		.cfi_startproc
 4631              		@ args = 4, pretend = 0, frame = 48
 4632              		@ frame_needed = 1, uses_anonymous_args = 0
 4633 0000 80B5     		push	{r7, lr}
 4634              		.cfi_def_cfa_offset 8
 4635              		.cfi_offset 7, -8
 4636              		.cfi_offset 14, -4
 4637 0002 8CB0     		sub	sp, sp, #48
 4638              		.cfi_def_cfa_offset 56
 4639 0004 00AF     		add	r7, sp, #0
 4640              		.cfi_def_cfa_register 7
 4641 0006 F860     		str	r0, [r7, #12]
 4642 0008 B960     		str	r1, [r7, #8]
 4643 000a 3B60     		str	r3, [r7]
 4644 000c 1346     		mov	r3, r2
 4645 000e FB71     		strb	r3, [r7, #7]
4332:..\..\..\Source/tasks.c **** 	TCB_t * pxTCB;
4333:..\..\..\Source/tasks.c **** 	uint8_t ucOriginalNotifyState;
4334:..\..\..\Source/tasks.c **** 	BaseType_t xReturn = pdPASS;
 4646              		.loc 1 4334 0
 4647 0010 0123     		movs	r3, #1
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 164


 4648 0012 FB62     		str	r3, [r7, #44]
4335:..\..\..\Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
4336:..\..\..\Source/tasks.c **** 
4337:..\..\..\Source/tasks.c **** 		configASSERT( xTaskToNotify );
4338:..\..\..\Source/tasks.c **** 
4339:..\..\..\Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
4340:..\..\..\Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
4341:..\..\..\Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
4342:..\..\..\Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
4343:..\..\..\Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4344:..\..\..\Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
4345:..\..\..\Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4346:..\..\..\Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
4347:..\..\..\Source/tasks.c **** 		been assigned a priority above the configured maximum system call
4348:..\..\..\Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
4349:..\..\..\Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
4350:..\..\..\Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
4351:..\..\..\Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
4352:..\..\..\Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
4353:..\..\..\Source/tasks.c **** 		provided on the following link:
4354:..\..\..\Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4355:..\..\..\Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4356:..\..\..\Source/tasks.c **** 
4357:..\..\..\Source/tasks.c **** 		pxTCB = ( TCB_t * ) xTaskToNotify;
 4649              		.loc 1 4357 0
 4650 0014 FB68     		ldr	r3, [r7, #12]
 4651 0016 BB62     		str	r3, [r7, #40]
 4652              	.LBB52:
 4653              	.LBB53:
 253:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	(
 4654              		.loc 2 253 0
 4655              	@ 253 "../../../Source/portable/GCC/ARM_CM3/portmacro.h" 1
 4656 0018 EFF31182 			mrs r2, basepri											
 4657 001c 4FF0A003 		mov r3, #160												
 4658 0020 83F31188 		msr basepri, r3											
 4659 0024 BFF36F8F 		isb														
 4660 0028 BFF34F8F 		dsb														
 4661              	
 4662              	@ 0 "" 2
 4663              		.thumb
 4664 002c FA61     		str	r2, [r7, #28]
 4665 002e BB61     		str	r3, [r7, #24]
 265:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** }
 4666              		.loc 2 265 0
 4667 0030 FB69     		ldr	r3, [r7, #28]
 4668              	.LBE53:
 4669              	.LBE52:
4358:..\..\..\Source/tasks.c **** 
4359:..\..\..\Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4670              		.loc 1 4359 0
 4671 0032 7B62     		str	r3, [r7, #36]
4360:..\..\..\Source/tasks.c **** 		{
4361:..\..\..\Source/tasks.c **** 			if( pulPreviousNotificationValue != NULL )
 4672              		.loc 1 4361 0
 4673 0034 3B68     		ldr	r3, [r7]
 4674 0036 002B     		cmp	r3, #0
 4675 0038 03D0     		beq	.L317
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 165


4362:..\..\..\Source/tasks.c **** 			{
4363:..\..\..\Source/tasks.c **** 				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 4676              		.loc 1 4363 0
 4677 003a BB6A     		ldr	r3, [r7, #40]
 4678 003c 9A6C     		ldr	r2, [r3, #72]
 4679 003e 3B68     		ldr	r3, [r7]
 4680 0040 1A60     		str	r2, [r3]
 4681              	.L317:
4364:..\..\..\Source/tasks.c **** 			}
4365:..\..\..\Source/tasks.c **** 
4366:..\..\..\Source/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
 4682              		.loc 1 4366 0
 4683 0042 BB6A     		ldr	r3, [r7, #40]
 4684 0044 93F84C30 		ldrb	r3, [r3, #76]
 4685 0048 87F82330 		strb	r3, [r7, #35]
4367:..\..\..\Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 4686              		.loc 1 4367 0
 4687 004c BB6A     		ldr	r3, [r7, #40]
 4688 004e 0222     		movs	r2, #2
 4689 0050 83F84C20 		strb	r2, [r3, #76]
4368:..\..\..\Source/tasks.c **** 
4369:..\..\..\Source/tasks.c **** 			switch( eAction )
 4690              		.loc 1 4369 0
 4691 0054 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4692 0056 042B     		cmp	r3, #4
 4693 0058 28D8     		bhi	.L318
 4694 005a 01A2     		adr	r2, .L320
 4695 005c 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 4696              		.p2align 2
 4697              	.L320:
 4698 0060 AD000000 		.word	.L318+1
 4699 0064 75000000 		.word	.L321+1
 4700 0068 83000000 		.word	.L322+1
 4701 006c 8F000000 		.word	.L323+1
 4702 0070 97000000 		.word	.L324+1
 4703              		.p2align 1
 4704              	.L321:
4370:..\..\..\Source/tasks.c **** 			{
4371:..\..\..\Source/tasks.c **** 				case eSetBits	:
4372:..\..\..\Source/tasks.c **** 					pxTCB->ulNotifiedValue |= ulValue;
 4705              		.loc 1 4372 0
 4706 0074 BB6A     		ldr	r3, [r7, #40]
 4707 0076 9A6C     		ldr	r2, [r3, #72]
 4708 0078 BB68     		ldr	r3, [r7, #8]
 4709 007a 1A43     		orrs	r2, r2, r3
 4710 007c BB6A     		ldr	r3, [r7, #40]
 4711 007e 9A64     		str	r2, [r3, #72]
4373:..\..\..\Source/tasks.c **** 					break;
 4712              		.loc 1 4373 0
 4713 0080 14E0     		b	.L318
 4714              	.L322:
4374:..\..\..\Source/tasks.c **** 
4375:..\..\..\Source/tasks.c **** 				case eIncrement	:
4376:..\..\..\Source/tasks.c **** 					( pxTCB->ulNotifiedValue )++;
 4715              		.loc 1 4376 0
 4716 0082 BB6A     		ldr	r3, [r7, #40]
 4717 0084 9B6C     		ldr	r3, [r3, #72]
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 166


 4718 0086 5A1C     		adds	r2, r3, #1
 4719 0088 BB6A     		ldr	r3, [r7, #40]
 4720 008a 9A64     		str	r2, [r3, #72]
4377:..\..\..\Source/tasks.c **** 					break;
 4721              		.loc 1 4377 0
 4722 008c 0EE0     		b	.L318
 4723              	.L323:
4378:..\..\..\Source/tasks.c **** 
4379:..\..\..\Source/tasks.c **** 				case eSetValueWithOverwrite	:
4380:..\..\..\Source/tasks.c **** 					pxTCB->ulNotifiedValue = ulValue;
 4724              		.loc 1 4380 0
 4725 008e BB6A     		ldr	r3, [r7, #40]
 4726 0090 BA68     		ldr	r2, [r7, #8]
 4727 0092 9A64     		str	r2, [r3, #72]
4381:..\..\..\Source/tasks.c **** 					break;
 4728              		.loc 1 4381 0
 4729 0094 0AE0     		b	.L318
 4730              	.L324:
4382:..\..\..\Source/tasks.c **** 
4383:..\..\..\Source/tasks.c **** 				case eSetValueWithoutOverwrite :
4384:..\..\..\Source/tasks.c **** 					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 4731              		.loc 1 4384 0
 4732 0096 97F82330 		ldrb	r3, [r7, #35]	@ zero_extendqisi2
 4733 009a 022B     		cmp	r3, #2
 4734 009c 03D0     		beq	.L325
4385:..\..\..\Source/tasks.c **** 					{
4386:..\..\..\Source/tasks.c **** 						pxTCB->ulNotifiedValue = ulValue;
 4735              		.loc 1 4386 0
 4736 009e BB6A     		ldr	r3, [r7, #40]
 4737 00a0 BA68     		ldr	r2, [r7, #8]
 4738 00a2 9A64     		str	r2, [r3, #72]
4387:..\..\..\Source/tasks.c **** 					}
4388:..\..\..\Source/tasks.c **** 					else
4389:..\..\..\Source/tasks.c **** 					{
4390:..\..\..\Source/tasks.c **** 						/* The value could not be written to the task. */
4391:..\..\..\Source/tasks.c **** 						xReturn = pdFAIL;
4392:..\..\..\Source/tasks.c **** 					}
4393:..\..\..\Source/tasks.c **** 					break;
 4739              		.loc 1 4393 0
 4740 00a4 01E0     		b	.L333
 4741              	.L325:
4391:..\..\..\Source/tasks.c **** 					}
 4742              		.loc 1 4391 0
 4743 00a6 0023     		movs	r3, #0
 4744 00a8 FB62     		str	r3, [r7, #44]
 4745              	.L333:
 4746              		.loc 1 4393 0
 4747 00aa 00BF     		nop
 4748              	.L318:
4394:..\..\..\Source/tasks.c **** 
4395:..\..\..\Source/tasks.c **** 				case eNoAction :
4396:..\..\..\Source/tasks.c **** 					/* The task is being notified without its notify value being
4397:..\..\..\Source/tasks.c **** 					updated. */
4398:..\..\..\Source/tasks.c **** 					break;
4399:..\..\..\Source/tasks.c **** 			}
4400:..\..\..\Source/tasks.c **** 
4401:..\..\..\Source/tasks.c **** 			traceTASK_NOTIFY_FROM_ISR();
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 167


4402:..\..\..\Source/tasks.c **** 
4403:..\..\..\Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4404:..\..\..\Source/tasks.c **** 			notification then unblock it now. */
4405:..\..\..\Source/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 4749              		.loc 1 4405 0
 4750 00ac 97F82330 		ldrb	r3, [r7, #35]	@ zero_extendqisi2
 4751 00b0 012B     		cmp	r3, #1
 4752 00b2 39D1     		bne	.L327
4406:..\..\..\Source/tasks.c **** 			{
4407:..\..\..\Source/tasks.c **** 				/* The task should not have been on an event list. */
4408:..\..\..\Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4409:..\..\..\Source/tasks.c **** 
4410:..\..\..\Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 4753              		.loc 1 4410 0
 4754 00b4 214B     		ldr	r3, .L334
 4755 00b6 1B68     		ldr	r3, [r3]
 4756 00b8 002B     		cmp	r3, #0
 4757 00ba 1ED1     		bne	.L328
4411:..\..\..\Source/tasks.c **** 				{
4412:..\..\..\Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 4758              		.loc 1 4412 0
 4759 00bc BB6A     		ldr	r3, [r7, #40]
 4760 00be 0433     		adds	r3, r3, #4
 4761 00c0 1846     		mov	r0, r3
 4762 00c2 FFF7FEFF 		bl	uxListRemove
4413:..\..\..\Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 4763              		.loc 1 4413 0
 4764 00c6 BB6A     		ldr	r3, [r7, #40]
 4765 00c8 DB6A     		ldr	r3, [r3, #44]
 4766 00ca 1A46     		mov	r2, r3
 4767 00cc 0123     		movs	r3, #1
 4768 00ce 03FA02F2 		lsl	r2, r3, r2
 4769 00d2 1B4B     		ldr	r3, .L334+4
 4770 00d4 1B68     		ldr	r3, [r3]
 4771 00d6 1343     		orrs	r3, r3, r2
 4772 00d8 194A     		ldr	r2, .L334+4
 4773 00da 1360     		str	r3, [r2]
 4774 00dc BB6A     		ldr	r3, [r7, #40]
 4775 00de DA6A     		ldr	r2, [r3, #44]
 4776 00e0 1346     		mov	r3, r2
 4777 00e2 9B00     		lsls	r3, r3, #2
 4778 00e4 1344     		add	r3, r3, r2
 4779 00e6 9B00     		lsls	r3, r3, #2
 4780 00e8 164A     		ldr	r2, .L334+8
 4781 00ea 1A44     		add	r2, r2, r3
 4782 00ec BB6A     		ldr	r3, [r7, #40]
 4783 00ee 0433     		adds	r3, r3, #4
 4784 00f0 1046     		mov	r0, r2
 4785 00f2 1946     		mov	r1, r3
 4786 00f4 FFF7FEFF 		bl	vListInsertEnd
 4787 00f8 05E0     		b	.L329
 4788              	.L328:
4414:..\..\..\Source/tasks.c **** 				}
4415:..\..\..\Source/tasks.c **** 				else
4416:..\..\..\Source/tasks.c **** 				{
4417:..\..\..\Source/tasks.c **** 					/* The delayed and ready lists cannot be accessed, so hold
4418:..\..\..\Source/tasks.c **** 					this task pending until the scheduler is resumed. */
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 168


4419:..\..\..\Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 4789              		.loc 1 4419 0
 4790 00fa BB6A     		ldr	r3, [r7, #40]
 4791 00fc 1833     		adds	r3, r3, #24
 4792 00fe 1248     		ldr	r0, .L334+12
 4793 0100 1946     		mov	r1, r3
 4794 0102 FFF7FEFF 		bl	vListInsertEnd
 4795              	.L329:
4420:..\..\..\Source/tasks.c **** 				}
4421:..\..\..\Source/tasks.c **** 
4422:..\..\..\Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 4796              		.loc 1 4422 0
 4797 0106 BB6A     		ldr	r3, [r7, #40]
 4798 0108 DA6A     		ldr	r2, [r3, #44]
 4799 010a 104B     		ldr	r3, .L334+16
 4800 010c 1B68     		ldr	r3, [r3]
 4801 010e DB6A     		ldr	r3, [r3, #44]
 4802 0110 9A42     		cmp	r2, r3
 4803 0112 09D9     		bls	.L327
4423:..\..\..\Source/tasks.c **** 				{
4424:..\..\..\Source/tasks.c **** 					/* The notified task has a priority above the currently
4425:..\..\..\Source/tasks.c **** 					executing task so a yield is required. */
4426:..\..\..\Source/tasks.c **** 					if( pxHigherPriorityTaskWoken != NULL )
 4804              		.loc 1 4426 0
 4805 0114 BB6B     		ldr	r3, [r7, #56]
 4806 0116 002B     		cmp	r3, #0
 4807 0118 03D0     		beq	.L330
4427:..\..\..\Source/tasks.c **** 					{
4428:..\..\..\Source/tasks.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
 4808              		.loc 1 4428 0
 4809 011a BB6B     		ldr	r3, [r7, #56]
 4810 011c 0122     		movs	r2, #1
 4811 011e 1A60     		str	r2, [r3]
 4812 0120 02E0     		b	.L327
 4813              	.L330:
4429:..\..\..\Source/tasks.c **** 					}
4430:..\..\..\Source/tasks.c **** 					else
4431:..\..\..\Source/tasks.c **** 					{
4432:..\..\..\Source/tasks.c **** 						/* Mark that a yield is pending in case the user is not
4433:..\..\..\Source/tasks.c **** 						using the "xHigherPriorityTaskWoken" parameter to an ISR
4434:..\..\..\Source/tasks.c **** 						safe FreeRTOS function. */
4435:..\..\..\Source/tasks.c **** 						xYieldPending = pdTRUE;
 4814              		.loc 1 4435 0
 4815 0122 0B4B     		ldr	r3, .L334+20
 4816 0124 0122     		movs	r2, #1
 4817 0126 1A60     		str	r2, [r3]
 4818              	.L327:
 4819 0128 7B6A     		ldr	r3, [r7, #36]
 4820 012a 7B61     		str	r3, [r7, #20]
 4821              	.LBB54:
 4822              	.LBB55:
 4823              		.loc 2 271 0
 4824 012c 7B69     		ldr	r3, [r7, #20]
 4825              	@ 271 "../../../Source/portable/GCC/ARM_CM3/portmacro.h" 1
 4826 012e 83F31188 			msr basepri, r3	
 4827              	@ 0 "" 2
 4828              		.thumb
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 169


 4829              	.LBE55:
 4830              	.LBE54:
4436:..\..\..\Source/tasks.c **** 					}
4437:..\..\..\Source/tasks.c **** 				}
4438:..\..\..\Source/tasks.c **** 				else
4439:..\..\..\Source/tasks.c **** 				{
4440:..\..\..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4441:..\..\..\Source/tasks.c **** 				}
4442:..\..\..\Source/tasks.c **** 			}
4443:..\..\..\Source/tasks.c **** 		}
4444:..\..\..\Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
4445:..\..\..\Source/tasks.c **** 
4446:..\..\..\Source/tasks.c **** 		return xReturn;
 4831              		.loc 1 4446 0
 4832 0132 FB6A     		ldr	r3, [r7, #44]
4447:..\..\..\Source/tasks.c **** 	}
 4833              		.loc 1 4447 0
 4834 0134 1846     		mov	r0, r3
 4835 0136 3037     		adds	r7, r7, #48
 4836              		.cfi_def_cfa_offset 8
 4837 0138 BD46     		mov	sp, r7
 4838              		.cfi_def_cfa_register 13
 4839              		@ sp needed
 4840 013a 80BD     		pop	{r7, pc}
 4841              	.L335:
 4842              		.align	2
 4843              	.L334:
 4844 013c 00010000 		.word	uxSchedulerSuspended
 4845 0140 E0000000 		.word	uxTopReadyPriority
 4846 0144 04000000 		.word	pxReadyTasksLists
 4847 0148 98000000 		.word	xPendingReadyList
 4848 014c 00000000 		.word	pxCurrentTCB
 4849 0150 EC000000 		.word	xYieldPending
 4850              		.cfi_endproc
 4851              	.LFE114:
 4852              		.size	xTaskGenericNotifyFromISR, .-xTaskGenericNotifyFromISR
 4853              		.section	.text.vTaskNotifyGiveFromISR,"ax",%progbits
 4854              		.align	2
 4855              		.global	vTaskNotifyGiveFromISR
 4856              		.thumb
 4857              		.thumb_func
 4858              		.type	vTaskNotifyGiveFromISR, %function
 4859              	vTaskNotifyGiveFromISR:
 4860              	.LFB115:
4448:..\..\..\Source/tasks.c **** 
4449:..\..\..\Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4450:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
4451:..\..\..\Source/tasks.c **** 
4452:..\..\..\Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4453:..\..\..\Source/tasks.c **** 
4454:..\..\..\Source/tasks.c **** 	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
4455:..\..\..\Source/tasks.c **** 	{
 4861              		.loc 1 4455 0
 4862              		.cfi_startproc
 4863              		@ args = 0, pretend = 0, frame = 32
 4864              		@ frame_needed = 1, uses_anonymous_args = 0
 4865 0000 80B5     		push	{r7, lr}
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 170


 4866              		.cfi_def_cfa_offset 8
 4867              		.cfi_offset 7, -8
 4868              		.cfi_offset 14, -4
 4869 0002 88B0     		sub	sp, sp, #32
 4870              		.cfi_def_cfa_offset 40
 4871 0004 00AF     		add	r7, sp, #0
 4872              		.cfi_def_cfa_register 7
 4873 0006 7860     		str	r0, [r7, #4]
 4874 0008 3960     		str	r1, [r7]
4456:..\..\..\Source/tasks.c **** 	TCB_t * pxTCB;
4457:..\..\..\Source/tasks.c **** 	uint8_t ucOriginalNotifyState;
4458:..\..\..\Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
4459:..\..\..\Source/tasks.c **** 
4460:..\..\..\Source/tasks.c **** 		configASSERT( xTaskToNotify );
4461:..\..\..\Source/tasks.c **** 
4462:..\..\..\Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
4463:..\..\..\Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
4464:..\..\..\Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
4465:..\..\..\Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
4466:..\..\..\Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4467:..\..\..\Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
4468:..\..\..\Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4469:..\..\..\Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
4470:..\..\..\Source/tasks.c **** 		been assigned a priority above the configured maximum system call
4471:..\..\..\Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
4472:..\..\..\Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
4473:..\..\..\Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
4474:..\..\..\Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
4475:..\..\..\Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
4476:..\..\..\Source/tasks.c **** 		provided on the following link:
4477:..\..\..\Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4478:..\..\..\Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4479:..\..\..\Source/tasks.c **** 
4480:..\..\..\Source/tasks.c **** 		pxTCB = ( TCB_t * ) xTaskToNotify;
 4875              		.loc 1 4480 0
 4876 000a 7B68     		ldr	r3, [r7, #4]
 4877 000c FB61     		str	r3, [r7, #28]
 4878              	.LBB56:
 4879              	.LBB57:
 253:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** 	(
 4880              		.loc 2 253 0
 4881              	@ 253 "../../../Source/portable/GCC/ARM_CM3/portmacro.h" 1
 4882 000e EFF31182 			mrs r2, basepri											
 4883 0012 4FF0A003 		mov r3, #160												
 4884 0016 83F31188 		msr basepri, r3											
 4885 001a BFF36F8F 		isb														
 4886 001e BFF34F8F 		dsb														
 4887              	
 4888              	@ 0 "" 2
 4889              		.thumb
 4890 0022 3A61     		str	r2, [r7, #16]
 4891 0024 FB60     		str	r3, [r7, #12]
 265:../../../Source/portable/GCC/ARM_CM3/portmacro.h **** }
 4892              		.loc 2 265 0
 4893 0026 3B69     		ldr	r3, [r7, #16]
 4894              	.LBE57:
 4895              	.LBE56:
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 171


4481:..\..\..\Source/tasks.c **** 
4482:..\..\..\Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4896              		.loc 1 4482 0
 4897 0028 BB61     		str	r3, [r7, #24]
4483:..\..\..\Source/tasks.c **** 		{
4484:..\..\..\Source/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
 4898              		.loc 1 4484 0
 4899 002a FB69     		ldr	r3, [r7, #28]
 4900 002c 93F84C30 		ldrb	r3, [r3, #76]
 4901 0030 FB75     		strb	r3, [r7, #23]
4485:..\..\..\Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 4902              		.loc 1 4485 0
 4903 0032 FB69     		ldr	r3, [r7, #28]
 4904 0034 0222     		movs	r2, #2
 4905 0036 83F84C20 		strb	r2, [r3, #76]
4486:..\..\..\Source/tasks.c **** 
4487:..\..\..\Source/tasks.c **** 			/* 'Giving' is equivalent to incrementing a count in a counting
4488:..\..\..\Source/tasks.c **** 			semaphore. */
4489:..\..\..\Source/tasks.c **** 			( pxTCB->ulNotifiedValue )++;
 4906              		.loc 1 4489 0
 4907 003a FB69     		ldr	r3, [r7, #28]
 4908 003c 9B6C     		ldr	r3, [r3, #72]
 4909 003e 5A1C     		adds	r2, r3, #1
 4910 0040 FB69     		ldr	r3, [r7, #28]
 4911 0042 9A64     		str	r2, [r3, #72]
4490:..\..\..\Source/tasks.c **** 
4491:..\..\..\Source/tasks.c **** 			traceTASK_NOTIFY_GIVE_FROM_ISR();
4492:..\..\..\Source/tasks.c **** 
4493:..\..\..\Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4494:..\..\..\Source/tasks.c **** 			notification then unblock it now. */
4495:..\..\..\Source/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 4912              		.loc 1 4495 0
 4913 0044 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 4914 0046 012B     		cmp	r3, #1
 4915 0048 39D1     		bne	.L338
4496:..\..\..\Source/tasks.c **** 			{
4497:..\..\..\Source/tasks.c **** 				/* The task should not have been on an event list. */
4498:..\..\..\Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4499:..\..\..\Source/tasks.c **** 
4500:..\..\..\Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 4916              		.loc 1 4500 0
 4917 004a 214B     		ldr	r3, .L343
 4918 004c 1B68     		ldr	r3, [r3]
 4919 004e 002B     		cmp	r3, #0
 4920 0050 1ED1     		bne	.L339
4501:..\..\..\Source/tasks.c **** 				{
4502:..\..\..\Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 4921              		.loc 1 4502 0
 4922 0052 FB69     		ldr	r3, [r7, #28]
 4923 0054 0433     		adds	r3, r3, #4
 4924 0056 1846     		mov	r0, r3
 4925 0058 FFF7FEFF 		bl	uxListRemove
4503:..\..\..\Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 4926              		.loc 1 4503 0
 4927 005c FB69     		ldr	r3, [r7, #28]
 4928 005e DB6A     		ldr	r3, [r3, #44]
 4929 0060 1A46     		mov	r2, r3
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 172


 4930 0062 0123     		movs	r3, #1
 4931 0064 03FA02F2 		lsl	r2, r3, r2
 4932 0068 1A4B     		ldr	r3, .L343+4
 4933 006a 1B68     		ldr	r3, [r3]
 4934 006c 1343     		orrs	r3, r3, r2
 4935 006e 194A     		ldr	r2, .L343+4
 4936 0070 1360     		str	r3, [r2]
 4937 0072 FB69     		ldr	r3, [r7, #28]
 4938 0074 DA6A     		ldr	r2, [r3, #44]
 4939 0076 1346     		mov	r3, r2
 4940 0078 9B00     		lsls	r3, r3, #2
 4941 007a 1344     		add	r3, r3, r2
 4942 007c 9B00     		lsls	r3, r3, #2
 4943 007e 164A     		ldr	r2, .L343+8
 4944 0080 1A44     		add	r2, r2, r3
 4945 0082 FB69     		ldr	r3, [r7, #28]
 4946 0084 0433     		adds	r3, r3, #4
 4947 0086 1046     		mov	r0, r2
 4948 0088 1946     		mov	r1, r3
 4949 008a FFF7FEFF 		bl	vListInsertEnd
 4950 008e 05E0     		b	.L340
 4951              	.L339:
4504:..\..\..\Source/tasks.c **** 				}
4505:..\..\..\Source/tasks.c **** 				else
4506:..\..\..\Source/tasks.c **** 				{
4507:..\..\..\Source/tasks.c **** 					/* The delayed and ready lists cannot be accessed, so hold
4508:..\..\..\Source/tasks.c **** 					this task pending until the scheduler is resumed. */
4509:..\..\..\Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 4952              		.loc 1 4509 0
 4953 0090 FB69     		ldr	r3, [r7, #28]
 4954 0092 1833     		adds	r3, r3, #24
 4955 0094 1148     		ldr	r0, .L343+12
 4956 0096 1946     		mov	r1, r3
 4957 0098 FFF7FEFF 		bl	vListInsertEnd
 4958              	.L340:
4510:..\..\..\Source/tasks.c **** 				}
4511:..\..\..\Source/tasks.c **** 
4512:..\..\..\Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 4959              		.loc 1 4512 0
 4960 009c FB69     		ldr	r3, [r7, #28]
 4961 009e DA6A     		ldr	r2, [r3, #44]
 4962 00a0 0F4B     		ldr	r3, .L343+16
 4963 00a2 1B68     		ldr	r3, [r3]
 4964 00a4 DB6A     		ldr	r3, [r3, #44]
 4965 00a6 9A42     		cmp	r2, r3
 4966 00a8 09D9     		bls	.L338
4513:..\..\..\Source/tasks.c **** 				{
4514:..\..\..\Source/tasks.c **** 					/* The notified task has a priority above the currently
4515:..\..\..\Source/tasks.c **** 					executing task so a yield is required. */
4516:..\..\..\Source/tasks.c **** 					if( pxHigherPriorityTaskWoken != NULL )
 4967              		.loc 1 4516 0
 4968 00aa 3B68     		ldr	r3, [r7]
 4969 00ac 002B     		cmp	r3, #0
 4970 00ae 03D0     		beq	.L341
4517:..\..\..\Source/tasks.c **** 					{
4518:..\..\..\Source/tasks.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
 4971              		.loc 1 4518 0
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 173


 4972 00b0 3B68     		ldr	r3, [r7]
 4973 00b2 0122     		movs	r2, #1
 4974 00b4 1A60     		str	r2, [r3]
 4975 00b6 02E0     		b	.L338
 4976              	.L341:
4519:..\..\..\Source/tasks.c **** 					}
4520:..\..\..\Source/tasks.c **** 					else
4521:..\..\..\Source/tasks.c **** 					{
4522:..\..\..\Source/tasks.c **** 						/* Mark that a yield is pending in case the user is not
4523:..\..\..\Source/tasks.c **** 						using the "xHigherPriorityTaskWoken" parameter in an ISR
4524:..\..\..\Source/tasks.c **** 						safe FreeRTOS function. */
4525:..\..\..\Source/tasks.c **** 						xYieldPending = pdTRUE;
 4977              		.loc 1 4525 0
 4978 00b8 0A4B     		ldr	r3, .L343+20
 4979 00ba 0122     		movs	r2, #1
 4980 00bc 1A60     		str	r2, [r3]
 4981              	.L338:
 4982 00be BB69     		ldr	r3, [r7, #24]
 4983 00c0 BB60     		str	r3, [r7, #8]
 4984              	.LBB58:
 4985              	.LBB59:
 4986              		.loc 2 271 0
 4987 00c2 BB68     		ldr	r3, [r7, #8]
 4988              	@ 271 "../../../Source/portable/GCC/ARM_CM3/portmacro.h" 1
 4989 00c4 83F31188 			msr basepri, r3	
 4990              	@ 0 "" 2
 4991              		.thumb
 4992              	.LBE59:
 4993              	.LBE58:
4526:..\..\..\Source/tasks.c **** 					}
4527:..\..\..\Source/tasks.c **** 				}
4528:..\..\..\Source/tasks.c **** 				else
4529:..\..\..\Source/tasks.c **** 				{
4530:..\..\..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4531:..\..\..\Source/tasks.c **** 				}
4532:..\..\..\Source/tasks.c **** 			}
4533:..\..\..\Source/tasks.c **** 		}
4534:..\..\..\Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
4535:..\..\..\Source/tasks.c **** 	}
 4994              		.loc 1 4535 0
 4995 00c8 2037     		adds	r7, r7, #32
 4996              		.cfi_def_cfa_offset 8
 4997 00ca BD46     		mov	sp, r7
 4998              		.cfi_def_cfa_register 13
 4999              		@ sp needed
 5000 00cc 80BD     		pop	{r7, pc}
 5001              	.L344:
 5002 00ce 00BF     		.align	2
 5003              	.L343:
 5004 00d0 00010000 		.word	uxSchedulerSuspended
 5005 00d4 E0000000 		.word	uxTopReadyPriority
 5006 00d8 04000000 		.word	pxReadyTasksLists
 5007 00dc 98000000 		.word	xPendingReadyList
 5008 00e0 00000000 		.word	pxCurrentTCB
 5009 00e4 EC000000 		.word	xYieldPending
 5010              		.cfi_endproc
 5011              	.LFE115:
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 174


 5012              		.size	vTaskNotifyGiveFromISR, .-vTaskNotifyGiveFromISR
 5013              		.section	.text.xTaskNotifyStateClear,"ax",%progbits
 5014              		.align	2
 5015              		.global	xTaskNotifyStateClear
 5016              		.thumb
 5017              		.thumb_func
 5018              		.type	xTaskNotifyStateClear, %function
 5019              	xTaskNotifyStateClear:
 5020              	.LFB116:
4536:..\..\..\Source/tasks.c **** 
4537:..\..\..\Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4538:..\..\..\Source/tasks.c **** 
4539:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
4540:..\..\..\Source/tasks.c **** 
4541:..\..\..\Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4542:..\..\..\Source/tasks.c **** 
4543:..\..\..\Source/tasks.c **** 	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
4544:..\..\..\Source/tasks.c **** 	{
 5021              		.loc 1 4544 0
 5022              		.cfi_startproc
 5023              		@ args = 0, pretend = 0, frame = 16
 5024              		@ frame_needed = 1, uses_anonymous_args = 0
 5025 0000 80B5     		push	{r7, lr}
 5026              		.cfi_def_cfa_offset 8
 5027              		.cfi_offset 7, -8
 5028              		.cfi_offset 14, -4
 5029 0002 84B0     		sub	sp, sp, #16
 5030              		.cfi_def_cfa_offset 24
 5031 0004 00AF     		add	r7, sp, #0
 5032              		.cfi_def_cfa_register 7
 5033 0006 7860     		str	r0, [r7, #4]
4545:..\..\..\Source/tasks.c **** 	TCB_t *pxTCB;
4546:..\..\..\Source/tasks.c **** 	BaseType_t xReturn;
4547:..\..\..\Source/tasks.c **** 
4548:..\..\..\Source/tasks.c **** 		/* If null is passed in here then it is the calling task that is having
4549:..\..\..\Source/tasks.c **** 		its notification state cleared. */
4550:..\..\..\Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
 5034              		.loc 1 4550 0
 5035 0008 7B68     		ldr	r3, [r7, #4]
 5036 000a 002B     		cmp	r3, #0
 5037 000c 02D1     		bne	.L346
 5038              		.loc 1 4550 0 is_stmt 0 discriminator 1
 5039 000e 0E4B     		ldr	r3, .L351
 5040 0010 1B68     		ldr	r3, [r3]
 5041 0012 00E0     		b	.L347
 5042              	.L346:
 5043              		.loc 1 4550 0 discriminator 2
 5044 0014 7B68     		ldr	r3, [r7, #4]
 5045              	.L347:
 5046              		.loc 1 4550 0 discriminator 4
 5047 0016 BB60     		str	r3, [r7, #8]
4551:..\..\..\Source/tasks.c **** 
4552:..\..\..\Source/tasks.c **** 		taskENTER_CRITICAL();
 5048              		.loc 1 4552 0 is_stmt 1 discriminator 4
 5049 0018 FFF7FEFF 		bl	vPortEnterCritical
4553:..\..\..\Source/tasks.c **** 		{
4554:..\..\..\Source/tasks.c **** 			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 175


 5050              		.loc 1 4554 0 discriminator 4
 5051 001c BB68     		ldr	r3, [r7, #8]
 5052 001e 93F84C30 		ldrb	r3, [r3, #76]
 5053 0022 DBB2     		uxtb	r3, r3
 5054 0024 022B     		cmp	r3, #2
 5055 0026 06D1     		bne	.L348
4555:..\..\..\Source/tasks.c **** 			{
4556:..\..\..\Source/tasks.c **** 				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 5056              		.loc 1 4556 0
 5057 0028 BB68     		ldr	r3, [r7, #8]
 5058 002a 0022     		movs	r2, #0
 5059 002c 83F84C20 		strb	r2, [r3, #76]
4557:..\..\..\Source/tasks.c **** 				xReturn = pdPASS;
 5060              		.loc 1 4557 0
 5061 0030 0123     		movs	r3, #1
 5062 0032 FB60     		str	r3, [r7, #12]
 5063 0034 01E0     		b	.L349
 5064              	.L348:
4558:..\..\..\Source/tasks.c **** 			}
4559:..\..\..\Source/tasks.c **** 			else
4560:..\..\..\Source/tasks.c **** 			{
4561:..\..\..\Source/tasks.c **** 				xReturn = pdFAIL;
 5065              		.loc 1 4561 0
 5066 0036 0023     		movs	r3, #0
 5067 0038 FB60     		str	r3, [r7, #12]
 5068              	.L349:
4562:..\..\..\Source/tasks.c **** 			}
4563:..\..\..\Source/tasks.c **** 		}
4564:..\..\..\Source/tasks.c **** 		taskEXIT_CRITICAL();
 5069              		.loc 1 4564 0
 5070 003a FFF7FEFF 		bl	vPortExitCritical
4565:..\..\..\Source/tasks.c **** 
4566:..\..\..\Source/tasks.c **** 		return xReturn;
 5071              		.loc 1 4566 0
 5072 003e FB68     		ldr	r3, [r7, #12]
4567:..\..\..\Source/tasks.c **** 	}
 5073              		.loc 1 4567 0
 5074 0040 1846     		mov	r0, r3
 5075 0042 1037     		adds	r7, r7, #16
 5076              		.cfi_def_cfa_offset 8
 5077 0044 BD46     		mov	sp, r7
 5078              		.cfi_def_cfa_register 13
 5079              		@ sp needed
 5080 0046 80BD     		pop	{r7, pc}
 5081              	.L352:
 5082              		.align	2
 5083              	.L351:
 5084 0048 00000000 		.word	pxCurrentTCB
 5085              		.cfi_endproc
 5086              	.LFE116:
 5087              		.size	xTaskNotifyStateClear, .-xTaskNotifyStateClear
 5088              		.section	.text.prvAddCurrentTaskToDelayedList,"ax",%progbits
 5089              		.align	2
 5090              		.thumb
 5091              		.thumb_func
 5092              		.type	prvAddCurrentTaskToDelayedList, %function
 5093              	prvAddCurrentTaskToDelayedList:
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 176


 5094              	.LFB117:
4568:..\..\..\Source/tasks.c **** 
4569:..\..\..\Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4570:..\..\..\Source/tasks.c **** /*-----------------------------------------------------------*/
4571:..\..\..\Source/tasks.c **** 
4572:..\..\..\Source/tasks.c **** 
4573:..\..\..\Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockInde
4574:..\..\..\Source/tasks.c **** {
 5095              		.loc 1 4574 0
 5096              		.cfi_startproc
 5097              		@ args = 0, pretend = 0, frame = 16
 5098              		@ frame_needed = 1, uses_anonymous_args = 0
 5099 0000 80B5     		push	{r7, lr}
 5100              		.cfi_def_cfa_offset 8
 5101              		.cfi_offset 7, -8
 5102              		.cfi_offset 14, -4
 5103 0002 84B0     		sub	sp, sp, #16
 5104              		.cfi_def_cfa_offset 24
 5105 0004 00AF     		add	r7, sp, #0
 5106              		.cfi_def_cfa_register 7
 5107 0006 7860     		str	r0, [r7, #4]
 5108 0008 3960     		str	r1, [r7]
4575:..\..\..\Source/tasks.c **** TickType_t xTimeToWake;
4576:..\..\..\Source/tasks.c **** const TickType_t xConstTickCount = xTickCount;
 5109              		.loc 1 4576 0
 5110 000a 284B     		ldr	r3, .L358
 5111 000c 1B68     		ldr	r3, [r3]
 5112 000e FB60     		str	r3, [r7, #12]
4577:..\..\..\Source/tasks.c **** 
4578:..\..\..\Source/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
4579:..\..\..\Source/tasks.c **** 	{
4580:..\..\..\Source/tasks.c **** 		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
4581:..\..\..\Source/tasks.c **** 		reset to pdFALSE so it can be detected as having been set to pdTRUE
4582:..\..\..\Source/tasks.c **** 		when the task leaves the Blocked state. */
4583:..\..\..\Source/tasks.c **** 		pxCurrentTCB->ucDelayAborted = pdFALSE;
4584:..\..\..\Source/tasks.c **** 	}
4585:..\..\..\Source/tasks.c **** 	#endif
4586:..\..\..\Source/tasks.c **** 
4587:..\..\..\Source/tasks.c **** 	/* Remove the task from the ready list before adding it to the blocked list
4588:..\..\..\Source/tasks.c **** 	as the same list item is used for both lists. */
4589:..\..\..\Source/tasks.c **** 	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 5113              		.loc 1 4589 0
 5114 0010 274B     		ldr	r3, .L358+4
 5115 0012 1B68     		ldr	r3, [r3]
 5116 0014 0433     		adds	r3, r3, #4
 5117 0016 1846     		mov	r0, r3
 5118 0018 FFF7FEFF 		bl	uxListRemove
 5119 001c 0346     		mov	r3, r0
 5120 001e 002B     		cmp	r3, #0
 5121 0020 0BD1     		bne	.L354
4590:..\..\..\Source/tasks.c **** 	{
4591:..\..\..\Source/tasks.c **** 		/* The current task must be in a ready list, so there is no need to
4592:..\..\..\Source/tasks.c **** 		check, and the port reset macro can be called directly. */
4593:..\..\..\Source/tasks.c **** 		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 5122              		.loc 1 4593 0
 5123 0022 234B     		ldr	r3, .L358+4
 5124 0024 1B68     		ldr	r3, [r3]
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 177


 5125 0026 DB6A     		ldr	r3, [r3, #44]
 5126 0028 1A46     		mov	r2, r3
 5127 002a 0123     		movs	r3, #1
 5128 002c 9340     		lsls	r3, r3, r2
 5129 002e DA43     		mvns	r2, r3
 5130 0030 204B     		ldr	r3, .L358+8
 5131 0032 1B68     		ldr	r3, [r3]
 5132 0034 1340     		ands	r3, r3, r2
 5133 0036 1F4A     		ldr	r2, .L358+8
 5134 0038 1360     		str	r3, [r2]
 5135              	.L354:
4594:..\..\..\Source/tasks.c **** 	}
4595:..\..\..\Source/tasks.c **** 	else
4596:..\..\..\Source/tasks.c **** 	{
4597:..\..\..\Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
4598:..\..\..\Source/tasks.c **** 	}
4599:..\..\..\Source/tasks.c **** 
4600:..\..\..\Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
4601:..\..\..\Source/tasks.c **** 	{
4602:..\..\..\Source/tasks.c **** 		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 5136              		.loc 1 4602 0
 5137 003a 7B68     		ldr	r3, [r7, #4]
 5138 003c B3F1FF3F 		cmp	r3, #-1
 5139 0040 0AD1     		bne	.L355
 5140              		.loc 1 4602 0 is_stmt 0 discriminator 1
 5141 0042 3B68     		ldr	r3, [r7]
 5142 0044 002B     		cmp	r3, #0
 5143 0046 07D0     		beq	.L355
4603:..\..\..\Source/tasks.c **** 		{
4604:..\..\..\Source/tasks.c **** 			/* Add the task to the suspended task list instead of a delayed task
4605:..\..\..\Source/tasks.c **** 			list to ensure it is not woken by a timing event.  It will block
4606:..\..\..\Source/tasks.c **** 			indefinitely. */
4607:..\..\..\Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 5144              		.loc 1 4607 0 is_stmt 1
 5145 0048 194B     		ldr	r3, .L358+4
 5146 004a 1B68     		ldr	r3, [r3]
 5147 004c 0433     		adds	r3, r3, #4
 5148 004e 1A48     		ldr	r0, .L358+12
 5149 0050 1946     		mov	r1, r3
 5150 0052 FFF7FEFF 		bl	vListInsertEnd
 5151 0056 26E0     		b	.L353
 5152              	.L355:
4608:..\..\..\Source/tasks.c **** 		}
4609:..\..\..\Source/tasks.c **** 		else
4610:..\..\..\Source/tasks.c **** 		{
4611:..\..\..\Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event
4612:..\..\..\Source/tasks.c **** 			does not occur.  This may overflow but this doesn't matter, the
4613:..\..\..\Source/tasks.c **** 			kernel will manage it correctly. */
4614:..\..\..\Source/tasks.c **** 			xTimeToWake = xConstTickCount + xTicksToWait;
 5153              		.loc 1 4614 0
 5154 0058 FA68     		ldr	r2, [r7, #12]
 5155 005a 7B68     		ldr	r3, [r7, #4]
 5156 005c 1344     		add	r3, r3, r2
 5157 005e BB60     		str	r3, [r7, #8]
4615:..\..\..\Source/tasks.c **** 
4616:..\..\..\Source/tasks.c **** 			/* The list item will be inserted in wake time order. */
4617:..\..\..\Source/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 178


 5158              		.loc 1 4617 0
 5159 0060 134B     		ldr	r3, .L358+4
 5160 0062 1B68     		ldr	r3, [r3]
 5161 0064 BA68     		ldr	r2, [r7, #8]
 5162 0066 5A60     		str	r2, [r3, #4]
4618:..\..\..\Source/tasks.c **** 
4619:..\..\..\Source/tasks.c **** 			if( xTimeToWake < xConstTickCount )
 5163              		.loc 1 4619 0
 5164 0068 BA68     		ldr	r2, [r7, #8]
 5165 006a FB68     		ldr	r3, [r7, #12]
 5166 006c 9A42     		cmp	r2, r3
 5167 006e 09D2     		bcs	.L357
4620:..\..\..\Source/tasks.c **** 			{
4621:..\..\..\Source/tasks.c **** 				/* Wake time has overflowed.  Place this item in the overflow
4622:..\..\..\Source/tasks.c **** 				list. */
4623:..\..\..\Source/tasks.c **** 				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 5168              		.loc 1 4623 0
 5169 0070 124B     		ldr	r3, .L358+16
 5170 0072 1A68     		ldr	r2, [r3]
 5171 0074 0E4B     		ldr	r3, .L358+4
 5172 0076 1B68     		ldr	r3, [r3]
 5173 0078 0433     		adds	r3, r3, #4
 5174 007a 1046     		mov	r0, r2
 5175 007c 1946     		mov	r1, r3
 5176 007e FFF7FEFF 		bl	vListInsert
 5177 0082 10E0     		b	.L353
 5178              	.L357:
4624:..\..\..\Source/tasks.c **** 			}
4625:..\..\..\Source/tasks.c **** 			else
4626:..\..\..\Source/tasks.c **** 			{
4627:..\..\..\Source/tasks.c **** 				/* The wake time has not overflowed, so the current block list
4628:..\..\..\Source/tasks.c **** 				is used. */
4629:..\..\..\Source/tasks.c **** 				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 5179              		.loc 1 4629 0
 5180 0084 0E4B     		ldr	r3, .L358+20
 5181 0086 1A68     		ldr	r2, [r3]
 5182 0088 094B     		ldr	r3, .L358+4
 5183 008a 1B68     		ldr	r3, [r3]
 5184 008c 0433     		adds	r3, r3, #4
 5185 008e 1046     		mov	r0, r2
 5186 0090 1946     		mov	r1, r3
 5187 0092 FFF7FEFF 		bl	vListInsert
4630:..\..\..\Source/tasks.c **** 
4631:..\..\..\Source/tasks.c **** 				/* If the task entering the blocked state was placed at the
4632:..\..\..\Source/tasks.c **** 				head of the list of blocked tasks then xNextTaskUnblockTime
4633:..\..\..\Source/tasks.c **** 				needs to be updated too. */
4634:..\..\..\Source/tasks.c **** 				if( xTimeToWake < xNextTaskUnblockTime )
 5188              		.loc 1 4634 0
 5189 0096 0B4B     		ldr	r3, .L358+24
 5190 0098 1B68     		ldr	r3, [r3]
 5191 009a BA68     		ldr	r2, [r7, #8]
 5192 009c 9A42     		cmp	r2, r3
 5193 009e 02D2     		bcs	.L353
4635:..\..\..\Source/tasks.c **** 				{
4636:..\..\..\Source/tasks.c **** 					xNextTaskUnblockTime = xTimeToWake;
 5194              		.loc 1 4636 0
 5195 00a0 084A     		ldr	r2, .L358+24
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 179


 5196 00a2 BB68     		ldr	r3, [r7, #8]
 5197 00a4 1360     		str	r3, [r2]
 5198              	.L353:
4637:..\..\..\Source/tasks.c **** 				}
4638:..\..\..\Source/tasks.c **** 				else
4639:..\..\..\Source/tasks.c **** 				{
4640:..\..\..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4641:..\..\..\Source/tasks.c **** 				}
4642:..\..\..\Source/tasks.c **** 			}
4643:..\..\..\Source/tasks.c **** 		}
4644:..\..\..\Source/tasks.c **** 	}
4645:..\..\..\Source/tasks.c **** 	#else /* INCLUDE_vTaskSuspend */
4646:..\..\..\Source/tasks.c **** 	{
4647:..\..\..\Source/tasks.c **** 		/* Calculate the time at which the task should be woken if the event
4648:..\..\..\Source/tasks.c **** 		does not occur.  This may overflow but this doesn't matter, the kernel
4649:..\..\..\Source/tasks.c **** 		will manage it correctly. */
4650:..\..\..\Source/tasks.c **** 		xTimeToWake = xConstTickCount + xTicksToWait;
4651:..\..\..\Source/tasks.c **** 
4652:..\..\..\Source/tasks.c **** 		/* The list item will be inserted in wake time order. */
4653:..\..\..\Source/tasks.c **** 		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
4654:..\..\..\Source/tasks.c **** 
4655:..\..\..\Source/tasks.c **** 		if( xTimeToWake < xConstTickCount )
4656:..\..\..\Source/tasks.c **** 		{
4657:..\..\..\Source/tasks.c **** 			/* Wake time has overflowed.  Place this item in the overflow list. */
4658:..\..\..\Source/tasks.c **** 			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
4659:..\..\..\Source/tasks.c **** 		}
4660:..\..\..\Source/tasks.c **** 		else
4661:..\..\..\Source/tasks.c **** 		{
4662:..\..\..\Source/tasks.c **** 			/* The wake time has not overflowed, so the current block list is used. */
4663:..\..\..\Source/tasks.c **** 			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
4664:..\..\..\Source/tasks.c **** 
4665:..\..\..\Source/tasks.c **** 			/* If the task entering the blocked state was placed at the head of the
4666:..\..\..\Source/tasks.c **** 			list of blocked tasks then xNextTaskUnblockTime needs to be updated
4667:..\..\..\Source/tasks.c **** 			too. */
4668:..\..\..\Source/tasks.c **** 			if( xTimeToWake < xNextTaskUnblockTime )
4669:..\..\..\Source/tasks.c **** 			{
4670:..\..\..\Source/tasks.c **** 				xNextTaskUnblockTime = xTimeToWake;
4671:..\..\..\Source/tasks.c **** 			}
4672:..\..\..\Source/tasks.c **** 			else
4673:..\..\..\Source/tasks.c **** 			{
4674:..\..\..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4675:..\..\..\Source/tasks.c **** 			}
4676:..\..\..\Source/tasks.c **** 		}
4677:..\..\..\Source/tasks.c **** 
4678:..\..\..\Source/tasks.c **** 		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
4679:..\..\..\Source/tasks.c **** 		( void ) xCanBlockIndefinitely;
4680:..\..\..\Source/tasks.c **** 	}
4681:..\..\..\Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
4682:..\..\..\Source/tasks.c **** }
 5199              		.loc 1 4682 0
 5200 00a6 1037     		adds	r7, r7, #16
 5201              		.cfi_def_cfa_offset 8
 5202 00a8 BD46     		mov	sp, r7
 5203              		.cfi_def_cfa_register 13
 5204              		@ sp needed
 5205 00aa 80BD     		pop	{r7, pc}
 5206              	.L359:
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 180


 5207              		.align	2
 5208              	.L358:
 5209 00ac DC000000 		.word	xTickCount
 5210 00b0 00000000 		.word	pxCurrentTCB
 5211 00b4 E0000000 		.word	uxTopReadyPriority
 5212 00b8 C4000000 		.word	xSuspendedTaskList
 5213 00bc 94000000 		.word	pxOverflowDelayedTaskList
 5214 00c0 90000000 		.word	pxDelayedTaskList
 5215 00c4 F8000000 		.word	xNextTaskUnblockTime
 5216              		.cfi_endproc
 5217              	.LFE117:
 5218              		.size	prvAddCurrentTaskToDelayedList, .-prvAddCurrentTaskToDelayedList
 5219              		.text
 5220              	.Letext0:
 5221              		.file 3 "c:\\program files (x86)\\cypress\\psoc creator\\4.0\\psoc creator\\import\\gnu\\arm\\4.9.
 5222              		.file 4 "c:\\program files (x86)\\cypress\\psoc creator\\4.0\\psoc creator\\import\\gnu\\arm\\4.9.
 5223              		.file 5 "c:\\program files (x86)\\cypress\\psoc creator\\4.0\\psoc creator\\import\\gnu\\arm\\4.9.
 5224              		.file 6 "../../../Source/include/projdefs.h"
 5225              		.file 7 "../../../Source/include/list.h"
 5226              		.file 8 "../../../Source/include/task.h"
 5227              		.file 9 "Generated_Source\\PSoC5/core_cm3.h"
 5228              		.section	.debug_info,"",%progbits
 5229              	.Ldebug_info0:
 5230 0000 DC150000 		.4byte	0x15dc
 5231 0004 0400     		.2byte	0x4
 5232 0006 00000000 		.4byte	.Ldebug_abbrev0
 5233 000a 04       		.byte	0x4
 5234 000b 01       		.uleb128 0x1
 5235 000c 7D070000 		.4byte	.LASF214
 5236 0010 01       		.byte	0x1
 5237 0011 140D0000 		.4byte	.LASF215
 5238 0015 1A060000 		.4byte	.LASF216
 5239 0019 00000000 		.4byte	.Ldebug_ranges0+0
 5240 001d 00000000 		.4byte	0
 5241 0021 00000000 		.4byte	.Ldebug_line0
 5242 0025 02       		.uleb128 0x2
 5243 0026 D1030000 		.4byte	.LASF2
 5244 002a 03       		.byte	0x3
 5245 002b D4       		.byte	0xd4
 5246 002c 30000000 		.4byte	0x30
 5247 0030 03       		.uleb128 0x3
 5248 0031 04       		.byte	0x4
 5249 0032 07       		.byte	0x7
 5250 0033 C1000000 		.4byte	.LASF0
 5251 0037 04       		.uleb128 0x4
 5252 0038 04       		.byte	0x4
 5253 0039 05       		.byte	0x5
 5254 003a 696E7400 		.ascii	"int\000"
 5255 003e 03       		.uleb128 0x3
 5256 003f 01       		.byte	0x1
 5257 0040 06       		.byte	0x6
 5258 0041 D40C0000 		.4byte	.LASF1
 5259 0045 02       		.uleb128 0x2
 5260 0046 210A0000 		.4byte	.LASF3
 5261 004a 04       		.byte	0x4
 5262 004b 1D       		.byte	0x1d
 5263 004c 50000000 		.4byte	0x50
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 181


 5264 0050 03       		.uleb128 0x3
 5265 0051 01       		.byte	0x1
 5266 0052 08       		.byte	0x8
 5267 0053 2F0B0000 		.4byte	.LASF4
 5268 0057 03       		.uleb128 0x3
 5269 0058 02       		.byte	0x2
 5270 0059 05       		.byte	0x5
 5271 005a 37090000 		.4byte	.LASF5
 5272 005e 02       		.uleb128 0x2
 5273 005f 79030000 		.4byte	.LASF6
 5274 0063 04       		.byte	0x4
 5275 0064 2B       		.byte	0x2b
 5276 0065 69000000 		.4byte	0x69
 5277 0069 03       		.uleb128 0x3
 5278 006a 02       		.byte	0x2
 5279 006b 07       		.byte	0x7
 5280 006c E00C0000 		.4byte	.LASF7
 5281 0070 02       		.uleb128 0x2
 5282 0071 3C010000 		.4byte	.LASF8
 5283 0075 04       		.byte	0x4
 5284 0076 3F       		.byte	0x3f
 5285 0077 7B000000 		.4byte	0x7b
 5286 007b 03       		.uleb128 0x3
 5287 007c 04       		.byte	0x4
 5288 007d 05       		.byte	0x5
 5289 007e 59090000 		.4byte	.LASF9
 5290 0082 02       		.uleb128 0x2
 5291 0083 7E0B0000 		.4byte	.LASF10
 5292 0087 04       		.byte	0x4
 5293 0088 41       		.byte	0x41
 5294 0089 8D000000 		.4byte	0x8d
 5295 008d 03       		.uleb128 0x3
 5296 008e 04       		.byte	0x4
 5297 008f 07       		.byte	0x7
 5298 0090 960A0000 		.4byte	.LASF11
 5299 0094 03       		.uleb128 0x3
 5300 0095 08       		.byte	0x8
 5301 0096 05       		.byte	0x5
 5302 0097 D6060000 		.4byte	.LASF12
 5303 009b 03       		.uleb128 0x3
 5304 009c 08       		.byte	0x8
 5305 009d 07       		.byte	0x7
 5306 009e E8020000 		.4byte	.LASF13
 5307 00a2 03       		.uleb128 0x3
 5308 00a3 04       		.byte	0x4
 5309 00a4 07       		.byte	0x7
 5310 00a5 6E0A0000 		.4byte	.LASF14
 5311 00a9 05       		.uleb128 0x5
 5312 00aa 04       		.byte	0x4
 5313 00ab 06       		.uleb128 0x6
 5314 00ac 04       		.byte	0x4
 5315 00ad B1000000 		.4byte	0xb1
 5316 00b1 03       		.uleb128 0x3
 5317 00b2 01       		.byte	0x1
 5318 00b3 08       		.byte	0x8
 5319 00b4 20050000 		.4byte	.LASF15
 5320 00b8 06       		.uleb128 0x6
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 182


 5321 00b9 04       		.byte	0x4
 5322 00ba BE000000 		.4byte	0xbe
 5323 00be 07       		.uleb128 0x7
 5324 00bf B1000000 		.4byte	0xb1
 5325 00c3 02       		.uleb128 0x2
 5326 00c4 F4050000 		.4byte	.LASF16
 5327 00c8 05       		.byte	0x5
 5328 00c9 15       		.byte	0x15
 5329 00ca 45000000 		.4byte	0x45
 5330 00ce 02       		.uleb128 0x2
 5331 00cf E3080000 		.4byte	.LASF17
 5332 00d3 05       		.byte	0x5
 5333 00d4 21       		.byte	0x21
 5334 00d5 5E000000 		.4byte	0x5e
 5335 00d9 02       		.uleb128 0x2
 5336 00da D60A0000 		.4byte	.LASF18
 5337 00de 05       		.byte	0x5
 5338 00df 2C       		.byte	0x2c
 5339 00e0 70000000 		.4byte	0x70
 5340 00e4 02       		.uleb128 0x2
 5341 00e5 52020000 		.4byte	.LASF19
 5342 00e9 05       		.byte	0x5
 5343 00ea 2D       		.byte	0x2d
 5344 00eb 82000000 		.4byte	0x82
 5345 00ef 03       		.uleb128 0x3
 5346 00f0 04       		.byte	0x4
 5347 00f1 04       		.byte	0x4
 5348 00f2 9D020000 		.4byte	.LASF20
 5349 00f6 03       		.uleb128 0x3
 5350 00f7 08       		.byte	0x8
 5351 00f8 04       		.byte	0x4
 5352 00f9 2C0D0000 		.4byte	.LASF21
 5353 00fd 08       		.uleb128 0x8
 5354 00fe E4000000 		.4byte	0xe4
 5355 0102 08       		.uleb128 0x8
 5356 0103 C3000000 		.4byte	0xc3
 5357 0107 02       		.uleb128 0x2
 5358 0108 67070000 		.4byte	.LASF22
 5359 010c 06       		.byte	0x6
 5360 010d 4D       		.byte	0x4d
 5361 010e 12010000 		.4byte	0x112
 5362 0112 06       		.uleb128 0x6
 5363 0113 04       		.byte	0x4
 5364 0114 18010000 		.4byte	0x118
 5365 0118 09       		.uleb128 0x9
 5366 0119 23010000 		.4byte	0x123
 5367 011d 0A       		.uleb128 0xa
 5368 011e A9000000 		.4byte	0xa9
 5369 0122 00       		.byte	0
 5370 0123 02       		.uleb128 0x2
 5371 0124 09010000 		.4byte	.LASF23
 5372 0128 02       		.byte	0x2
 5373 0129 61       		.byte	0x61
 5374 012a E4000000 		.4byte	0xe4
 5375 012e 02       		.uleb128 0x2
 5376 012f 15070000 		.4byte	.LASF24
 5377 0133 02       		.byte	0x2
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 183


 5378 0134 62       		.byte	0x62
 5379 0135 7B000000 		.4byte	0x7b
 5380 0139 02       		.uleb128 0x2
 5381 013a 57050000 		.4byte	.LASF25
 5382 013e 02       		.byte	0x2
 5383 013f 63       		.byte	0x63
 5384 0140 8D000000 		.4byte	0x8d
 5385 0144 02       		.uleb128 0x2
 5386 0145 BB080000 		.4byte	.LASF26
 5387 0149 02       		.byte	0x2
 5388 014a 69       		.byte	0x69
 5389 014b E4000000 		.4byte	0xe4
 5390 014f 06       		.uleb128 0x6
 5391 0150 04       		.byte	0x4
 5392 0151 C3000000 		.4byte	0xc3
 5393 0155 0B       		.uleb128 0xb
 5394 0156 46010000 		.4byte	.LASF33
 5395 015a 14       		.byte	0x14
 5396 015b 07       		.byte	0x7
 5397 015c B5       		.byte	0xb5
 5398 015d 9E010000 		.4byte	0x19e
 5399 0161 0C       		.uleb128 0xc
 5400 0162 4E090000 		.4byte	.LASF27
 5401 0166 07       		.byte	0x7
 5402 0167 B8       		.byte	0xb8
 5403 0168 44010000 		.4byte	0x144
 5404 016c 00       		.byte	0
 5405 016d 0C       		.uleb128 0xc
 5406 016e 76070000 		.4byte	.LASF28
 5407 0172 07       		.byte	0x7
 5408 0173 B9       		.byte	0xb9
 5409 0174 9E010000 		.4byte	0x19e
 5410 0178 04       		.byte	0x4
 5411 0179 0C       		.uleb128 0xc
 5412 017a 55030000 		.4byte	.LASF29
 5413 017e 07       		.byte	0x7
 5414 017f BA       		.byte	0xba
 5415 0180 9E010000 		.4byte	0x19e
 5416 0184 08       		.byte	0x8
 5417 0185 0C       		.uleb128 0xc
 5418 0186 120C0000 		.4byte	.LASF30
 5419 018a 07       		.byte	0x7
 5420 018b BB       		.byte	0xbb
 5421 018c A9000000 		.4byte	0xa9
 5422 0190 0C       		.byte	0xc
 5423 0191 0C       		.uleb128 0xc
 5424 0192 1B090000 		.4byte	.LASF31
 5425 0196 07       		.byte	0x7
 5426 0197 BC       		.byte	0xbc
 5427 0198 A9000000 		.4byte	0xa9
 5428 019c 10       		.byte	0x10
 5429 019d 00       		.byte	0
 5430 019e 06       		.uleb128 0x6
 5431 019f 04       		.byte	0x4
 5432 01a0 55010000 		.4byte	0x155
 5433 01a4 02       		.uleb128 0x2
 5434 01a5 25050000 		.4byte	.LASF32
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 184


 5435 01a9 07       		.byte	0x7
 5436 01aa BF       		.byte	0xbf
 5437 01ab 55010000 		.4byte	0x155
 5438 01af 0B       		.uleb128 0xb
 5439 01b0 E3030000 		.4byte	.LASF34
 5440 01b4 0C       		.byte	0xc
 5441 01b5 07       		.byte	0x7
 5442 01b6 C1       		.byte	0xc1
 5443 01b7 E0010000 		.4byte	0x1e0
 5444 01bb 0C       		.uleb128 0xc
 5445 01bc 4E090000 		.4byte	.LASF27
 5446 01c0 07       		.byte	0x7
 5447 01c1 C4       		.byte	0xc4
 5448 01c2 44010000 		.4byte	0x144
 5449 01c6 00       		.byte	0
 5450 01c7 0C       		.uleb128 0xc
 5451 01c8 76070000 		.4byte	.LASF28
 5452 01cc 07       		.byte	0x7
 5453 01cd C5       		.byte	0xc5
 5454 01ce 9E010000 		.4byte	0x19e
 5455 01d2 04       		.byte	0x4
 5456 01d3 0C       		.uleb128 0xc
 5457 01d4 55030000 		.4byte	.LASF29
 5458 01d8 07       		.byte	0x7
 5459 01d9 C6       		.byte	0xc6
 5460 01da 9E010000 		.4byte	0x19e
 5461 01de 08       		.byte	0x8
 5462 01df 00       		.byte	0
 5463 01e0 02       		.uleb128 0x2
 5464 01e1 B0050000 		.4byte	.LASF35
 5465 01e5 07       		.byte	0x7
 5466 01e6 C8       		.byte	0xc8
 5467 01e7 AF010000 		.4byte	0x1af
 5468 01eb 0B       		.uleb128 0xb
 5469 01ec 00040000 		.4byte	.LASF36
 5470 01f0 14       		.byte	0x14
 5471 01f1 07       		.byte	0x7
 5472 01f2 CD       		.byte	0xcd
 5473 01f3 1C020000 		.4byte	0x21c
 5474 01f7 0C       		.uleb128 0xc
 5475 01f8 0B000000 		.4byte	.LASF37
 5476 01fc 07       		.byte	0x7
 5477 01fd D0       		.byte	0xd0
 5478 01fe 39010000 		.4byte	0x139
 5479 0202 00       		.byte	0
 5480 0203 0C       		.uleb128 0xc
 5481 0204 EC000000 		.4byte	.LASF38
 5482 0208 07       		.byte	0x7
 5483 0209 D1       		.byte	0xd1
 5484 020a 1C020000 		.4byte	0x21c
 5485 020e 04       		.byte	0x4
 5486 020f 0C       		.uleb128 0xc
 5487 0210 89050000 		.4byte	.LASF39
 5488 0214 07       		.byte	0x7
 5489 0215 D2       		.byte	0xd2
 5490 0216 E0010000 		.4byte	0x1e0
 5491 021a 08       		.byte	0x8
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 185


 5492 021b 00       		.byte	0
 5493 021c 06       		.uleb128 0x6
 5494 021d 04       		.byte	0x4
 5495 021e A4010000 		.4byte	0x1a4
 5496 0222 02       		.uleb128 0x2
 5497 0223 A7080000 		.4byte	.LASF40
 5498 0227 07       		.byte	0x7
 5499 0228 D4       		.byte	0xd4
 5500 0229 EB010000 		.4byte	0x1eb
 5501 022d 02       		.uleb128 0x2
 5502 022e 4D080000 		.4byte	.LASF41
 5503 0232 08       		.byte	0x8
 5504 0233 67       		.byte	0x67
 5505 0234 A9000000 		.4byte	0xa9
 5506 0238 0D       		.uleb128 0xd
 5507 0239 01       		.byte	0x1
 5508 023a 08       		.byte	0x8
 5509 023b 71       		.byte	0x71
 5510 023c 65020000 		.4byte	0x265
 5511 0240 0E       		.uleb128 0xe
 5512 0241 0F0B0000 		.4byte	.LASF42
 5513 0245 00       		.sleb128 0
 5514 0246 0E       		.uleb128 0xe
 5515 0247 FC050000 		.4byte	.LASF43
 5516 024b 01       		.sleb128 1
 5517 024c 0E       		.uleb128 0xe
 5518 024d 270C0000 		.4byte	.LASF44
 5519 0251 02       		.sleb128 2
 5520 0252 0E       		.uleb128 0xe
 5521 0253 3E000000 		.4byte	.LASF45
 5522 0257 03       		.sleb128 3
 5523 0258 0E       		.uleb128 0xe
 5524 0259 E4060000 		.4byte	.LASF46
 5525 025d 04       		.sleb128 4
 5526 025e 0E       		.uleb128 0xe
 5527 025f 49000000 		.4byte	.LASF47
 5528 0263 05       		.sleb128 5
 5529 0264 00       		.byte	0
 5530 0265 02       		.uleb128 0x2
 5531 0266 9C080000 		.4byte	.LASF48
 5532 026a 08       		.byte	0x8
 5533 026b 78       		.byte	0x78
 5534 026c 38020000 		.4byte	0x238
 5535 0270 0D       		.uleb128 0xd
 5536 0271 01       		.byte	0x1
 5537 0272 08       		.byte	0x8
 5538 0273 7C       		.byte	0x7c
 5539 0274 97020000 		.4byte	0x297
 5540 0278 0E       		.uleb128 0xe
 5541 0279 A4000000 		.4byte	.LASF49
 5542 027d 00       		.sleb128 0
 5543 027e 0E       		.uleb128 0xe
 5544 027f DA080000 		.4byte	.LASF50
 5545 0283 01       		.sleb128 1
 5546 0284 0E       		.uleb128 0xe
 5547 0285 D8030000 		.4byte	.LASF51
 5548 0289 02       		.sleb128 2
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 186


 5549 028a 0E       		.uleb128 0xe
 5550 028b D1020000 		.4byte	.LASF52
 5551 028f 03       		.sleb128 3
 5552 0290 0E       		.uleb128 0xe
 5553 0291 30050000 		.4byte	.LASF53
 5554 0295 04       		.sleb128 4
 5555 0296 00       		.byte	0
 5556 0297 02       		.uleb128 0x2
 5557 0298 C3030000 		.4byte	.LASF54
 5558 029c 08       		.byte	0x8
 5559 029d 82       		.byte	0x82
 5560 029e 70020000 		.4byte	0x270
 5561 02a2 0B       		.uleb128 0xb
 5562 02a3 15010000 		.4byte	.LASF55
 5563 02a7 08       		.byte	0x8
 5564 02a8 08       		.byte	0x8
 5565 02a9 87       		.byte	0x87
 5566 02aa C7020000 		.4byte	0x2c7
 5567 02ae 0C       		.uleb128 0xc
 5568 02af E8010000 		.4byte	.LASF56
 5569 02b3 08       		.byte	0x8
 5570 02b4 89       		.byte	0x89
 5571 02b5 2E010000 		.4byte	0x12e
 5572 02b9 00       		.byte	0
 5573 02ba 0C       		.uleb128 0xc
 5574 02bb 49070000 		.4byte	.LASF57
 5575 02bf 08       		.byte	0x8
 5576 02c0 8A       		.byte	0x8a
 5577 02c1 44010000 		.4byte	0x144
 5578 02c5 04       		.byte	0x4
 5579 02c6 00       		.byte	0
 5580 02c7 02       		.uleb128 0x2
 5581 02c8 36080000 		.4byte	.LASF58
 5582 02cc 08       		.byte	0x8
 5583 02cd 8B       		.byte	0x8b
 5584 02ce A2020000 		.4byte	0x2a2
 5585 02d2 07       		.uleb128 0x7
 5586 02d3 B8000000 		.4byte	0xb8
 5587 02d7 06       		.uleb128 0x6
 5588 02d8 04       		.byte	0x4
 5589 02d9 23010000 		.4byte	0x123
 5590 02dd 0F       		.uleb128 0xf
 5591 02de 5D040000 		.4byte	.LASF59
 5592 02e2 50       		.byte	0x50
 5593 02e3 01       		.byte	0x1
 5594 02e4 1101     		.2byte	0x111
 5595 02e6 6D030000 		.4byte	0x36d
 5596 02ea 10       		.uleb128 0x10
 5597 02eb 480D0000 		.4byte	.LASF60
 5598 02ef 01       		.byte	0x1
 5599 02f0 1301     		.2byte	0x113
 5600 02f2 6D030000 		.4byte	0x36d
 5601 02f6 00       		.byte	0
 5602 02f7 10       		.uleb128 0x10
 5603 02f8 FF0C0000 		.4byte	.LASF61
 5604 02fc 01       		.byte	0x1
 5605 02fd 1901     		.2byte	0x119
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 187


 5606 02ff A4010000 		.4byte	0x1a4
 5607 0303 04       		.byte	0x4
 5608 0304 10       		.uleb128 0x10
 5609 0305 DA0B0000 		.4byte	.LASF62
 5610 0309 01       		.byte	0x1
 5611 030a 1A01     		.2byte	0x11a
 5612 030c A4010000 		.4byte	0x1a4
 5613 0310 18       		.byte	0x18
 5614 0311 10       		.uleb128 0x10
 5615 0312 1B000000 		.4byte	.LASF63
 5616 0316 01       		.byte	0x1
 5617 0317 1B01     		.2byte	0x11b
 5618 0319 39010000 		.4byte	0x139
 5619 031d 2C       		.byte	0x2c
 5620 031e 10       		.uleb128 0x10
 5621 031f CC090000 		.4byte	.LASF64
 5622 0323 01       		.byte	0x1
 5623 0324 1C01     		.2byte	0x11c
 5624 0326 D7020000 		.4byte	0x2d7
 5625 032a 30       		.byte	0x30
 5626 032b 10       		.uleb128 0x10
 5627 032c 00000000 		.4byte	.LASF65
 5628 0330 01       		.byte	0x1
 5629 0331 1D01     		.2byte	0x11d
 5630 0333 78030000 		.4byte	0x378
 5631 0337 34       		.byte	0x34
 5632 0338 10       		.uleb128 0x10
 5633 0339 BB0B0000 		.4byte	.LASF66
 5634 033d 01       		.byte	0x1
 5635 033e 2D01     		.2byte	0x12d
 5636 0340 39010000 		.4byte	0x139
 5637 0344 40       		.byte	0x40
 5638 0345 10       		.uleb128 0x10
 5639 0346 E1040000 		.4byte	.LASF67
 5640 034a 01       		.byte	0x1
 5641 034b 2E01     		.2byte	0x12e
 5642 034d 39010000 		.4byte	0x139
 5643 0351 44       		.byte	0x44
 5644 0352 10       		.uleb128 0x10
 5645 0353 D1040000 		.4byte	.LASF68
 5646 0357 01       		.byte	0x1
 5647 0358 4901     		.2byte	0x149
 5648 035a FD000000 		.4byte	0xfd
 5649 035e 48       		.byte	0x48
 5650 035f 10       		.uleb128 0x10
 5651 0360 5B020000 		.4byte	.LASF69
 5652 0364 01       		.byte	0x1
 5653 0365 4A01     		.2byte	0x14a
 5654 0367 02010000 		.4byte	0x102
 5655 036b 4C       		.byte	0x4c
 5656 036c 00       		.byte	0
 5657 036d 06       		.uleb128 0x6
 5658 036e 04       		.byte	0x4
 5659 036f 73030000 		.4byte	0x373
 5660 0373 08       		.uleb128 0x8
 5661 0374 23010000 		.4byte	0x123
 5662 0378 11       		.uleb128 0x11
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 188


 5663 0379 B1000000 		.4byte	0xb1
 5664 037d 88030000 		.4byte	0x388
 5665 0381 12       		.uleb128 0x12
 5666 0382 A2000000 		.4byte	0xa2
 5667 0386 0B       		.byte	0xb
 5668 0387 00       		.byte	0
 5669 0388 13       		.uleb128 0x13
 5670 0389 34020000 		.4byte	.LASF70
 5671 038d 01       		.byte	0x1
 5672 038e 5501     		.2byte	0x155
 5673 0390 DD020000 		.4byte	0x2dd
 5674 0394 13       		.uleb128 0x13
 5675 0395 FF0B0000 		.4byte	.LASF71
 5676 0399 01       		.byte	0x1
 5677 039a 5901     		.2byte	0x159
 5678 039c 88030000 		.4byte	0x388
 5679 03a0 14       		.uleb128 0x14
 5680 03a1 B8060000 		.4byte	.LASF76
 5681 03a5 02       		.byte	0x2
 5682 03a6 F9       		.byte	0xf9
 5683 03a7 E4000000 		.4byte	0xe4
 5684 03ab 03       		.byte	0x3
 5685 03ac C7030000 		.4byte	0x3c7
 5686 03b0 15       		.uleb128 0x15
 5687 03b1 78020000 		.4byte	.LASF72
 5688 03b5 02       		.byte	0x2
 5689 03b6 FB       		.byte	0xfb
 5690 03b7 E4000000 		.4byte	0xe4
 5691 03bb 15       		.uleb128 0x15
 5692 03bc 4A050000 		.4byte	.LASF73
 5693 03c0 02       		.byte	0x2
 5694 03c1 FB       		.byte	0xfb
 5695 03c2 E4000000 		.4byte	0xe4
 5696 03c6 00       		.byte	0
 5697 03c7 16       		.uleb128 0x16
 5698 03c8 4D040000 		.4byte	.LASF74
 5699 03cc 02       		.byte	0x2
 5700 03cd 0D01     		.2byte	0x10d
 5701 03cf 03       		.byte	0x3
 5702 03d0 E1030000 		.4byte	0x3e1
 5703 03d4 17       		.uleb128 0x17
 5704 03d5 62080000 		.4byte	.LASF78
 5705 03d9 02       		.byte	0x2
 5706 03da 0D01     		.2byte	0x10d
 5707 03dc E4000000 		.4byte	0xe4
 5708 03e0 00       		.byte	0
 5709 03e1 18       		.uleb128 0x18
 5710 03e2 A80A0000 		.4byte	.LASF75
 5711 03e6 02       		.byte	0x2
 5712 03e7 E9       		.byte	0xe9
 5713 03e8 03       		.byte	0x3
 5714 03e9 F9030000 		.4byte	0x3f9
 5715 03ed 15       		.uleb128 0x15
 5716 03ee 4A050000 		.4byte	.LASF73
 5717 03f2 02       		.byte	0x2
 5718 03f3 EB       		.byte	0xeb
 5719 03f4 E4000000 		.4byte	0xe4
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 189


 5720 03f8 00       		.byte	0
 5721 03f9 14       		.uleb128 0x14
 5722 03fa ED060000 		.4byte	.LASF77
 5723 03fe 02       		.byte	0x2
 5724 03ff AC       		.byte	0xac
 5725 0400 C3000000 		.4byte	0xc3
 5726 0404 03       		.byte	0x3
 5727 0405 20040000 		.4byte	0x420
 5728 0409 19       		.uleb128 0x19
 5729 040a BB010000 		.4byte	.LASF79
 5730 040e 02       		.byte	0x2
 5731 040f AC       		.byte	0xac
 5732 0410 E4000000 		.4byte	0xe4
 5733 0414 15       		.uleb128 0x15
 5734 0415 2B0A0000 		.4byte	.LASF80
 5735 0419 02       		.byte	0x2
 5736 041a AE       		.byte	0xae
 5737 041b C3000000 		.4byte	0xc3
 5738 041f 00       		.byte	0
 5739 0420 1A       		.uleb128 0x1a
 5740 0421 CF050000 		.4byte	.LASF103
 5741 0425 01       		.byte	0x1
 5742 0426 5402     		.2byte	0x254
 5743 0428 2E010000 		.4byte	0x12e
 5744 042c 00000000 		.4byte	.LFB68
 5745 0430 7E000000 		.4byte	.LFE68-.LFB68
 5746 0434 01       		.uleb128 0x1
 5747 0435 9C       		.byte	0x9c
 5748 0436 CC040000 		.4byte	0x4cc
 5749 043a 1B       		.uleb128 0x1b
 5750 043b 86060000 		.4byte	.LASF81
 5751 043f 01       		.byte	0x1
 5752 0440 5402     		.2byte	0x254
 5753 0442 07010000 		.4byte	0x107
 5754 0446 02       		.uleb128 0x2
 5755 0447 91       		.byte	0x91
 5756 0448 64       		.sleb128 -28
 5757 0449 1B       		.uleb128 0x1b
 5758 044a 2D020000 		.4byte	.LASF82
 5759 044e 01       		.byte	0x1
 5760 044f 5402     		.2byte	0x254
 5761 0451 D2020000 		.4byte	0x2d2
 5762 0455 02       		.uleb128 0x2
 5763 0456 91       		.byte	0x91
 5764 0457 60       		.sleb128 -32
 5765 0458 1B       		.uleb128 0x1b
 5766 0459 B2020000 		.4byte	.LASF83
 5767 045d 01       		.byte	0x1
 5768 045e 5402     		.2byte	0x254
 5769 0460 CC040000 		.4byte	0x4cc
 5770 0464 02       		.uleb128 0x2
 5771 0465 91       		.byte	0x91
 5772 0466 5E       		.sleb128 -34
 5773 0467 1B       		.uleb128 0x1b
 5774 0468 41090000 		.4byte	.LASF84
 5775 046c 01       		.byte	0x1
 5776 046d 5402     		.2byte	0x254
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 190


 5777 046f D1040000 		.4byte	0x4d1
 5778 0473 02       		.uleb128 0x2
 5779 0474 91       		.byte	0x91
 5780 0475 58       		.sleb128 -40
 5781 0476 1B       		.uleb128 0x1b
 5782 0477 1B000000 		.4byte	.LASF63
 5783 047b 01       		.byte	0x1
 5784 047c 5402     		.2byte	0x254
 5785 047e 39010000 		.4byte	0x139
 5786 0482 02       		.uleb128 0x2
 5787 0483 91       		.byte	0x91
 5788 0484 00       		.sleb128 0
 5789 0485 1B       		.uleb128 0x1b
 5790 0486 880D0000 		.4byte	.LASF85
 5791 048a 01       		.byte	0x1
 5792 048b 5402     		.2byte	0x254
 5793 048d D6040000 		.4byte	0x4d6
 5794 0491 02       		.uleb128 0x2
 5795 0492 91       		.byte	0x91
 5796 0493 04       		.sleb128 4
 5797 0494 1C       		.uleb128 0x1c
 5798 0495 11060000 		.4byte	.LASF86
 5799 0499 01       		.byte	0x1
 5800 049a 5602     		.2byte	0x256
 5801 049c E1040000 		.4byte	0x4e1
 5802 04a0 02       		.uleb128 0x2
 5803 04a1 91       		.byte	0x91
 5804 04a2 74       		.sleb128 -12
 5805 04a3 1C       		.uleb128 0x1c
 5806 04a4 660A0000 		.4byte	.LASF87
 5807 04a8 01       		.byte	0x1
 5808 04a9 5702     		.2byte	0x257
 5809 04ab 2E010000 		.4byte	0x12e
 5810 04af 02       		.uleb128 0x2
 5811 04b0 91       		.byte	0x91
 5812 04b1 70       		.sleb128 -16
 5813 04b2 1D       		.uleb128 0x1d
 5814 04b3 10000000 		.4byte	.LBB27
 5815 04b7 34000000 		.4byte	.LBE27-.LBB27
 5816 04bb 1C       		.uleb128 0x1c
 5817 04bc CC090000 		.4byte	.LASF64
 5818 04c0 01       		.byte	0x1
 5819 04c1 7402     		.2byte	0x274
 5820 04c3 D7020000 		.4byte	0x2d7
 5821 04c7 02       		.uleb128 0x2
 5822 04c8 91       		.byte	0x91
 5823 04c9 6C       		.sleb128 -20
 5824 04ca 00       		.byte	0
 5825 04cb 00       		.byte	0
 5826 04cc 07       		.uleb128 0x7
 5827 04cd CE000000 		.4byte	0xce
 5828 04d1 07       		.uleb128 0x7
 5829 04d2 A9000000 		.4byte	0xa9
 5830 04d6 07       		.uleb128 0x7
 5831 04d7 DB040000 		.4byte	0x4db
 5832 04db 06       		.uleb128 0x6
 5833 04dc 04       		.byte	0x4
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 191


 5834 04dd 2D020000 		.4byte	0x22d
 5835 04e1 06       		.uleb128 0x6
 5836 04e2 04       		.byte	0x4
 5837 04e3 94030000 		.4byte	0x394
 5838 04e7 1E       		.uleb128 0x1e
 5839 04e8 75000000 		.4byte	.LASF89
 5840 04ec 01       		.byte	0x1
 5841 04ed AA02     		.2byte	0x2aa
 5842 04ef 00000000 		.4byte	.LFB69
 5843 04f3 EC000000 		.4byte	.LFE69-.LFB69
 5844 04f7 01       		.uleb128 0x1
 5845 04f8 9C       		.byte	0x9c
 5846 04f9 83050000 		.4byte	0x583
 5847 04fd 1B       		.uleb128 0x1b
 5848 04fe 86060000 		.4byte	.LASF81
 5849 0502 01       		.byte	0x1
 5850 0503 AA02     		.2byte	0x2aa
 5851 0505 07010000 		.4byte	0x107
 5852 0509 02       		.uleb128 0x2
 5853 050a 91       		.byte	0x91
 5854 050b 6C       		.sleb128 -20
 5855 050c 1B       		.uleb128 0x1b
 5856 050d 2D020000 		.4byte	.LASF82
 5857 0511 01       		.byte	0x1
 5858 0512 AA02     		.2byte	0x2aa
 5859 0514 D2020000 		.4byte	0x2d2
 5860 0518 02       		.uleb128 0x2
 5861 0519 91       		.byte	0x91
 5862 051a 68       		.sleb128 -24
 5863 051b 1B       		.uleb128 0x1b
 5864 051c 63050000 		.4byte	.LASF88
 5865 0520 01       		.byte	0x1
 5866 0521 AA02     		.2byte	0x2aa
 5867 0523 83050000 		.4byte	0x583
 5868 0527 02       		.uleb128 0x2
 5869 0528 91       		.byte	0x91
 5870 0529 64       		.sleb128 -28
 5871 052a 1B       		.uleb128 0x1b
 5872 052b 41090000 		.4byte	.LASF84
 5873 052f 01       		.byte	0x1
 5874 0530 AA02     		.2byte	0x2aa
 5875 0532 D1040000 		.4byte	0x4d1
 5876 0536 02       		.uleb128 0x2
 5877 0537 91       		.byte	0x91
 5878 0538 60       		.sleb128 -32
 5879 0539 1B       		.uleb128 0x1b
 5880 053a 1B000000 		.4byte	.LASF63
 5881 053e 01       		.byte	0x1
 5882 053f AA02     		.2byte	0x2aa
 5883 0541 39010000 		.4byte	0x139
 5884 0545 02       		.uleb128 0x2
 5885 0546 91       		.byte	0x91
 5886 0547 00       		.sleb128 0
 5887 0548 1B       		.uleb128 0x1b
 5888 0549 880D0000 		.4byte	.LASF85
 5889 054d 01       		.byte	0x1
 5890 054e AA02     		.2byte	0x2aa
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 192


 5891 0550 D6040000 		.4byte	0x4d6
 5892 0554 02       		.uleb128 0x2
 5893 0555 91       		.byte	0x91
 5894 0556 04       		.sleb128 4
 5895 0557 1B       		.uleb128 0x1b
 5896 0558 11060000 		.4byte	.LASF86
 5897 055c 01       		.byte	0x1
 5898 055d AA02     		.2byte	0x2aa
 5899 055f E1040000 		.4byte	0x4e1
 5900 0563 02       		.uleb128 0x2
 5901 0564 91       		.byte	0x91
 5902 0565 08       		.sleb128 8
 5903 0566 1C       		.uleb128 0x1c
 5904 0567 480D0000 		.4byte	.LASF60
 5905 056b 01       		.byte	0x1
 5906 056c AC02     		.2byte	0x2ac
 5907 056e D7020000 		.4byte	0x2d7
 5908 0572 02       		.uleb128 0x2
 5909 0573 91       		.byte	0x91
 5910 0574 70       		.sleb128 -16
 5911 0575 1F       		.uleb128 0x1f
 5912 0576 7800     		.ascii	"x\000"
 5913 0578 01       		.byte	0x1
 5914 0579 AD02     		.2byte	0x2ad
 5915 057b 39010000 		.4byte	0x139
 5916 057f 02       		.uleb128 0x2
 5917 0580 91       		.byte	0x91
 5918 0581 74       		.sleb128 -12
 5919 0582 00       		.byte	0
 5920 0583 07       		.uleb128 0x7
 5921 0584 E4000000 		.4byte	0xe4
 5922 0588 1E       		.uleb128 0x1e
 5923 0589 DB050000 		.4byte	.LASF90
 5924 058d 01       		.byte	0x1
 5925 058e 6203     		.2byte	0x362
 5926 0590 00000000 		.4byte	.LFB70
 5927 0594 D8000000 		.4byte	.LFE70-.LFB70
 5928 0598 01       		.uleb128 0x1
 5929 0599 9C       		.byte	0x9c
 5930 059a AE050000 		.4byte	0x5ae
 5931 059e 1B       		.uleb128 0x1b
 5932 059f 11060000 		.4byte	.LASF86
 5933 05a3 01       		.byte	0x1
 5934 05a4 6203     		.2byte	0x362
 5935 05a6 E1040000 		.4byte	0x4e1
 5936 05aa 02       		.uleb128 0x2
 5937 05ab 91       		.byte	0x91
 5938 05ac 74       		.sleb128 -12
 5939 05ad 00       		.byte	0
 5940 05ae 20       		.uleb128 0x20
 5941 05af EC080000 		.4byte	.LASF93
 5942 05b3 01       		.byte	0x1
 5943 05b4 B703     		.2byte	0x3b7
 5944 05b6 00000000 		.4byte	.LFB71
 5945 05ba FC000000 		.4byte	.LFE71-.LFB71
 5946 05be 01       		.uleb128 0x1
 5947 05bf 9C       		.byte	0x9c
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 193


 5948 05c0 E3050000 		.4byte	0x5e3
 5949 05c4 1B       		.uleb128 0x1b
 5950 05c5 D4090000 		.4byte	.LASF91
 5951 05c9 01       		.byte	0x1
 5952 05ca B703     		.2byte	0x3b7
 5953 05cc 2D020000 		.4byte	0x22d
 5954 05d0 02       		.uleb128 0x2
 5955 05d1 91       		.byte	0x91
 5956 05d2 6C       		.sleb128 -20
 5957 05d3 1C       		.uleb128 0x1c
 5958 05d4 0E0D0000 		.4byte	.LASF92
 5959 05d8 01       		.byte	0x1
 5960 05d9 B903     		.2byte	0x3b9
 5961 05db E1040000 		.4byte	0x4e1
 5962 05df 02       		.uleb128 0x2
 5963 05e0 91       		.byte	0x91
 5964 05e1 74       		.sleb128 -12
 5965 05e2 00       		.byte	0
 5966 05e3 20       		.uleb128 0x20
 5967 05e4 CA0B0000 		.4byte	.LASF94
 5968 05e8 01       		.byte	0x1
 5969 05e9 1304     		.2byte	0x413
 5970 05eb 00000000 		.4byte	.LFB72
 5971 05ef A0000000 		.4byte	.LFE72-.LFB72
 5972 05f3 01       		.uleb128 0x1
 5973 05f4 9C       		.byte	0x9c
 5974 05f5 5E060000 		.4byte	0x65e
 5975 05f9 1B       		.uleb128 0x1b
 5976 05fa 0E0A0000 		.4byte	.LASF95
 5977 05fe 01       		.byte	0x1
 5978 05ff 1304     		.2byte	0x413
 5979 0601 5E060000 		.4byte	0x65e
 5980 0605 02       		.uleb128 0x2
 5981 0606 91       		.byte	0x91
 5982 0607 64       		.sleb128 -28
 5983 0608 1B       		.uleb128 0x1b
 5984 0609 C50C0000 		.4byte	.LASF96
 5985 060d 01       		.byte	0x1
 5986 060e 1304     		.2byte	0x413
 5987 0610 69060000 		.4byte	0x669
 5988 0614 02       		.uleb128 0x2
 5989 0615 91       		.byte	0x91
 5990 0616 60       		.sleb128 -32
 5991 0617 1C       		.uleb128 0x1c
 5992 0618 F30C0000 		.4byte	.LASF97
 5993 061c 01       		.byte	0x1
 5994 061d 1504     		.2byte	0x415
 5995 061f 44010000 		.4byte	0x144
 5996 0623 02       		.uleb128 0x2
 5997 0624 91       		.byte	0x91
 5998 0625 6C       		.sleb128 -20
 5999 0626 1C       		.uleb128 0x1c
 6000 0627 3D0C0000 		.4byte	.LASF98
 6001 062b 01       		.byte	0x1
 6002 062c 1604     		.2byte	0x416
 6003 062e 2E010000 		.4byte	0x12e
 6004 0632 02       		.uleb128 0x2
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 194


 6005 0633 91       		.byte	0x91
 6006 0634 68       		.sleb128 -24
 6007 0635 1C       		.uleb128 0x1c
 6008 0636 70050000 		.4byte	.LASF99
 6009 063a 01       		.byte	0x1
 6010 063b 1604     		.2byte	0x416
 6011 063d 2E010000 		.4byte	0x12e
 6012 0641 02       		.uleb128 0x2
 6013 0642 91       		.byte	0x91
 6014 0643 74       		.sleb128 -12
 6015 0644 1D       		.uleb128 0x1d
 6016 0645 12000000 		.4byte	.LBB28
 6017 0649 62000000 		.4byte	.LBE28-.LBB28
 6018 064d 1C       		.uleb128 0x1c
 6019 064e 2A040000 		.4byte	.LASF100
 6020 0652 01       		.byte	0x1
 6021 0653 2004     		.2byte	0x420
 6022 0655 69060000 		.4byte	0x669
 6023 0659 02       		.uleb128 0x2
 6024 065a 91       		.byte	0x91
 6025 065b 70       		.sleb128 -16
 6026 065c 00       		.byte	0
 6027 065d 00       		.byte	0
 6028 065e 07       		.uleb128 0x7
 6029 065f 63060000 		.4byte	0x663
 6030 0663 06       		.uleb128 0x6
 6031 0664 04       		.byte	0x4
 6032 0665 44010000 		.4byte	0x144
 6033 0669 07       		.uleb128 0x7
 6034 066a 44010000 		.4byte	0x144
 6035 066e 20       		.uleb128 0x20
 6036 066f A8040000 		.4byte	.LASF101
 6037 0673 01       		.byte	0x1
 6038 0674 6704     		.2byte	0x467
 6039 0676 00000000 		.4byte	.LFB73
 6040 067a 44000000 		.4byte	.LFE73-.LFB73
 6041 067e 01       		.uleb128 0x1
 6042 067f 9C       		.byte	0x9c
 6043 0680 A3060000 		.4byte	0x6a3
 6044 0684 1B       		.uleb128 0x1b
 6045 0685 210B0000 		.4byte	.LASF102
 6046 0689 01       		.byte	0x1
 6047 068a 6704     		.2byte	0x467
 6048 068c 69060000 		.4byte	0x669
 6049 0690 02       		.uleb128 0x2
 6050 0691 91       		.byte	0x91
 6051 0692 6C       		.sleb128 -20
 6052 0693 1C       		.uleb128 0x1c
 6053 0694 3D0C0000 		.4byte	.LASF98
 6054 0698 01       		.byte	0x1
 6055 0699 6904     		.2byte	0x469
 6056 069b 2E010000 		.4byte	0x12e
 6057 069f 02       		.uleb128 0x2
 6058 06a0 91       		.byte	0x91
 6059 06a1 74       		.sleb128 -12
 6060 06a2 00       		.byte	0
 6061 06a3 1A       		.uleb128 0x1a
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 195


 6062 06a4 03060000 		.4byte	.LASF104
 6063 06a8 01       		.byte	0x1
 6064 06a9 9404     		.2byte	0x494
 6065 06ab 65020000 		.4byte	0x265
 6066 06af 00000000 		.4byte	.LFB74
 6067 06b3 98000000 		.4byte	.LFE74-.LFB74
 6068 06b7 01       		.uleb128 0x1
 6069 06b8 9C       		.byte	0x9c
 6070 06b9 FA060000 		.4byte	0x6fa
 6071 06bd 1B       		.uleb128 0x1b
 6072 06be D4080000 		.4byte	.LASF105
 6073 06c2 01       		.byte	0x1
 6074 06c3 9404     		.2byte	0x494
 6075 06c5 2D020000 		.4byte	0x22d
 6076 06c9 02       		.uleb128 0x2
 6077 06ca 91       		.byte	0x91
 6078 06cb 64       		.sleb128 -28
 6079 06cc 1C       		.uleb128 0x1c
 6080 06cd F7010000 		.4byte	.LASF106
 6081 06d1 01       		.byte	0x1
 6082 06d2 9604     		.2byte	0x496
 6083 06d4 65020000 		.4byte	0x265
 6084 06d8 02       		.uleb128 0x2
 6085 06d9 91       		.byte	0x91
 6086 06da 77       		.sleb128 -9
 6087 06db 1C       		.uleb128 0x1c
 6088 06dc 32000000 		.4byte	.LASF107
 6089 06e0 01       		.byte	0x1
 6090 06e1 9704     		.2byte	0x497
 6091 06e3 FA060000 		.4byte	0x6fa
 6092 06e7 02       		.uleb128 0x2
 6093 06e8 91       		.byte	0x91
 6094 06e9 6C       		.sleb128 -20
 6095 06ea 1C       		.uleb128 0x1c
 6096 06eb 0E0D0000 		.4byte	.LASF92
 6097 06ef 01       		.byte	0x1
 6098 06f0 9804     		.2byte	0x498
 6099 06f2 00070000 		.4byte	0x700
 6100 06f6 02       		.uleb128 0x2
 6101 06f7 91       		.byte	0x91
 6102 06f8 70       		.sleb128 -16
 6103 06f9 00       		.byte	0
 6104 06fa 06       		.uleb128 0x6
 6105 06fb 04       		.byte	0x4
 6106 06fc 22020000 		.4byte	0x222
 6107 0700 07       		.uleb128 0x7
 6108 0701 05070000 		.4byte	0x705
 6109 0705 06       		.uleb128 0x6
 6110 0706 04       		.byte	0x4
 6111 0707 0B070000 		.4byte	0x70b
 6112 070b 07       		.uleb128 0x7
 6113 070c 94030000 		.4byte	0x394
 6114 0710 1A       		.uleb128 0x1a
 6115 0711 18040000 		.4byte	.LASF108
 6116 0715 01       		.byte	0x1
 6117 0716 DB04     		.2byte	0x4db
 6118 0718 39010000 		.4byte	0x139
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 196


 6119 071c 00000000 		.4byte	.LFB75
 6120 0720 34000000 		.4byte	.LFE75-.LFB75
 6121 0724 01       		.uleb128 0x1
 6122 0725 9C       		.byte	0x9c
 6123 0726 58070000 		.4byte	0x758
 6124 072a 1B       		.uleb128 0x1b
 6125 072b D4080000 		.4byte	.LASF105
 6126 072f 01       		.byte	0x1
 6127 0730 DB04     		.2byte	0x4db
 6128 0732 2D020000 		.4byte	0x22d
 6129 0736 02       		.uleb128 0x2
 6130 0737 91       		.byte	0x91
 6131 0738 6C       		.sleb128 -20
 6132 0739 1C       		.uleb128 0x1c
 6133 073a 0E0D0000 		.4byte	.LASF92
 6134 073e 01       		.byte	0x1
 6135 073f DD04     		.2byte	0x4dd
 6136 0741 E1040000 		.4byte	0x4e1
 6137 0745 02       		.uleb128 0x2
 6138 0746 91       		.byte	0x91
 6139 0747 74       		.sleb128 -12
 6140 0748 1C       		.uleb128 0x1c
 6141 0749 0D020000 		.4byte	.LASF109
 6142 074d 01       		.byte	0x1
 6143 074e DE04     		.2byte	0x4de
 6144 0750 39010000 		.4byte	0x139
 6145 0754 02       		.uleb128 0x2
 6146 0755 91       		.byte	0x91
 6147 0756 70       		.sleb128 -16
 6148 0757 00       		.byte	0
 6149 0758 21       		.uleb128 0x21
 6150 0759 15080000 		.4byte	.LASF110
 6151 075d 01       		.byte	0x1
 6152 075e F104     		.2byte	0x4f1
 6153 0760 39010000 		.4byte	0x139
 6154 0764 00000000 		.4byte	.LFB76
 6155 0768 58000000 		.4byte	.LFE76-.LFB76
 6156 076c 01       		.uleb128 0x1
 6157 076d 9C       		.byte	0x9c
 6158 076e F7070000 		.4byte	0x7f7
 6159 0772 1B       		.uleb128 0x1b
 6160 0773 D4080000 		.4byte	.LASF105
 6161 0777 01       		.byte	0x1
 6162 0778 F104     		.2byte	0x4f1
 6163 077a 2D020000 		.4byte	0x22d
 6164 077e 02       		.uleb128 0x2
 6165 077f 91       		.byte	0x91
 6166 0780 5C       		.sleb128 -36
 6167 0781 1C       		.uleb128 0x1c
 6168 0782 0E0D0000 		.4byte	.LASF92
 6169 0786 01       		.byte	0x1
 6170 0787 F304     		.2byte	0x4f3
 6171 0789 E1040000 		.4byte	0x4e1
 6172 078d 02       		.uleb128 0x2
 6173 078e 91       		.byte	0x91
 6174 078f 70       		.sleb128 -16
 6175 0790 1C       		.uleb128 0x1c
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 197


 6176 0791 0D020000 		.4byte	.LASF109
 6177 0795 01       		.byte	0x1
 6178 0796 F404     		.2byte	0x4f4
 6179 0798 39010000 		.4byte	0x139
 6180 079c 02       		.uleb128 0x2
 6181 079d 91       		.byte	0x91
 6182 079e 6C       		.sleb128 -20
 6183 079f 1C       		.uleb128 0x1c
 6184 07a0 18030000 		.4byte	.LASF111
 6185 07a4 01       		.byte	0x1
 6186 07a5 F404     		.2byte	0x4f4
 6187 07a7 39010000 		.4byte	0x139
 6188 07ab 02       		.uleb128 0x2
 6189 07ac 91       		.byte	0x91
 6190 07ad 74       		.sleb128 -12
 6191 07ae 22       		.uleb128 0x22
 6192 07af A0030000 		.4byte	0x3a0
 6193 07b3 08000000 		.4byte	.LBB29
 6194 07b7 1A000000 		.4byte	.LBE29-.LBB29
 6195 07bb 01       		.byte	0x1
 6196 07bc 0805     		.2byte	0x508
 6197 07be DD070000 		.4byte	0x7dd
 6198 07c2 1D       		.uleb128 0x1d
 6199 07c3 08000000 		.4byte	.LBB30
 6200 07c7 1A000000 		.4byte	.LBE30-.LBB30
 6201 07cb 23       		.uleb128 0x23
 6202 07cc B0030000 		.4byte	0x3b0
 6203 07d0 02       		.uleb128 0x2
 6204 07d1 91       		.byte	0x91
 6205 07d2 68       		.sleb128 -24
 6206 07d3 23       		.uleb128 0x23
 6207 07d4 BB030000 		.4byte	0x3bb
 6208 07d8 02       		.uleb128 0x2
 6209 07d9 91       		.byte	0x91
 6210 07da 64       		.sleb128 -28
 6211 07db 00       		.byte	0
 6212 07dc 00       		.byte	0
 6213 07dd 24       		.uleb128 0x24
 6214 07de C7030000 		.4byte	0x3c7
 6215 07e2 3E000000 		.4byte	.LBB31
 6216 07e6 06000000 		.4byte	.LBE31-.LBB31
 6217 07ea 01       		.byte	0x1
 6218 07eb 0F05     		.2byte	0x50f
 6219 07ed 25       		.uleb128 0x25
 6220 07ee D4030000 		.4byte	0x3d4
 6221 07f2 02       		.uleb128 0x2
 6222 07f3 91       		.byte	0x91
 6223 07f4 60       		.sleb128 -32
 6224 07f5 00       		.byte	0
 6225 07f6 00       		.byte	0
 6226 07f7 20       		.uleb128 0x20
 6227 07f8 8B080000 		.4byte	.LASF112
 6228 07fc 01       		.byte	0x1
 6229 07fd 1905     		.2byte	0x519
 6230 07ff 00000000 		.4byte	.LFB77
 6231 0803 44010000 		.4byte	.LFE77-.LFB77
 6232 0807 01       		.uleb128 0x1
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 198


 6233 0808 9C       		.byte	0x9c
 6234 0809 68080000 		.4byte	0x868
 6235 080d 1B       		.uleb128 0x1b
 6236 080e D4080000 		.4byte	.LASF105
 6237 0812 01       		.byte	0x1
 6238 0813 1905     		.2byte	0x519
 6239 0815 2D020000 		.4byte	0x22d
 6240 0819 02       		.uleb128 0x2
 6241 081a 91       		.byte	0x91
 6242 081b 64       		.sleb128 -28
 6243 081c 1B       		.uleb128 0x1b
 6244 081d 59070000 		.4byte	.LASF113
 6245 0821 01       		.byte	0x1
 6246 0822 1905     		.2byte	0x519
 6247 0824 39010000 		.4byte	0x139
 6248 0828 02       		.uleb128 0x2
 6249 0829 91       		.byte	0x91
 6250 082a 60       		.sleb128 -32
 6251 082b 1C       		.uleb128 0x1c
 6252 082c 0E0D0000 		.4byte	.LASF92
 6253 0830 01       		.byte	0x1
 6254 0831 1B05     		.2byte	0x51b
 6255 0833 E1040000 		.4byte	0x4e1
 6256 0837 02       		.uleb128 0x2
 6257 0838 91       		.byte	0x91
 6258 0839 70       		.sleb128 -16
 6259 083a 1C       		.uleb128 0x1c
 6260 083b BF0D0000 		.4byte	.LASF114
 6261 083f 01       		.byte	0x1
 6262 0840 1C05     		.2byte	0x51c
 6263 0842 39010000 		.4byte	0x139
 6264 0846 02       		.uleb128 0x2
 6265 0847 91       		.byte	0x91
 6266 0848 6C       		.sleb128 -20
 6267 0849 1C       		.uleb128 0x1c
 6268 084a E90B0000 		.4byte	.LASF115
 6269 084e 01       		.byte	0x1
 6270 084f 1C05     		.2byte	0x51c
 6271 0851 39010000 		.4byte	0x139
 6272 0855 02       		.uleb128 0x2
 6273 0856 91       		.byte	0x91
 6274 0857 68       		.sleb128 -24
 6275 0858 1C       		.uleb128 0x1c
 6276 0859 69020000 		.4byte	.LASF116
 6277 085d 01       		.byte	0x1
 6278 085e 1D05     		.2byte	0x51d
 6279 0860 2E010000 		.4byte	0x12e
 6280 0864 02       		.uleb128 0x2
 6281 0865 91       		.byte	0x91
 6282 0866 74       		.sleb128 -12
 6283 0867 00       		.byte	0
 6284 0868 20       		.uleb128 0x20
 6285 0869 300C0000 		.4byte	.LASF117
 6286 086d 01       		.byte	0x1
 6287 086e BD05     		.2byte	0x5bd
 6288 0870 00000000 		.4byte	.LFB78
 6289 0874 EC000000 		.4byte	.LFE78-.LFB78
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 199


 6290 0878 01       		.uleb128 0x1
 6291 0879 9C       		.byte	0x9c
 6292 087a 9D080000 		.4byte	0x89d
 6293 087e 1B       		.uleb128 0x1b
 6294 087f EA090000 		.4byte	.LASF118
 6295 0883 01       		.byte	0x1
 6296 0884 BD05     		.2byte	0x5bd
 6297 0886 2D020000 		.4byte	0x22d
 6298 088a 02       		.uleb128 0x2
 6299 088b 91       		.byte	0x91
 6300 088c 6C       		.sleb128 -20
 6301 088d 1C       		.uleb128 0x1c
 6302 088e 0E0D0000 		.4byte	.LASF92
 6303 0892 01       		.byte	0x1
 6304 0893 BF05     		.2byte	0x5bf
 6305 0895 E1040000 		.4byte	0x4e1
 6306 0899 02       		.uleb128 0x2
 6307 089a 91       		.byte	0x91
 6308 089b 74       		.sleb128 -12
 6309 089c 00       		.byte	0
 6310 089d 26       		.uleb128 0x26
 6311 089e A7090000 		.4byte	.LASF158
 6312 08a2 01       		.byte	0x1
 6313 08a3 1706     		.2byte	0x617
 6314 08a5 2E010000 		.4byte	0x12e
 6315 08a9 00000000 		.4byte	.LFB79
 6316 08ad 5C000000 		.4byte	.LFE79-.LFB79
 6317 08b1 01       		.uleb128 0x1
 6318 08b2 9C       		.byte	0x9c
 6319 08b3 E5080000 		.4byte	0x8e5
 6320 08b7 1B       		.uleb128 0x1b
 6321 08b8 D4080000 		.4byte	.LASF105
 6322 08bc 01       		.byte	0x1
 6323 08bd 1706     		.2byte	0x617
 6324 08bf E5080000 		.4byte	0x8e5
 6325 08c3 02       		.uleb128 0x2
 6326 08c4 91       		.byte	0x91
 6327 08c5 6C       		.sleb128 -20
 6328 08c6 1C       		.uleb128 0x1c
 6329 08c7 660A0000 		.4byte	.LASF87
 6330 08cb 01       		.byte	0x1
 6331 08cc 1906     		.2byte	0x619
 6332 08ce 2E010000 		.4byte	0x12e
 6333 08d2 02       		.uleb128 0x2
 6334 08d3 91       		.byte	0x91
 6335 08d4 74       		.sleb128 -12
 6336 08d5 1C       		.uleb128 0x1c
 6337 08d6 0E0D0000 		.4byte	.LASF92
 6338 08da 01       		.byte	0x1
 6339 08db 1A06     		.2byte	0x61a
 6340 08dd 00070000 		.4byte	0x700
 6341 08e1 02       		.uleb128 0x2
 6342 08e2 91       		.byte	0x91
 6343 08e3 70       		.sleb128 -16
 6344 08e4 00       		.byte	0
 6345 08e5 07       		.uleb128 0x7
 6346 08e6 2D020000 		.4byte	0x22d
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 200


 6347 08ea 20       		.uleb128 0x20
 6348 08eb 550D0000 		.4byte	.LASF119
 6349 08ef 01       		.byte	0x1
 6350 08f0 4506     		.2byte	0x645
 6351 08f2 00000000 		.4byte	.LFB80
 6352 08f6 A0000000 		.4byte	.LFE80-.LFB80
 6353 08fa 01       		.uleb128 0x1
 6354 08fb 9C       		.byte	0x9c
 6355 08fc 1F090000 		.4byte	0x91f
 6356 0900 1B       		.uleb128 0x1b
 6357 0901 FF010000 		.4byte	.LASF120
 6358 0905 01       		.byte	0x1
 6359 0906 4506     		.2byte	0x645
 6360 0908 2D020000 		.4byte	0x22d
 6361 090c 02       		.uleb128 0x2
 6362 090d 91       		.byte	0x91
 6363 090e 6C       		.sleb128 -20
 6364 090f 1C       		.uleb128 0x1c
 6365 0910 0E0D0000 		.4byte	.LASF92
 6366 0914 01       		.byte	0x1
 6367 0915 4706     		.2byte	0x647
 6368 0917 1F090000 		.4byte	0x91f
 6369 091b 02       		.uleb128 0x2
 6370 091c 91       		.byte	0x91
 6371 091d 74       		.sleb128 -12
 6372 091e 00       		.byte	0
 6373 091f 07       		.uleb128 0x7
 6374 0920 E1040000 		.4byte	0x4e1
 6375 0924 1A       		.uleb128 0x1a
 6376 0925 84030000 		.4byte	.LASF121
 6377 0929 01       		.byte	0x1
 6378 092a 7B06     		.2byte	0x67b
 6379 092c 2E010000 		.4byte	0x12e
 6380 0930 00000000 		.4byte	.LFB81
 6381 0934 C4000000 		.4byte	.LFE81-.LFB81
 6382 0938 01       		.uleb128 0x1
 6383 0939 9C       		.byte	0x9c
 6384 093a C3090000 		.4byte	0x9c3
 6385 093e 1B       		.uleb128 0x1b
 6386 093f FF010000 		.4byte	.LASF120
 6387 0943 01       		.byte	0x1
 6388 0944 7B06     		.2byte	0x67b
 6389 0946 2D020000 		.4byte	0x22d
 6390 094a 02       		.uleb128 0x2
 6391 094b 91       		.byte	0x91
 6392 094c 5C       		.sleb128 -36
 6393 094d 1C       		.uleb128 0x1c
 6394 094e 69020000 		.4byte	.LASF116
 6395 0952 01       		.byte	0x1
 6396 0953 7D06     		.2byte	0x67d
 6397 0955 2E010000 		.4byte	0x12e
 6398 0959 02       		.uleb128 0x2
 6399 095a 91       		.byte	0x91
 6400 095b 74       		.sleb128 -12
 6401 095c 1C       		.uleb128 0x1c
 6402 095d 0E0D0000 		.4byte	.LASF92
 6403 0961 01       		.byte	0x1
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 201


 6404 0962 7E06     		.2byte	0x67e
 6405 0964 1F090000 		.4byte	0x91f
 6406 0968 02       		.uleb128 0x2
 6407 0969 91       		.byte	0x91
 6408 096a 70       		.sleb128 -16
 6409 096b 1C       		.uleb128 0x1c
 6410 096c 3B020000 		.4byte	.LASF122
 6411 0970 01       		.byte	0x1
 6412 0971 7F06     		.2byte	0x67f
 6413 0973 39010000 		.4byte	0x139
 6414 0977 02       		.uleb128 0x2
 6415 0978 91       		.byte	0x91
 6416 0979 6C       		.sleb128 -20
 6417 097a 22       		.uleb128 0x22
 6418 097b A0030000 		.4byte	0x3a0
 6419 097f 10000000 		.4byte	.LBB33
 6420 0983 1A000000 		.4byte	.LBE33-.LBB33
 6421 0987 01       		.byte	0x1
 6422 0988 9506     		.2byte	0x695
 6423 098a A9090000 		.4byte	0x9a9
 6424 098e 1D       		.uleb128 0x1d
 6425 098f 10000000 		.4byte	.LBB34
 6426 0993 1A000000 		.4byte	.LBE34-.LBB34
 6427 0997 23       		.uleb128 0x23
 6428 0998 B0030000 		.4byte	0x3b0
 6429 099c 02       		.uleb128 0x2
 6430 099d 91       		.byte	0x91
 6431 099e 68       		.sleb128 -24
 6432 099f 23       		.uleb128 0x23
 6433 09a0 BB030000 		.4byte	0x3bb
 6434 09a4 02       		.uleb128 0x2
 6435 09a5 91       		.byte	0x91
 6436 09a6 64       		.sleb128 -28
 6437 09a7 00       		.byte	0
 6438 09a8 00       		.byte	0
 6439 09a9 24       		.uleb128 0x24
 6440 09aa C7030000 		.4byte	0x3c7
 6441 09ae A0000000 		.4byte	.LBB35
 6442 09b2 06000000 		.4byte	.LBE35-.LBB35
 6443 09b6 01       		.byte	0x1
 6444 09b7 B906     		.2byte	0x6b9
 6445 09b9 25       		.uleb128 0x25
 6446 09ba D4030000 		.4byte	0x3d4
 6447 09be 02       		.uleb128 0x2
 6448 09bf 91       		.byte	0x91
 6449 09c0 60       		.sleb128 -32
 6450 09c1 00       		.byte	0
 6451 09c2 00       		.byte	0
 6452 09c3 20       		.uleb128 0x20
 6453 09c4 E50A0000 		.4byte	.LASF123
 6454 09c8 01       		.byte	0x1
 6455 09c9 C106     		.2byte	0x6c1
 6456 09cb 00000000 		.4byte	.LFB82
 6457 09cf 6C000000 		.4byte	.LFE82-.LFB82
 6458 09d3 01       		.uleb128 0x1
 6459 09d4 9C       		.byte	0x9c
 6460 09d5 0C0A0000 		.4byte	0xa0c
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 202


 6461 09d9 1C       		.uleb128 0x1c
 6462 09da 660A0000 		.4byte	.LASF87
 6463 09de 01       		.byte	0x1
 6464 09df C306     		.2byte	0x6c3
 6465 09e1 2E010000 		.4byte	0x12e
 6466 09e5 02       		.uleb128 0x2
 6467 09e6 91       		.byte	0x91
 6468 09e7 74       		.sleb128 -12
 6469 09e8 24       		.uleb128 0x24
 6470 09e9 E1030000 		.4byte	0x3e1
 6471 09ed 22000000 		.4byte	.LBB37
 6472 09f1 12000000 		.4byte	.LBE37-.LBB37
 6473 09f5 01       		.byte	0x1
 6474 09f6 F506     		.2byte	0x6f5
 6475 09f8 1D       		.uleb128 0x1d
 6476 09f9 22000000 		.4byte	.LBB38
 6477 09fd 12000000 		.4byte	.LBE38-.LBB38
 6478 0a01 23       		.uleb128 0x23
 6479 0a02 ED030000 		.4byte	0x3ed
 6480 0a06 02       		.uleb128 0x2
 6481 0a07 91       		.byte	0x91
 6482 0a08 70       		.sleb128 -16
 6483 0a09 00       		.byte	0
 6484 0a0a 00       		.byte	0
 6485 0a0b 00       		.byte	0
 6486 0a0c 20       		.uleb128 0x20
 6487 0a0d 06040000 		.4byte	.LASF124
 6488 0a11 01       		.byte	0x1
 6489 0a12 2207     		.2byte	0x722
 6490 0a14 00000000 		.4byte	.LFB83
 6491 0a18 2C000000 		.4byte	.LFE83-.LFB83
 6492 0a1c 01       		.uleb128 0x1
 6493 0a1d 9C       		.byte	0x9c
 6494 0a1e 460A0000 		.4byte	0xa46
 6495 0a22 24       		.uleb128 0x24
 6496 0a23 E1030000 		.4byte	0x3e1
 6497 0a27 06000000 		.4byte	.LBB39
 6498 0a2b 12000000 		.4byte	.LBE39-.LBB39
 6499 0a2f 01       		.byte	0x1
 6500 0a30 2707     		.2byte	0x727
 6501 0a32 1D       		.uleb128 0x1d
 6502 0a33 06000000 		.4byte	.LBB40
 6503 0a37 12000000 		.4byte	.LBE40-.LBB40
 6504 0a3b 23       		.uleb128 0x23
 6505 0a3c ED030000 		.4byte	0x3ed
 6506 0a40 02       		.uleb128 0x2
 6507 0a41 91       		.byte	0x91
 6508 0a42 74       		.sleb128 -12
 6509 0a43 00       		.byte	0
 6510 0a44 00       		.byte	0
 6511 0a45 00       		.byte	0
 6512 0a46 27       		.uleb128 0x27
 6513 0a47 97030000 		.4byte	.LASF152
 6514 0a4b 01       		.byte	0x1
 6515 0a4c 2D07     		.2byte	0x72d
 6516 0a4e 00000000 		.4byte	.LFB84
 6517 0a52 1C000000 		.4byte	.LFE84-.LFB84
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 203


 6518 0a56 01       		.uleb128 0x1
 6519 0a57 9C       		.byte	0x9c
 6520 0a58 1A       		.uleb128 0x1a
 6521 0a59 6F090000 		.4byte	.LASF125
 6522 0a5d 01       		.byte	0x1
 6523 0a5e 7607     		.2byte	0x776
 6524 0a60 2E010000 		.4byte	0x12e
 6525 0a64 00000000 		.4byte	.LFB85
 6526 0a68 20010000 		.4byte	.LFE85-.LFB85
 6527 0a6c 01       		.uleb128 0x1
 6528 0a6d 9C       		.byte	0x9c
 6529 0a6e AA0A0000 		.4byte	0xaaa
 6530 0a72 1C       		.uleb128 0x1c
 6531 0a73 0E0D0000 		.4byte	.LASF92
 6532 0a77 01       		.byte	0x1
 6533 0a78 7807     		.2byte	0x778
 6534 0a7a E1040000 		.4byte	0x4e1
 6535 0a7e 02       		.uleb128 0x2
 6536 0a7f 91       		.byte	0x91
 6537 0a80 74       		.sleb128 -12
 6538 0a81 1C       		.uleb128 0x1c
 6539 0a82 3D0C0000 		.4byte	.LASF98
 6540 0a86 01       		.byte	0x1
 6541 0a87 7907     		.2byte	0x779
 6542 0a89 2E010000 		.4byte	0x12e
 6543 0a8d 02       		.uleb128 0x2
 6544 0a8e 91       		.byte	0x91
 6545 0a8f 70       		.sleb128 -16
 6546 0a90 1D       		.uleb128 0x1d
 6547 0a91 A2000000 		.4byte	.LBB41
 6548 0a95 2E000000 		.4byte	.LBE41-.LBB41
 6549 0a99 1C       		.uleb128 0x1c
 6550 0a9a 52000000 		.4byte	.LASF126
 6551 0a9e 01       		.byte	0x1
 6552 0a9f B107     		.2byte	0x7b1
 6553 0aa1 39010000 		.4byte	0x139
 6554 0aa5 02       		.uleb128 0x2
 6555 0aa6 91       		.byte	0x91
 6556 0aa7 6C       		.sleb128 -20
 6557 0aa8 00       		.byte	0
 6558 0aa9 00       		.byte	0
 6559 0aaa 21       		.uleb128 0x21
 6560 0aab 91060000 		.4byte	.LASF127
 6561 0aaf 01       		.byte	0x1
 6562 0ab0 E407     		.2byte	0x7e4
 6563 0ab2 44010000 		.4byte	0x144
 6564 0ab6 00000000 		.4byte	.LFB86
 6565 0aba 20000000 		.4byte	.LFE86-.LFB86
 6566 0abe 01       		.uleb128 0x1
 6567 0abf 9C       		.byte	0x9c
 6568 0ac0 D40A0000 		.4byte	0xad4
 6569 0ac4 1C       		.uleb128 0x1c
 6570 0ac5 DE0A0000 		.4byte	.LASF128
 6571 0ac9 01       		.byte	0x1
 6572 0aca E607     		.2byte	0x7e6
 6573 0acc 44010000 		.4byte	0x144
 6574 0ad0 02       		.uleb128 0x2
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 204


 6575 0ad1 91       		.byte	0x91
 6576 0ad2 74       		.sleb128 -12
 6577 0ad3 00       		.byte	0
 6578 0ad4 21       		.uleb128 0x21
 6579 0ad5 FF020000 		.4byte	.LASF129
 6580 0ad9 01       		.byte	0x1
 6581 0ada F307     		.2byte	0x7f3
 6582 0adc 44010000 		.4byte	0x144
 6583 0ae0 00000000 		.4byte	.LFB87
 6584 0ae4 24000000 		.4byte	.LFE87-.LFB87
 6585 0ae8 01       		.uleb128 0x1
 6586 0ae9 9C       		.byte	0x9c
 6587 0aea 0D0B0000 		.4byte	0xb0d
 6588 0aee 1C       		.uleb128 0x1c
 6589 0aef 660A0000 		.4byte	.LASF87
 6590 0af3 01       		.byte	0x1
 6591 0af4 F507     		.2byte	0x7f5
 6592 0af6 44010000 		.4byte	0x144
 6593 0afa 02       		.uleb128 0x2
 6594 0afb 91       		.byte	0x91
 6595 0afc 70       		.sleb128 -16
 6596 0afd 1C       		.uleb128 0x1c
 6597 0afe 3B020000 		.4byte	.LASF122
 6598 0b02 01       		.byte	0x1
 6599 0b03 F607     		.2byte	0x7f6
 6600 0b05 39010000 		.4byte	0x139
 6601 0b09 02       		.uleb128 0x2
 6602 0b0a 91       		.byte	0x91
 6603 0b0b 74       		.sleb128 -12
 6604 0b0c 00       		.byte	0
 6605 0b0d 28       		.uleb128 0x28
 6606 0b0e 16020000 		.4byte	.LASF171
 6607 0b12 01       		.byte	0x1
 6608 0b13 1208     		.2byte	0x812
 6609 0b15 39010000 		.4byte	0x139
 6610 0b19 00000000 		.4byte	.LFB88
 6611 0b1d 18000000 		.4byte	.LFE88-.LFB88
 6612 0b21 01       		.uleb128 0x1
 6613 0b22 9C       		.byte	0x9c
 6614 0b23 21       		.uleb128 0x21
 6615 0b24 C80A0000 		.4byte	.LASF130
 6616 0b28 01       		.byte	0x1
 6617 0b29 1A08     		.2byte	0x81a
 6618 0b2b AB000000 		.4byte	0xab
 6619 0b2f 00000000 		.4byte	.LFB89
 6620 0b33 2C000000 		.4byte	.LFE89-.LFB89
 6621 0b37 01       		.uleb128 0x1
 6622 0b38 9C       		.byte	0x9c
 6623 0b39 5C0B0000 		.4byte	0xb5c
 6624 0b3d 1B       		.uleb128 0x1b
 6625 0b3e AE080000 		.4byte	.LASF131
 6626 0b42 01       		.byte	0x1
 6627 0b43 1A08     		.2byte	0x81a
 6628 0b45 2D020000 		.4byte	0x22d
 6629 0b49 02       		.uleb128 0x2
 6630 0b4a 91       		.byte	0x91
 6631 0b4b 6C       		.sleb128 -20
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 205


 6632 0b4c 1C       		.uleb128 0x1c
 6633 0b4d 0E0D0000 		.4byte	.LASF92
 6634 0b51 01       		.byte	0x1
 6635 0b52 1C08     		.2byte	0x81c
 6636 0b54 E1040000 		.4byte	0x4e1
 6637 0b58 02       		.uleb128 0x2
 6638 0b59 91       		.byte	0x91
 6639 0b5a 74       		.sleb128 -12
 6640 0b5b 00       		.byte	0
 6641 0b5c 1A       		.uleb128 0x1a
 6642 0b5d A8010000 		.4byte	.LASF132
 6643 0b61 01       		.byte	0x1
 6644 0b62 5809     		.2byte	0x958
 6645 0b64 2E010000 		.4byte	0x12e
 6646 0b68 00000000 		.4byte	.LFB90
 6647 0b6c 5C010000 		.4byte	.LFE90-.LFB90
 6648 0b70 01       		.uleb128 0x1
 6649 0b71 9C       		.byte	0x9c
 6650 0b72 D60B0000 		.4byte	0xbd6
 6651 0b76 1C       		.uleb128 0x1c
 6652 0b77 0E0D0000 		.4byte	.LASF92
 6653 0b7b 01       		.byte	0x1
 6654 0b7c 5A09     		.2byte	0x95a
 6655 0b7e E1040000 		.4byte	0x4e1
 6656 0b82 02       		.uleb128 0x2
 6657 0b83 91       		.byte	0x91
 6658 0b84 68       		.sleb128 -24
 6659 0b85 1C       		.uleb128 0x1c
 6660 0b86 4E090000 		.4byte	.LASF27
 6661 0b8a 01       		.byte	0x1
 6662 0b8b 5B09     		.2byte	0x95b
 6663 0b8d 44010000 		.4byte	0x144
 6664 0b91 02       		.uleb128 0x2
 6665 0b92 91       		.byte	0x91
 6666 0b93 64       		.sleb128 -28
 6667 0b94 1C       		.uleb128 0x1c
 6668 0b95 05070000 		.4byte	.LASF133
 6669 0b99 01       		.byte	0x1
 6670 0b9a 5C09     		.2byte	0x95c
 6671 0b9c 2E010000 		.4byte	0x12e
 6672 0ba0 02       		.uleb128 0x2
 6673 0ba1 91       		.byte	0x91
 6674 0ba2 74       		.sleb128 -12
 6675 0ba3 1D       		.uleb128 0x1d
 6676 0ba4 12000000 		.4byte	.LBB42
 6677 0ba8 FC000000 		.4byte	.LBE42-.LBB42
 6678 0bac 1C       		.uleb128 0x1c
 6679 0bad 2A040000 		.4byte	.LASF100
 6680 0bb1 01       		.byte	0x1
 6681 0bb2 6609     		.2byte	0x966
 6682 0bb4 69060000 		.4byte	0x669
 6683 0bb8 02       		.uleb128 0x2
 6684 0bb9 91       		.byte	0x91
 6685 0bba 70       		.sleb128 -16
 6686 0bbb 1D       		.uleb128 0x1d
 6687 0bbc 26000000 		.4byte	.LBB43
 6688 0bc0 22000000 		.4byte	.LBE43-.LBB43
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 206


 6689 0bc4 1C       		.uleb128 0x1c
 6690 0bc5 8B040000 		.4byte	.LASF134
 6691 0bc9 01       		.byte	0x1
 6692 0bca 6E09     		.2byte	0x96e
 6693 0bcc FA060000 		.4byte	0x6fa
 6694 0bd0 02       		.uleb128 0x2
 6695 0bd1 91       		.byte	0x91
 6696 0bd2 6C       		.sleb128 -20
 6697 0bd3 00       		.byte	0
 6698 0bd4 00       		.byte	0
 6699 0bd5 00       		.byte	0
 6700 0bd6 20       		.uleb128 0x20
 6701 0bd7 F8080000 		.4byte	.LASF135
 6702 0bdb 01       		.byte	0x1
 6703 0bdc 5E0A     		.2byte	0xa5e
 6704 0bde 00000000 		.4byte	.LFB91
 6705 0be2 D4000000 		.4byte	.LFE91-.LFB91
 6706 0be6 01       		.uleb128 0x1
 6707 0be7 9C       		.byte	0x9c
 6708 0be8 7A0C0000 		.4byte	0xc7a
 6709 0bec 29       		.uleb128 0x29
 6710 0bed 1C000000 		.4byte	.LBB44
 6711 0bf1 4E000000 		.4byte	.LBE44-.LBB44
 6712 0bf5 180C0000 		.4byte	0xc18
 6713 0bf9 1C       		.uleb128 0x1c
 6714 0bfa 180B0000 		.4byte	.LASF136
 6715 0bfe 01       		.byte	0x1
 6716 0bff 870A     		.2byte	0xa87
 6717 0c01 7A0C0000 		.4byte	0xc7a
 6718 0c05 02       		.uleb128 0x2
 6719 0c06 91       		.byte	0x91
 6720 0c07 74       		.sleb128 -12
 6721 0c08 1C       		.uleb128 0x1c
 6722 0c09 20070000 		.4byte	.LASF137
 6723 0c0d 01       		.byte	0x1
 6724 0c0e 870A     		.2byte	0xa87
 6725 0c10 83050000 		.4byte	0x583
 6726 0c14 02       		.uleb128 0x2
 6727 0c15 91       		.byte	0x91
 6728 0c16 70       		.sleb128 -16
 6729 0c17 00       		.byte	0
 6730 0c18 1D       		.uleb128 0x1d
 6731 0c19 6A000000 		.4byte	.LBB45
 6732 0c1d 50000000 		.4byte	.LBE45-.LBB45
 6733 0c21 1C       		.uleb128 0x1c
 6734 0c22 AD0B0000 		.4byte	.LASF138
 6735 0c26 01       		.byte	0x1
 6736 0c27 8B0A     		.2byte	0xa8b
 6737 0c29 39010000 		.4byte	0x139
 6738 0c2d 02       		.uleb128 0x2
 6739 0c2e 91       		.byte	0x91
 6740 0c2f 6C       		.sleb128 -20
 6741 0c30 22       		.uleb128 0x22
 6742 0c31 F9030000 		.4byte	0x3f9
 6743 0c35 70000000 		.4byte	.LBB46
 6744 0c39 0A000000 		.4byte	.LBE46-.LBB46
 6745 0c3d 01       		.byte	0x1
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 207


 6746 0c3e 8B0A     		.2byte	0xa8b
 6747 0c40 5F0C0000 		.4byte	0xc5f
 6748 0c44 25       		.uleb128 0x25
 6749 0c45 09040000 		.4byte	0x409
 6750 0c49 02       		.uleb128 0x2
 6751 0c4a 91       		.byte	0x91
 6752 0c4b 64       		.sleb128 -28
 6753 0c4c 1D       		.uleb128 0x1d
 6754 0c4d 70000000 		.4byte	.LBB47
 6755 0c51 0A000000 		.4byte	.LBE47-.LBB47
 6756 0c55 23       		.uleb128 0x23
 6757 0c56 14040000 		.4byte	0x414
 6758 0c5a 02       		.uleb128 0x2
 6759 0c5b 91       		.byte	0x91
 6760 0c5c 63       		.sleb128 -29
 6761 0c5d 00       		.byte	0
 6762 0c5e 00       		.byte	0
 6763 0c5f 1D       		.uleb128 0x1d
 6764 0c60 80000000 		.4byte	.LBB48
 6765 0c64 3A000000 		.4byte	.LBE48-.LBB48
 6766 0c68 1C       		.uleb128 0x1c
 6767 0c69 26000000 		.4byte	.LASF139
 6768 0c6d 01       		.byte	0x1
 6769 0c6e 8B0A     		.2byte	0xa8b
 6770 0c70 850C0000 		.4byte	0xc85
 6771 0c74 02       		.uleb128 0x2
 6772 0c75 91       		.byte	0x91
 6773 0c76 68       		.sleb128 -24
 6774 0c77 00       		.byte	0
 6775 0c78 00       		.byte	0
 6776 0c79 00       		.byte	0
 6777 0c7a 07       		.uleb128 0x7
 6778 0c7b 7F0C0000 		.4byte	0xc7f
 6779 0c7f 06       		.uleb128 0x6
 6780 0c80 04       		.byte	0x4
 6781 0c81 83050000 		.4byte	0x583
 6782 0c85 07       		.uleb128 0x7
 6783 0c86 FA060000 		.4byte	0x6fa
 6784 0c8a 20       		.uleb128 0x20
 6785 0c8b 92040000 		.4byte	.LASF140
 6786 0c8f 01       		.byte	0x1
 6787 0c90 990A     		.2byte	0xa99
 6788 0c92 00000000 		.4byte	.LFB92
 6789 0c96 2C000000 		.4byte	.LFE92-.LFB92
 6790 0c9a 01       		.uleb128 0x1
 6791 0c9b 9C       		.byte	0x9c
 6792 0c9c BF0C0000 		.4byte	0xcbf
 6793 0ca0 1B       		.uleb128 0x1b
 6794 0ca1 CE000000 		.4byte	.LASF141
 6795 0ca5 01       		.byte	0x1
 6796 0ca6 990A     		.2byte	0xa99
 6797 0ca8 850C0000 		.4byte	0xc85
 6798 0cac 02       		.uleb128 0x2
 6799 0cad 91       		.byte	0x91
 6800 0cae 74       		.sleb128 -12
 6801 0caf 1B       		.uleb128 0x1b
 6802 0cb0 050C0000 		.4byte	.LASF142
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 208


 6803 0cb4 01       		.byte	0x1
 6804 0cb5 990A     		.2byte	0xa99
 6805 0cb7 69060000 		.4byte	0x669
 6806 0cbb 02       		.uleb128 0x2
 6807 0cbc 91       		.byte	0x91
 6808 0cbd 70       		.sleb128 -16
 6809 0cbe 00       		.byte	0
 6810 0cbf 20       		.uleb128 0x20
 6811 0cc0 3D0B0000 		.4byte	.LASF143
 6812 0cc4 01       		.byte	0x1
 6813 0cc5 AA0A     		.2byte	0xaaa
 6814 0cc7 00000000 		.4byte	.LFB93
 6815 0ccb 38000000 		.4byte	.LFE93-.LFB93
 6816 0ccf 01       		.uleb128 0x1
 6817 0cd0 9C       		.byte	0x9c
 6818 0cd1 030D0000 		.4byte	0xd03
 6819 0cd5 1B       		.uleb128 0x1b
 6820 0cd6 CE000000 		.4byte	.LASF141
 6821 0cda 01       		.byte	0x1
 6822 0cdb AA0A     		.2byte	0xaaa
 6823 0cdd FA060000 		.4byte	0x6fa
 6824 0ce1 02       		.uleb128 0x2
 6825 0ce2 91       		.byte	0x91
 6826 0ce3 74       		.sleb128 -12
 6827 0ce4 1B       		.uleb128 0x1b
 6828 0ce5 4E090000 		.4byte	.LASF27
 6829 0ce9 01       		.byte	0x1
 6830 0cea AA0A     		.2byte	0xaaa
 6831 0cec 69060000 		.4byte	0x669
 6832 0cf0 02       		.uleb128 0x2
 6833 0cf1 91       		.byte	0x91
 6834 0cf2 70       		.sleb128 -16
 6835 0cf3 1B       		.uleb128 0x1b
 6836 0cf4 050C0000 		.4byte	.LASF142
 6837 0cf8 01       		.byte	0x1
 6838 0cf9 AA0A     		.2byte	0xaaa
 6839 0cfb 69060000 		.4byte	0x669
 6840 0cff 02       		.uleb128 0x2
 6841 0d00 91       		.byte	0x91
 6842 0d01 6C       		.sleb128 -20
 6843 0d02 00       		.byte	0
 6844 0d03 1A       		.uleb128 0x1a
 6845 0d04 07050000 		.4byte	.LASF144
 6846 0d08 01       		.byte	0x1
 6847 0d09 E30A     		.2byte	0xae3
 6848 0d0b 2E010000 		.4byte	0x12e
 6849 0d0f 00000000 		.4byte	.LFB94
 6850 0d13 AC000000 		.4byte	.LFE94-.LFB94
 6851 0d17 01       		.uleb128 0x1
 6852 0d18 9C       		.byte	0x9c
 6853 0d19 4B0D0000 		.4byte	0xd4b
 6854 0d1d 1B       		.uleb128 0x1b
 6855 0d1e CE000000 		.4byte	.LASF141
 6856 0d22 01       		.byte	0x1
 6857 0d23 E30A     		.2byte	0xae3
 6858 0d25 4B0D0000 		.4byte	0xd4b
 6859 0d29 02       		.uleb128 0x2
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 209


 6860 0d2a 91       		.byte	0x91
 6861 0d2b 6C       		.sleb128 -20
 6862 0d2c 1C       		.uleb128 0x1c
 6863 0d2d A3020000 		.4byte	.LASF145
 6864 0d31 01       		.byte	0x1
 6865 0d32 E50A     		.2byte	0xae5
 6866 0d34 E1040000 		.4byte	0x4e1
 6867 0d38 02       		.uleb128 0x2
 6868 0d39 91       		.byte	0x91
 6869 0d3a 70       		.sleb128 -16
 6870 0d3b 1C       		.uleb128 0x1c
 6871 0d3c 660A0000 		.4byte	.LASF87
 6872 0d40 01       		.byte	0x1
 6873 0d41 E60A     		.2byte	0xae6
 6874 0d43 2E010000 		.4byte	0x12e
 6875 0d47 02       		.uleb128 0x2
 6876 0d48 91       		.byte	0x91
 6877 0d49 74       		.sleb128 -12
 6878 0d4a 00       		.byte	0
 6879 0d4b 07       		.uleb128 0x7
 6880 0d4c 500D0000 		.4byte	0xd50
 6881 0d50 06       		.uleb128 0x6
 6882 0d51 04       		.byte	0x4
 6883 0d52 560D0000 		.4byte	0xd56
 6884 0d56 07       		.uleb128 0x7
 6885 0d57 22020000 		.4byte	0x222
 6886 0d5b 1A       		.uleb128 0x1a
 6887 0d5c 5C0B0000 		.4byte	.LASF146
 6888 0d60 01       		.byte	0x1
 6889 0d61 270B     		.2byte	0xb27
 6890 0d63 2E010000 		.4byte	0x12e
 6891 0d67 00000000 		.4byte	.LFB95
 6892 0d6b 94000000 		.4byte	.LFE95-.LFB95
 6893 0d6f 01       		.uleb128 0x1
 6894 0d70 9C       		.byte	0x9c
 6895 0d71 B20D0000 		.4byte	0xdb2
 6896 0d75 1B       		.uleb128 0x1b
 6897 0d76 780D0000 		.4byte	.LASF147
 6898 0d7a 01       		.byte	0x1
 6899 0d7b 270B     		.2byte	0xb27
 6900 0d7d 1C020000 		.4byte	0x21c
 6901 0d81 02       		.uleb128 0x2
 6902 0d82 91       		.byte	0x91
 6903 0d83 6C       		.sleb128 -20
 6904 0d84 1B       		.uleb128 0x1b
 6905 0d85 4E090000 		.4byte	.LASF27
 6906 0d89 01       		.byte	0x1
 6907 0d8a 270B     		.2byte	0xb27
 6908 0d8c 69060000 		.4byte	0x669
 6909 0d90 02       		.uleb128 0x2
 6910 0d91 91       		.byte	0x91
 6911 0d92 68       		.sleb128 -24
 6912 0d93 1C       		.uleb128 0x1c
 6913 0d94 A3020000 		.4byte	.LASF145
 6914 0d98 01       		.byte	0x1
 6915 0d99 290B     		.2byte	0xb29
 6916 0d9b E1040000 		.4byte	0x4e1
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 210


 6917 0d9f 02       		.uleb128 0x2
 6918 0da0 91       		.byte	0x91
 6919 0da1 70       		.sleb128 -16
 6920 0da2 1C       		.uleb128 0x1c
 6921 0da3 660A0000 		.4byte	.LASF87
 6922 0da7 01       		.byte	0x1
 6923 0da8 2A0B     		.2byte	0xb2a
 6924 0daa 2E010000 		.4byte	0x12e
 6925 0dae 02       		.uleb128 0x2
 6926 0daf 91       		.byte	0x91
 6927 0db0 74       		.sleb128 -12
 6928 0db1 00       		.byte	0
 6929 0db2 2A       		.uleb128 0x2a
 6930 0db3 79010000 		.4byte	.LASF148
 6931 0db7 01       		.byte	0x1
 6932 0db8 540B     		.2byte	0xb54
 6933 0dba 00000000 		.4byte	.LFB96
 6934 0dbe 2C000000 		.4byte	.LFE96-.LFB96
 6935 0dc2 01       		.uleb128 0x1
 6936 0dc3 9C       		.byte	0x9c
 6937 0dc4 D80D0000 		.4byte	0xdd8
 6938 0dc8 1B       		.uleb128 0x1b
 6939 0dc9 0B080000 		.4byte	.LASF149
 6940 0dcd 01       		.byte	0x1
 6941 0dce 540B     		.2byte	0xb54
 6942 0dd0 D80D0000 		.4byte	0xdd8
 6943 0dd4 02       		.uleb128 0x2
 6944 0dd5 91       		.byte	0x91
 6945 0dd6 74       		.sleb128 -12
 6946 0dd7 00       		.byte	0
 6947 0dd8 07       		.uleb128 0x7
 6948 0dd9 DD0D0000 		.4byte	0xddd
 6949 0ddd 06       		.uleb128 0x6
 6950 0dde 04       		.byte	0x4
 6951 0ddf C7020000 		.4byte	0x2c7
 6952 0de3 1A       		.uleb128 0x1a
 6953 0de4 F9090000 		.4byte	.LASF150
 6954 0de8 01       		.byte	0x1
 6955 0de9 5C0B     		.2byte	0xb5c
 6956 0deb 2E010000 		.4byte	0x12e
 6957 0def 00000000 		.4byte	.LFB97
 6958 0df3 88000000 		.4byte	.LFE97-.LFB97
 6959 0df7 01       		.uleb128 0x1
 6960 0df8 9C       		.byte	0x9c
 6961 0df9 440E0000 		.4byte	0xe44
 6962 0dfd 1B       		.uleb128 0x1b
 6963 0dfe 0B080000 		.4byte	.LASF149
 6964 0e02 01       		.byte	0x1
 6965 0e03 5C0B     		.2byte	0xb5c
 6966 0e05 D80D0000 		.4byte	0xdd8
 6967 0e09 02       		.uleb128 0x2
 6968 0e0a 91       		.byte	0x91
 6969 0e0b 6C       		.sleb128 -20
 6970 0e0c 1B       		.uleb128 0x1b
 6971 0e0d 9F0B0000 		.4byte	.LASF151
 6972 0e11 01       		.byte	0x1
 6973 0e12 5C0B     		.2byte	0xb5c
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 211


 6974 0e14 5E060000 		.4byte	0x65e
 6975 0e18 02       		.uleb128 0x2
 6976 0e19 91       		.byte	0x91
 6977 0e1a 68       		.sleb128 -24
 6978 0e1b 1C       		.uleb128 0x1c
 6979 0e1c 660A0000 		.4byte	.LASF87
 6980 0e20 01       		.byte	0x1
 6981 0e21 5E0B     		.2byte	0xb5e
 6982 0e23 2E010000 		.4byte	0x12e
 6983 0e27 02       		.uleb128 0x2
 6984 0e28 91       		.byte	0x91
 6985 0e29 74       		.sleb128 -12
 6986 0e2a 1D       		.uleb128 0x1d
 6987 0e2b 0E000000 		.4byte	.LBB49
 6988 0e2f 64000000 		.4byte	.LBE49-.LBB49
 6989 0e33 1C       		.uleb128 0x1c
 6990 0e34 2A040000 		.4byte	.LASF100
 6991 0e38 01       		.byte	0x1
 6992 0e39 660B     		.2byte	0xb66
 6993 0e3b 69060000 		.4byte	0x669
 6994 0e3f 02       		.uleb128 0x2
 6995 0e40 91       		.byte	0x91
 6996 0e41 70       		.sleb128 -16
 6997 0e42 00       		.byte	0
 6998 0e43 00       		.byte	0
 6999 0e44 27       		.uleb128 0x27
 7000 0e45 770A0000 		.4byte	.LASF153
 7001 0e49 01       		.byte	0x1
 7002 0e4a 990B     		.2byte	0xb99
 7003 0e4c 00000000 		.4byte	.LFB98
 7004 0e50 18000000 		.4byte	.LFE98-.LFB98
 7005 0e54 01       		.uleb128 0x1
 7006 0e55 9C       		.byte	0x9c
 7007 0e56 1E       		.uleb128 0x1e
 7008 0e57 7D050000 		.4byte	.LASF154
 7009 0e5b 01       		.byte	0x1
 7010 0e5c D00B     		.2byte	0xbd0
 7011 0e5e 00000000 		.4byte	.LFB99
 7012 0e62 0E000000 		.4byte	.LFE99-.LFB99
 7013 0e66 01       		.uleb128 0x1
 7014 0e67 9C       		.byte	0x9c
 7015 0e68 7C0E0000 		.4byte	0xe7c
 7016 0e6c 1B       		.uleb128 0x1b
 7017 0e6d 41090000 		.4byte	.LASF84
 7018 0e71 01       		.byte	0x1
 7019 0e72 D00B     		.2byte	0xbd0
 7020 0e74 A9000000 		.4byte	0xa9
 7021 0e78 02       		.uleb128 0x2
 7022 0e79 91       		.byte	0x91
 7023 0e7a 74       		.sleb128 -12
 7024 0e7b 00       		.byte	0
 7025 0e7c 1E       		.uleb128 0x1e
 7026 0e7d 610D0000 		.4byte	.LASF155
 7027 0e81 01       		.byte	0x1
 7028 0e82 9A0C     		.2byte	0xc9a
 7029 0e84 00000000 		.4byte	.LFB100
 7030 0e88 7C000000 		.4byte	.LFE100-.LFB100
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 212


 7031 0e8c 01       		.uleb128 0x1
 7032 0e8d 9C       		.byte	0x9c
 7033 0e8e A20E0000 		.4byte	0xea2
 7034 0e92 1C       		.uleb128 0x1c
 7035 0e93 1B000000 		.4byte	.LASF63
 7036 0e97 01       		.byte	0x1
 7037 0e98 9C0C     		.2byte	0xc9c
 7038 0e9a 39010000 		.4byte	0x139
 7039 0e9e 02       		.uleb128 0x2
 7040 0e9f 91       		.byte	0x91
 7041 0ea0 74       		.sleb128 -12
 7042 0ea1 00       		.byte	0
 7043 0ea2 1E       		.uleb128 0x1e
 7044 0ea3 960D0000 		.4byte	.LASF156
 7045 0ea7 01       		.byte	0x1
 7046 0ea8 BA0C     		.2byte	0xcba
 7047 0eaa 00000000 		.4byte	.LFB101
 7048 0eae 74000000 		.4byte	.LFE101-.LFB101
 7049 0eb2 01       		.uleb128 0x1
 7050 0eb3 9C       		.byte	0x9c
 7051 0eb4 EB0E0000 		.4byte	0xeeb
 7052 0eb8 1D       		.uleb128 0x1d
 7053 0eb9 06000000 		.4byte	.LBB50
 7054 0ebd 5C000000 		.4byte	.LBE50-.LBB50
 7055 0ec1 1C       		.uleb128 0x1c
 7056 0ec2 92050000 		.4byte	.LASF157
 7057 0ec6 01       		.byte	0x1
 7058 0ec7 C10C     		.2byte	0xcc1
 7059 0ec9 2E010000 		.4byte	0x12e
 7060 0ecd 02       		.uleb128 0x2
 7061 0ece 91       		.byte	0x91
 7062 0ecf 74       		.sleb128 -12
 7063 0ed0 1D       		.uleb128 0x1d
 7064 0ed1 26000000 		.4byte	.LBB51
 7065 0ed5 34000000 		.4byte	.LBE51-.LBB51
 7066 0ed9 1C       		.uleb128 0x1c
 7067 0eda 0E0D0000 		.4byte	.LASF92
 7068 0ede 01       		.byte	0x1
 7069 0edf CF0C     		.2byte	0xccf
 7070 0ee1 E1040000 		.4byte	0x4e1
 7071 0ee5 02       		.uleb128 0x2
 7072 0ee6 91       		.byte	0x91
 7073 0ee7 70       		.sleb128 -16
 7074 0ee8 00       		.byte	0
 7075 0ee9 00       		.byte	0
 7076 0eea 00       		.byte	0
 7077 0eeb 26       		.uleb128 0x26
 7078 0eec 670C0000 		.4byte	.LASF159
 7079 0ef0 01       		.byte	0x1
 7080 0ef1 620D     		.2byte	0xd62
 7081 0ef3 CE000000 		.4byte	0xce
 7082 0ef7 00000000 		.4byte	.LFB102
 7083 0efb 38000000 		.4byte	.LFE102-.LFB102
 7084 0eff 01       		.uleb128 0x1
 7085 0f00 9C       		.byte	0x9c
 7086 0f01 240F0000 		.4byte	0xf24
 7087 0f05 1B       		.uleb128 0x1b
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 213


 7088 0f06 F3030000 		.4byte	.LASF160
 7089 0f0a 01       		.byte	0x1
 7090 0f0b 620D     		.2byte	0xd62
 7091 0f0d 240F0000 		.4byte	0xf24
 7092 0f11 02       		.uleb128 0x2
 7093 0f12 91       		.byte	0x91
 7094 0f13 6C       		.sleb128 -20
 7095 0f14 1C       		.uleb128 0x1c
 7096 0f15 2E080000 		.4byte	.LASF161
 7097 0f19 01       		.byte	0x1
 7098 0f1a 640D     		.2byte	0xd64
 7099 0f1c E4000000 		.4byte	0xe4
 7100 0f20 02       		.uleb128 0x2
 7101 0f21 91       		.byte	0x91
 7102 0f22 74       		.sleb128 -12
 7103 0f23 00       		.byte	0
 7104 0f24 06       		.uleb128 0x6
 7105 0f25 04       		.byte	0x4
 7106 0f26 2A0F0000 		.4byte	0xf2a
 7107 0f2a 07       		.uleb128 0x7
 7108 0f2b C3000000 		.4byte	0xc3
 7109 0f2f 1A       		.uleb128 0x1a
 7110 0f30 A7030000 		.4byte	.LASF162
 7111 0f34 01       		.byte	0x1
 7112 0f35 760D     		.2byte	0xd76
 7113 0f37 39010000 		.4byte	0x139
 7114 0f3b 00000000 		.4byte	.LFB103
 7115 0f3f 38000000 		.4byte	.LFE103-.LFB103
 7116 0f43 01       		.uleb128 0x1
 7117 0f44 9C       		.byte	0x9c
 7118 0f45 860F0000 		.4byte	0xf86
 7119 0f49 1B       		.uleb128 0x1b
 7120 0f4a D4080000 		.4byte	.LASF105
 7121 0f4e 01       		.byte	0x1
 7122 0f4f 760D     		.2byte	0xd76
 7123 0f51 2D020000 		.4byte	0x22d
 7124 0f55 02       		.uleb128 0x2
 7125 0f56 91       		.byte	0x91
 7126 0f57 64       		.sleb128 -28
 7127 0f58 1C       		.uleb128 0x1c
 7128 0f59 0E0D0000 		.4byte	.LASF92
 7129 0f5d 01       		.byte	0x1
 7130 0f5e 780D     		.2byte	0xd78
 7131 0f60 E1040000 		.4byte	0x4e1
 7132 0f64 02       		.uleb128 0x2
 7133 0f65 91       		.byte	0x91
 7134 0f66 74       		.sleb128 -12
 7135 0f67 1C       		.uleb128 0x1c
 7136 0f68 BA0A0000 		.4byte	.LASF163
 7137 0f6c 01       		.byte	0x1
 7138 0f6d 790D     		.2byte	0xd79
 7139 0f6f 4F010000 		.4byte	0x14f
 7140 0f73 02       		.uleb128 0x2
 7141 0f74 91       		.byte	0x91
 7142 0f75 70       		.sleb128 -16
 7143 0f76 1C       		.uleb128 0x1c
 7144 0f77 0D020000 		.4byte	.LASF109
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 214


 7145 0f7b 01       		.byte	0x1
 7146 0f7c 7A0D     		.2byte	0xd7a
 7147 0f7e 39010000 		.4byte	0x139
 7148 0f82 02       		.uleb128 0x2
 7149 0f83 91       		.byte	0x91
 7150 0f84 6C       		.sleb128 -20
 7151 0f85 00       		.byte	0
 7152 0f86 1E       		.uleb128 0x1e
 7153 0f87 1A0C0000 		.4byte	.LASF164
 7154 0f8b 01       		.byte	0x1
 7155 0f8c 920D     		.2byte	0xd92
 7156 0f8e 00000000 		.4byte	.LFB104
 7157 0f92 1E000000 		.4byte	.LFE104-.LFB104
 7158 0f96 01       		.uleb128 0x1
 7159 0f97 9C       		.byte	0x9c
 7160 0f98 AC0F0000 		.4byte	0xfac
 7161 0f9c 1B       		.uleb128 0x1b
 7162 0f9d 0E0D0000 		.4byte	.LASF92
 7163 0fa1 01       		.byte	0x1
 7164 0fa2 920D     		.2byte	0xd92
 7165 0fa4 E1040000 		.4byte	0x4e1
 7166 0fa8 02       		.uleb128 0x2
 7167 0fa9 91       		.byte	0x91
 7168 0faa 74       		.sleb128 -12
 7169 0fab 00       		.byte	0
 7170 0fac 2B       		.uleb128 0x2b
 7171 0fad 2D070000 		.4byte	.LASF165
 7172 0fb1 01       		.byte	0x1
 7173 0fb2 BC0D     		.2byte	0xdbc
 7174 0fb4 00000000 		.4byte	.LFB105
 7175 0fb8 48000000 		.4byte	.LFE105-.LFB105
 7176 0fbc 01       		.uleb128 0x1
 7177 0fbd 9C       		.byte	0x9c
 7178 0fbe D20F0000 		.4byte	0xfd2
 7179 0fc2 1C       		.uleb128 0x1c
 7180 0fc3 0E0D0000 		.4byte	.LASF92
 7181 0fc7 01       		.byte	0x1
 7182 0fc8 BE0D     		.2byte	0xdbe
 7183 0fca E1040000 		.4byte	0x4e1
 7184 0fce 02       		.uleb128 0x2
 7185 0fcf 91       		.byte	0x91
 7186 0fd0 74       		.sleb128 -12
 7187 0fd1 00       		.byte	0
 7188 0fd2 21       		.uleb128 0x21
 7189 0fd3 4D0C0000 		.4byte	.LASF166
 7190 0fd7 01       		.byte	0x1
 7191 0fd8 D60D     		.2byte	0xdd6
 7192 0fda 2D020000 		.4byte	0x22d
 7193 0fde 00000000 		.4byte	.LFB106
 7194 0fe2 20000000 		.4byte	.LFE106-.LFB106
 7195 0fe6 01       		.uleb128 0x1
 7196 0fe7 9C       		.byte	0x9c
 7197 0fe8 FC0F0000 		.4byte	0xffc
 7198 0fec 1C       		.uleb128 0x1c
 7199 0fed 660A0000 		.4byte	.LASF87
 7200 0ff1 01       		.byte	0x1
 7201 0ff2 D80D     		.2byte	0xdd8
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 215


 7202 0ff4 2D020000 		.4byte	0x22d
 7203 0ff8 02       		.uleb128 0x2
 7204 0ff9 91       		.byte	0x91
 7205 0ffa 74       		.sleb128 -12
 7206 0ffb 00       		.byte	0
 7207 0ffc 20       		.uleb128 0x20
 7208 0ffd F4000000 		.4byte	.LASF167
 7209 1001 01       		.byte	0x1
 7210 1002 030E     		.2byte	0xe03
 7211 1004 00000000 		.4byte	.LFB107
 7212 1008 F0000000 		.4byte	.LFE107-.LFB107
 7213 100c 01       		.uleb128 0x1
 7214 100d 9C       		.byte	0x9c
 7215 100e 31100000 		.4byte	0x1031
 7216 1012 1B       		.uleb128 0x1b
 7217 1013 BE090000 		.4byte	.LASF168
 7218 1017 01       		.byte	0x1
 7219 1018 030E     		.2byte	0xe03
 7220 101a E5080000 		.4byte	0x8e5
 7221 101e 02       		.uleb128 0x2
 7222 101f 91       		.byte	0x91
 7223 1020 6C       		.sleb128 -20
 7224 1021 1C       		.uleb128 0x1c
 7225 1022 0E0D0000 		.4byte	.LASF92
 7226 1026 01       		.byte	0x1
 7227 1027 050E     		.2byte	0xe05
 7228 1029 1F090000 		.4byte	0x91f
 7229 102d 02       		.uleb128 0x2
 7230 102e 91       		.byte	0x91
 7231 102f 74       		.sleb128 -12
 7232 1030 00       		.byte	0
 7233 1031 1A       		.uleb128 0x1a
 7234 1032 EF040000 		.4byte	.LASF169
 7235 1036 01       		.byte	0x1
 7236 1037 450E     		.2byte	0xe45
 7237 1039 2E010000 		.4byte	0x12e
 7238 103d 00000000 		.4byte	.LFB108
 7239 1041 CC000000 		.4byte	.LFE108-.LFB108
 7240 1045 01       		.uleb128 0x1
 7241 1046 9C       		.byte	0x9c
 7242 1047 79100000 		.4byte	0x1079
 7243 104b 1B       		.uleb128 0x1b
 7244 104c BE090000 		.4byte	.LASF168
 7245 1050 01       		.byte	0x1
 7246 1051 450E     		.2byte	0xe45
 7247 1053 E5080000 		.4byte	0x8e5
 7248 1057 02       		.uleb128 0x2
 7249 1058 91       		.byte	0x91
 7250 1059 6C       		.sleb128 -20
 7251 105a 1C       		.uleb128 0x1c
 7252 105b 0E0D0000 		.4byte	.LASF92
 7253 105f 01       		.byte	0x1
 7254 1060 470E     		.2byte	0xe47
 7255 1062 1F090000 		.4byte	0x91f
 7256 1066 02       		.uleb128 0x2
 7257 1067 91       		.byte	0x91
 7258 1068 70       		.sleb128 -16
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 216


 7259 1069 1C       		.uleb128 0x1c
 7260 106a 660A0000 		.4byte	.LASF87
 7261 106e 01       		.byte	0x1
 7262 106f 480E     		.2byte	0xe48
 7263 1071 2E010000 		.4byte	0x12e
 7264 1075 02       		.uleb128 0x2
 7265 1076 91       		.byte	0x91
 7266 1077 74       		.sleb128 -12
 7267 1078 00       		.byte	0
 7268 1079 21       		.uleb128 0x21
 7269 107a 71080000 		.4byte	.LASF170
 7270 107e 01       		.byte	0x1
 7271 107f CB0F     		.2byte	0xfcb
 7272 1081 44010000 		.4byte	0x144
 7273 1085 00000000 		.4byte	.LFB109
 7274 1089 30000000 		.4byte	.LFE109-.LFB109
 7275 108d 01       		.uleb128 0x1
 7276 108e 9C       		.byte	0x9c
 7277 108f A3100000 		.4byte	0x10a3
 7278 1093 1C       		.uleb128 0x1c
 7279 1094 0D020000 		.4byte	.LASF109
 7280 1098 01       		.byte	0x1
 7281 1099 CD0F     		.2byte	0xfcd
 7282 109b 44010000 		.4byte	0x144
 7283 109f 02       		.uleb128 0x2
 7284 10a0 91       		.byte	0x91
 7285 10a1 74       		.sleb128 -12
 7286 10a2 00       		.byte	0
 7287 10a3 28       		.uleb128 0x28
 7288 10a4 B3040000 		.4byte	.LASF172
 7289 10a8 01       		.byte	0x1
 7290 10a9 DB0F     		.2byte	0xfdb
 7291 10ab A9000000 		.4byte	0xa9
 7292 10af 00000000 		.4byte	.LFB110
 7293 10b3 28000000 		.4byte	.LFE110-.LFB110
 7294 10b7 01       		.uleb128 0x1
 7295 10b8 9C       		.byte	0x9c
 7296 10b9 1A       		.uleb128 0x1a
 7297 10ba 9F050000 		.4byte	.LASF173
 7298 10be 01       		.byte	0x1
 7299 10bf EC0F     		.2byte	0xfec
 7300 10c1 E4000000 		.4byte	0xe4
 7301 10c5 00000000 		.4byte	.LFB111
 7302 10c9 90000000 		.4byte	.LFE111-.LFB111
 7303 10cd 01       		.uleb128 0x1
 7304 10ce 9C       		.byte	0x9c
 7305 10cf 01110000 		.4byte	0x1101
 7306 10d3 1B       		.uleb128 0x1b
 7307 10d4 BF020000 		.4byte	.LASF174
 7308 10d8 01       		.byte	0x1
 7309 10d9 EC0F     		.2byte	0xfec
 7310 10db 2E010000 		.4byte	0x12e
 7311 10df 02       		.uleb128 0x2
 7312 10e0 91       		.byte	0x91
 7313 10e1 6C       		.sleb128 -20
 7314 10e2 1B       		.uleb128 0x1b
 7315 10e3 050C0000 		.4byte	.LASF142
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 217


 7316 10e7 01       		.byte	0x1
 7317 10e8 EC0F     		.2byte	0xfec
 7318 10ea 44010000 		.4byte	0x144
 7319 10ee 02       		.uleb128 0x2
 7320 10ef 91       		.byte	0x91
 7321 10f0 68       		.sleb128 -24
 7322 10f1 1C       		.uleb128 0x1c
 7323 10f2 B60D0000 		.4byte	.LASF175
 7324 10f6 01       		.byte	0x1
 7325 10f7 EE0F     		.2byte	0xfee
 7326 10f9 E4000000 		.4byte	0xe4
 7327 10fd 02       		.uleb128 0x2
 7328 10fe 91       		.byte	0x91
 7329 10ff 74       		.sleb128 -12
 7330 1100 00       		.byte	0
 7331 1101 1A       		.uleb128 0x1a
 7332 1102 BF050000 		.4byte	.LASF176
 7333 1106 01       		.byte	0x1
 7334 1107 3010     		.2byte	0x1030
 7335 1109 2E010000 		.4byte	0x12e
 7336 110d 00000000 		.4byte	.LFB112
 7337 1111 B4000000 		.4byte	.LFE112-.LFB112
 7338 1115 01       		.uleb128 0x1
 7339 1116 9C       		.byte	0x9c
 7340 1117 67110000 		.4byte	0x1167
 7341 111b 1B       		.uleb128 0x1b
 7342 111c 2E030000 		.4byte	.LASF177
 7343 1120 01       		.byte	0x1
 7344 1121 3010     		.2byte	0x1030
 7345 1123 E4000000 		.4byte	0xe4
 7346 1127 02       		.uleb128 0x2
 7347 1128 91       		.byte	0x91
 7348 1129 6C       		.sleb128 -20
 7349 112a 1B       		.uleb128 0x1b
 7350 112b 61000000 		.4byte	.LASF178
 7351 112f 01       		.byte	0x1
 7352 1130 3010     		.2byte	0x1030
 7353 1132 E4000000 		.4byte	0xe4
 7354 1136 02       		.uleb128 0x2
 7355 1137 91       		.byte	0x91
 7356 1138 68       		.sleb128 -24
 7357 1139 1B       		.uleb128 0x1b
 7358 113a 510A0000 		.4byte	.LASF179
 7359 113e 01       		.byte	0x1
 7360 113f 3010     		.2byte	0x1030
 7361 1141 67110000 		.4byte	0x1167
 7362 1145 02       		.uleb128 0x2
 7363 1146 91       		.byte	0x91
 7364 1147 64       		.sleb128 -28
 7365 1148 1B       		.uleb128 0x1b
 7366 1149 050C0000 		.4byte	.LASF142
 7367 114d 01       		.byte	0x1
 7368 114e 3010     		.2byte	0x1030
 7369 1150 44010000 		.4byte	0x144
 7370 1154 02       		.uleb128 0x2
 7371 1155 91       		.byte	0x91
 7372 1156 60       		.sleb128 -32
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 218


 7373 1157 1C       		.uleb128 0x1c
 7374 1158 660A0000 		.4byte	.LASF87
 7375 115c 01       		.byte	0x1
 7376 115d 3210     		.2byte	0x1032
 7377 115f 2E010000 		.4byte	0x12e
 7378 1163 02       		.uleb128 0x2
 7379 1164 91       		.byte	0x91
 7380 1165 74       		.sleb128 -12
 7381 1166 00       		.byte	0
 7382 1167 06       		.uleb128 0x6
 7383 1168 04       		.byte	0x4
 7384 1169 E4000000 		.4byte	0xe4
 7385 116d 1A       		.uleb128 0x1a
 7386 116e 8A020000 		.4byte	.LASF180
 7387 1172 01       		.byte	0x1
 7388 1173 8010     		.2byte	0x1080
 7389 1175 2E010000 		.4byte	0x12e
 7390 1179 00000000 		.4byte	.LFB113
 7391 117d 10010000 		.4byte	.LFE113-.LFB113
 7392 1181 01       		.uleb128 0x1
 7393 1182 9C       		.byte	0x9c
 7394 1183 F1110000 		.4byte	0x11f1
 7395 1187 1B       		.uleb128 0x1b
 7396 1188 C6080000 		.4byte	.LASF181
 7397 118c 01       		.byte	0x1
 7398 118d 8010     		.2byte	0x1080
 7399 118f 2D020000 		.4byte	0x22d
 7400 1193 02       		.uleb128 0x2
 7401 1194 91       		.byte	0x91
 7402 1195 64       		.sleb128 -28
 7403 1196 1B       		.uleb128 0x1b
 7404 1197 E2090000 		.4byte	.LASF182
 7405 119b 01       		.byte	0x1
 7406 119c 8010     		.2byte	0x1080
 7407 119e E4000000 		.4byte	0xe4
 7408 11a2 02       		.uleb128 0x2
 7409 11a3 91       		.byte	0x91
 7410 11a4 60       		.sleb128 -32
 7411 11a5 1B       		.uleb128 0x1b
 7412 11a6 5A080000 		.4byte	.LASF183
 7413 11aa 01       		.byte	0x1
 7414 11ab 8010     		.2byte	0x1080
 7415 11ad 97020000 		.4byte	0x297
 7416 11b1 02       		.uleb128 0x2
 7417 11b2 91       		.byte	0x91
 7418 11b3 5F       		.sleb128 -33
 7419 11b4 1B       		.uleb128 0x1b
 7420 11b5 340A0000 		.4byte	.LASF184
 7421 11b9 01       		.byte	0x1
 7422 11ba 8010     		.2byte	0x1080
 7423 11bc 67110000 		.4byte	0x1167
 7424 11c0 02       		.uleb128 0x2
 7425 11c1 91       		.byte	0x91
 7426 11c2 58       		.sleb128 -40
 7427 11c3 1C       		.uleb128 0x1c
 7428 11c4 0E0D0000 		.4byte	.LASF92
 7429 11c8 01       		.byte	0x1
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 219


 7430 11c9 8210     		.2byte	0x1082
 7431 11cb E1040000 		.4byte	0x4e1
 7432 11cf 02       		.uleb128 0x2
 7433 11d0 91       		.byte	0x91
 7434 11d1 70       		.sleb128 -16
 7435 11d2 1C       		.uleb128 0x1c
 7436 11d3 660A0000 		.4byte	.LASF87
 7437 11d7 01       		.byte	0x1
 7438 11d8 8310     		.2byte	0x1083
 7439 11da 2E010000 		.4byte	0x12e
 7440 11de 02       		.uleb128 0x2
 7441 11df 91       		.byte	0x91
 7442 11e0 74       		.sleb128 -12
 7443 11e1 1C       		.uleb128 0x1c
 7444 11e2 63010000 		.4byte	.LASF185
 7445 11e6 01       		.byte	0x1
 7446 11e7 8410     		.2byte	0x1084
 7447 11e9 C3000000 		.4byte	0xc3
 7448 11ed 02       		.uleb128 0x2
 7449 11ee 91       		.byte	0x91
 7450 11ef 6F       		.sleb128 -17
 7451 11f0 00       		.byte	0
 7452 11f1 1A       		.uleb128 0x1a
 7453 11f2 8E010000 		.4byte	.LASF186
 7454 11f6 01       		.byte	0x1
 7455 11f7 EA10     		.2byte	0x10ea
 7456 11f9 2E010000 		.4byte	0x12e
 7457 11fd 00000000 		.4byte	.LFB114
 7458 1201 54010000 		.4byte	.LFE114-.LFB114
 7459 1205 01       		.uleb128 0x1
 7460 1206 9C       		.byte	0x9c
 7461 1207 DB120000 		.4byte	0x12db
 7462 120b 1B       		.uleb128 0x1b
 7463 120c C6080000 		.4byte	.LASF181
 7464 1210 01       		.byte	0x1
 7465 1211 EA10     		.2byte	0x10ea
 7466 1213 2D020000 		.4byte	0x22d
 7467 1217 02       		.uleb128 0x2
 7468 1218 91       		.byte	0x91
 7469 1219 54       		.sleb128 -44
 7470 121a 1B       		.uleb128 0x1b
 7471 121b E2090000 		.4byte	.LASF182
 7472 121f 01       		.byte	0x1
 7473 1220 EA10     		.2byte	0x10ea
 7474 1222 E4000000 		.4byte	0xe4
 7475 1226 02       		.uleb128 0x2
 7476 1227 91       		.byte	0x91
 7477 1228 50       		.sleb128 -48
 7478 1229 1B       		.uleb128 0x1b
 7479 122a 5A080000 		.4byte	.LASF183
 7480 122e 01       		.byte	0x1
 7481 122f EA10     		.2byte	0x10ea
 7482 1231 97020000 		.4byte	0x297
 7483 1235 02       		.uleb128 0x2
 7484 1236 91       		.byte	0x91
 7485 1237 4F       		.sleb128 -49
 7486 1238 1B       		.uleb128 0x1b
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 220


 7487 1239 340A0000 		.4byte	.LASF184
 7488 123d 01       		.byte	0x1
 7489 123e EA10     		.2byte	0x10ea
 7490 1240 67110000 		.4byte	0x1167
 7491 1244 02       		.uleb128 0x2
 7492 1245 91       		.byte	0x91
 7493 1246 48       		.sleb128 -56
 7494 1247 1B       		.uleb128 0x1b
 7495 1248 8A000000 		.4byte	.LASF187
 7496 124c 01       		.byte	0x1
 7497 124d EA10     		.2byte	0x10ea
 7498 124f DB120000 		.4byte	0x12db
 7499 1253 02       		.uleb128 0x2
 7500 1254 91       		.byte	0x91
 7501 1255 00       		.sleb128 0
 7502 1256 1C       		.uleb128 0x1c
 7503 1257 0E0D0000 		.4byte	.LASF92
 7504 125b 01       		.byte	0x1
 7505 125c EC10     		.2byte	0x10ec
 7506 125e E1040000 		.4byte	0x4e1
 7507 1262 02       		.uleb128 0x2
 7508 1263 91       		.byte	0x91
 7509 1264 70       		.sleb128 -16
 7510 1265 1C       		.uleb128 0x1c
 7511 1266 63010000 		.4byte	.LASF185
 7512 126a 01       		.byte	0x1
 7513 126b ED10     		.2byte	0x10ed
 7514 126d C3000000 		.4byte	0xc3
 7515 1271 02       		.uleb128 0x2
 7516 1272 91       		.byte	0x91
 7517 1273 6B       		.sleb128 -21
 7518 1274 1C       		.uleb128 0x1c
 7519 1275 660A0000 		.4byte	.LASF87
 7520 1279 01       		.byte	0x1
 7521 127a EE10     		.2byte	0x10ee
 7522 127c 2E010000 		.4byte	0x12e
 7523 1280 02       		.uleb128 0x2
 7524 1281 91       		.byte	0x91
 7525 1282 74       		.sleb128 -12
 7526 1283 1C       		.uleb128 0x1c
 7527 1284 3B020000 		.4byte	.LASF122
 7528 1288 01       		.byte	0x1
 7529 1289 EF10     		.2byte	0x10ef
 7530 128b 39010000 		.4byte	0x139
 7531 128f 02       		.uleb128 0x2
 7532 1290 91       		.byte	0x91
 7533 1291 6C       		.sleb128 -20
 7534 1292 22       		.uleb128 0x22
 7535 1293 A0030000 		.4byte	0x3a0
 7536 1297 18000000 		.4byte	.LBB52
 7537 129b 1A000000 		.4byte	.LBE52-.LBB52
 7538 129f 01       		.byte	0x1
 7539 12a0 0711     		.2byte	0x1107
 7540 12a2 C1120000 		.4byte	0x12c1
 7541 12a6 1D       		.uleb128 0x1d
 7542 12a7 18000000 		.4byte	.LBB53
 7543 12ab 1A000000 		.4byte	.LBE53-.LBB53
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 221


 7544 12af 23       		.uleb128 0x23
 7545 12b0 B0030000 		.4byte	0x3b0
 7546 12b4 02       		.uleb128 0x2
 7547 12b5 91       		.byte	0x91
 7548 12b6 64       		.sleb128 -28
 7549 12b7 23       		.uleb128 0x23
 7550 12b8 BB030000 		.4byte	0x3bb
 7551 12bc 02       		.uleb128 0x2
 7552 12bd 91       		.byte	0x91
 7553 12be 60       		.sleb128 -32
 7554 12bf 00       		.byte	0
 7555 12c0 00       		.byte	0
 7556 12c1 24       		.uleb128 0x24
 7557 12c2 C7030000 		.4byte	0x3c7
 7558 12c6 2C010000 		.4byte	.LBB54
 7559 12ca 06000000 		.4byte	.LBE54-.LBB54
 7560 12ce 01       		.byte	0x1
 7561 12cf 5C11     		.2byte	0x115c
 7562 12d1 25       		.uleb128 0x25
 7563 12d2 D4030000 		.4byte	0x3d4
 7564 12d6 02       		.uleb128 0x2
 7565 12d7 91       		.byte	0x91
 7566 12d8 5C       		.sleb128 -36
 7567 12d9 00       		.byte	0
 7568 12da 00       		.byte	0
 7569 12db 06       		.uleb128 0x6
 7570 12dc 04       		.byte	0x4
 7571 12dd 2E010000 		.4byte	0x12e
 7572 12e1 20       		.uleb128 0x20
 7573 12e2 7E090000 		.4byte	.LASF188
 7574 12e6 01       		.byte	0x1
 7575 12e7 6611     		.2byte	0x1166
 7576 12e9 00000000 		.4byte	.LFB115
 7577 12ed E8000000 		.4byte	.LFE115-.LFB115
 7578 12f1 01       		.uleb128 0x1
 7579 12f2 9C       		.byte	0x9c
 7580 12f3 8B130000 		.4byte	0x138b
 7581 12f7 1B       		.uleb128 0x1b
 7582 12f8 C6080000 		.4byte	.LASF181
 7583 12fc 01       		.byte	0x1
 7584 12fd 6611     		.2byte	0x1166
 7585 12ff 2D020000 		.4byte	0x22d
 7586 1303 02       		.uleb128 0x2
 7587 1304 91       		.byte	0x91
 7588 1305 5C       		.sleb128 -36
 7589 1306 1B       		.uleb128 0x1b
 7590 1307 8A000000 		.4byte	.LASF187
 7591 130b 01       		.byte	0x1
 7592 130c 6611     		.2byte	0x1166
 7593 130e DB120000 		.4byte	0x12db
 7594 1312 02       		.uleb128 0x2
 7595 1313 91       		.byte	0x91
 7596 1314 58       		.sleb128 -40
 7597 1315 1C       		.uleb128 0x1c
 7598 1316 0E0D0000 		.4byte	.LASF92
 7599 131a 01       		.byte	0x1
 7600 131b 6811     		.2byte	0x1168
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 222


 7601 131d E1040000 		.4byte	0x4e1
 7602 1321 02       		.uleb128 0x2
 7603 1322 91       		.byte	0x91
 7604 1323 74       		.sleb128 -12
 7605 1324 1C       		.uleb128 0x1c
 7606 1325 63010000 		.4byte	.LASF185
 7607 1329 01       		.byte	0x1
 7608 132a 6911     		.2byte	0x1169
 7609 132c C3000000 		.4byte	0xc3
 7610 1330 02       		.uleb128 0x2
 7611 1331 91       		.byte	0x91
 7612 1332 6F       		.sleb128 -17
 7613 1333 1C       		.uleb128 0x1c
 7614 1334 3B020000 		.4byte	.LASF122
 7615 1338 01       		.byte	0x1
 7616 1339 6A11     		.2byte	0x116a
 7617 133b 39010000 		.4byte	0x139
 7618 133f 02       		.uleb128 0x2
 7619 1340 91       		.byte	0x91
 7620 1341 70       		.sleb128 -16
 7621 1342 22       		.uleb128 0x22
 7622 1343 A0030000 		.4byte	0x3a0
 7623 1347 0E000000 		.4byte	.LBB56
 7624 134b 1A000000 		.4byte	.LBE56-.LBB56
 7625 134f 01       		.byte	0x1
 7626 1350 8211     		.2byte	0x1182
 7627 1352 71130000 		.4byte	0x1371
 7628 1356 1D       		.uleb128 0x1d
 7629 1357 0E000000 		.4byte	.LBB57
 7630 135b 1A000000 		.4byte	.LBE57-.LBB57
 7631 135f 23       		.uleb128 0x23
 7632 1360 B0030000 		.4byte	0x3b0
 7633 1364 02       		.uleb128 0x2
 7634 1365 91       		.byte	0x91
 7635 1366 68       		.sleb128 -24
 7636 1367 23       		.uleb128 0x23
 7637 1368 BB030000 		.4byte	0x3bb
 7638 136c 02       		.uleb128 0x2
 7639 136d 91       		.byte	0x91
 7640 136e 64       		.sleb128 -28
 7641 136f 00       		.byte	0
 7642 1370 00       		.byte	0
 7643 1371 24       		.uleb128 0x24
 7644 1372 C7030000 		.4byte	0x3c7
 7645 1376 C2000000 		.4byte	.LBB58
 7646 137a 06000000 		.4byte	.LBE58-.LBB58
 7647 137e 01       		.byte	0x1
 7648 137f B611     		.2byte	0x11b6
 7649 1381 25       		.uleb128 0x25
 7650 1382 D4030000 		.4byte	0x3d4
 7651 1386 02       		.uleb128 0x2
 7652 1387 91       		.byte	0x91
 7653 1388 60       		.sleb128 -32
 7654 1389 00       		.byte	0
 7655 138a 00       		.byte	0
 7656 138b 1A       		.uleb128 0x1a
 7657 138c 890B0000 		.4byte	.LASF189
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 223


 7658 1390 01       		.byte	0x1
 7659 1391 BF11     		.2byte	0x11bf
 7660 1393 2E010000 		.4byte	0x12e
 7661 1397 00000000 		.4byte	.LFB116
 7662 139b 4C000000 		.4byte	.LFE116-.LFB116
 7663 139f 01       		.uleb128 0x1
 7664 13a0 9C       		.byte	0x9c
 7665 13a1 D3130000 		.4byte	0x13d3
 7666 13a5 1B       		.uleb128 0x1b
 7667 13a6 D4080000 		.4byte	.LASF105
 7668 13aa 01       		.byte	0x1
 7669 13ab BF11     		.2byte	0x11bf
 7670 13ad 2D020000 		.4byte	0x22d
 7671 13b1 02       		.uleb128 0x2
 7672 13b2 91       		.byte	0x91
 7673 13b3 6C       		.sleb128 -20
 7674 13b4 1C       		.uleb128 0x1c
 7675 13b5 0E0D0000 		.4byte	.LASF92
 7676 13b9 01       		.byte	0x1
 7677 13ba C111     		.2byte	0x11c1
 7678 13bc E1040000 		.4byte	0x4e1
 7679 13c0 02       		.uleb128 0x2
 7680 13c1 91       		.byte	0x91
 7681 13c2 70       		.sleb128 -16
 7682 13c3 1C       		.uleb128 0x1c
 7683 13c4 660A0000 		.4byte	.LASF87
 7684 13c8 01       		.byte	0x1
 7685 13c9 C211     		.2byte	0x11c2
 7686 13cb 2E010000 		.4byte	0x12e
 7687 13cf 02       		.uleb128 0x2
 7688 13d0 91       		.byte	0x91
 7689 13d1 74       		.sleb128 -12
 7690 13d2 00       		.byte	0
 7691 13d3 1E       		.uleb128 0x1e
 7692 13d4 820C0000 		.4byte	.LASF190
 7693 13d8 01       		.byte	0x1
 7694 13d9 DD11     		.2byte	0x11dd
 7695 13db 00000000 		.4byte	.LFB117
 7696 13df C8000000 		.4byte	.LFE117-.LFB117
 7697 13e3 01       		.uleb128 0x1
 7698 13e4 9C       		.byte	0x9c
 7699 13e5 26140000 		.4byte	0x1426
 7700 13e9 1B       		.uleb128 0x1b
 7701 13ea 050C0000 		.4byte	.LASF142
 7702 13ee 01       		.byte	0x1
 7703 13ef DD11     		.2byte	0x11dd
 7704 13f1 44010000 		.4byte	0x144
 7705 13f5 02       		.uleb128 0x2
 7706 13f6 91       		.byte	0x91
 7707 13f7 6C       		.sleb128 -20
 7708 13f8 1B       		.uleb128 0x1b
 7709 13f9 F90A0000 		.4byte	.LASF191
 7710 13fd 01       		.byte	0x1
 7711 13fe DD11     		.2byte	0x11dd
 7712 1400 26140000 		.4byte	0x1426
 7713 1404 02       		.uleb128 0x2
 7714 1405 91       		.byte	0x91
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 224


 7715 1406 68       		.sleb128 -24
 7716 1407 1C       		.uleb128 0x1c
 7717 1408 F30C0000 		.4byte	.LASF97
 7718 140c 01       		.byte	0x1
 7719 140d DF11     		.2byte	0x11df
 7720 140f 44010000 		.4byte	0x144
 7721 1413 02       		.uleb128 0x2
 7722 1414 91       		.byte	0x91
 7723 1415 70       		.sleb128 -16
 7724 1416 1C       		.uleb128 0x1c
 7725 1417 2A040000 		.4byte	.LASF100
 7726 141b 01       		.byte	0x1
 7727 141c E011     		.2byte	0x11e0
 7728 141e 69060000 		.4byte	0x669
 7729 1422 02       		.uleb128 0x2
 7730 1423 91       		.byte	0x91
 7731 1424 74       		.sleb128 -12
 7732 1425 00       		.byte	0
 7733 1426 07       		.uleb128 0x7
 7734 1427 2E010000 		.4byte	0x12e
 7735 142b 11       		.uleb128 0x11
 7736 142c 22020000 		.4byte	0x222
 7737 1430 3B140000 		.4byte	0x143b
 7738 1434 12       		.uleb128 0x12
 7739 1435 A2000000 		.4byte	0xa2
 7740 1439 04       		.byte	0x4
 7741 143a 00       		.byte	0
 7742 143b 1C       		.uleb128 0x1c
 7743 143c 51010000 		.4byte	.LASF192
 7744 1440 01       		.byte	0x1
 7745 1441 6101     		.2byte	0x161
 7746 1443 2B140000 		.4byte	0x142b
 7747 1447 05       		.uleb128 0x5
 7748 1448 03       		.byte	0x3
 7749 1449 04000000 		.4byte	pxReadyTasksLists
 7750 144d 1C       		.uleb128 0x1c
 7751 144e C4010000 		.4byte	.LASF193
 7752 1452 01       		.byte	0x1
 7753 1453 6201     		.2byte	0x162
 7754 1455 22020000 		.4byte	0x222
 7755 1459 05       		.uleb128 0x5
 7756 145a 03       		.byte	0x3
 7757 145b 68000000 		.4byte	xDelayedTaskList1
 7758 145f 1C       		.uleb128 0x1c
 7759 1460 D6010000 		.4byte	.LASF194
 7760 1464 01       		.byte	0x1
 7761 1465 6301     		.2byte	0x163
 7762 1467 22020000 		.4byte	0x222
 7763 146b 05       		.uleb128 0x5
 7764 146c 03       		.byte	0x3
 7765 146d 7C000000 		.4byte	xDelayedTaskList2
 7766 1471 1C       		.uleb128 0x1c
 7767 1472 95090000 		.4byte	.LASF195
 7768 1476 01       		.byte	0x1
 7769 1477 6401     		.2byte	0x164
 7770 1479 83140000 		.4byte	0x1483
 7771 147d 05       		.uleb128 0x5
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 225


 7772 147e 03       		.byte	0x3
 7773 147f 90000000 		.4byte	pxDelayedTaskList
 7774 1483 08       		.uleb128 0x8
 7775 1484 FA060000 		.4byte	0x6fa
 7776 1488 1C       		.uleb128 0x1c
 7777 1489 71040000 		.4byte	.LASF196
 7778 148d 01       		.byte	0x1
 7779 148e 6501     		.2byte	0x165
 7780 1490 83140000 		.4byte	0x1483
 7781 1494 05       		.uleb128 0x5
 7782 1495 03       		.byte	0x3
 7783 1496 94000000 		.4byte	pxOverflowDelayedTaskList
 7784 149a 1C       		.uleb128 0x1c
 7785 149b 43030000 		.4byte	.LASF197
 7786 149f 01       		.byte	0x1
 7787 14a0 6601     		.2byte	0x166
 7788 14a2 22020000 		.4byte	0x222
 7789 14a6 05       		.uleb128 0x5
 7790 14a7 03       		.byte	0x3
 7791 14a8 98000000 		.4byte	xPendingReadyList
 7792 14ac 1C       		.uleb128 0x1c
 7793 14ad 60030000 		.4byte	.LASF198
 7794 14b1 01       		.byte	0x1
 7795 14b2 6A01     		.2byte	0x16a
 7796 14b4 22020000 		.4byte	0x222
 7797 14b8 05       		.uleb128 0x5
 7798 14b9 03       		.byte	0x3
 7799 14ba AC000000 		.4byte	xTasksWaitingTermination
 7800 14be 1C       		.uleb128 0x1c
 7801 14bf 1F010000 		.4byte	.LASF199
 7802 14c3 01       		.byte	0x1
 7803 14c4 6B01     		.2byte	0x16b
 7804 14c6 D0140000 		.4byte	0x14d0
 7805 14ca 05       		.uleb128 0x5
 7806 14cb 03       		.byte	0x3
 7807 14cc C0000000 		.4byte	uxDeletedTasksWaitingCleanUp
 7808 14d0 08       		.uleb128 0x8
 7809 14d1 39010000 		.4byte	0x139
 7810 14d5 1C       		.uleb128 0x1c
 7811 14d6 3A040000 		.4byte	.LASF200
 7812 14da 01       		.byte	0x1
 7813 14db 7101     		.2byte	0x171
 7814 14dd 22020000 		.4byte	0x222
 7815 14e1 05       		.uleb128 0x5
 7816 14e2 03       		.byte	0x3
 7817 14e3 C4000000 		.4byte	xSuspendedTaskList
 7818 14e7 1C       		.uleb128 0x1c
 7819 14e8 AE0C0000 		.4byte	.LASF201
 7820 14ec 01       		.byte	0x1
 7821 14ed 7601     		.2byte	0x176
 7822 14ef D0140000 		.4byte	0x14d0
 7823 14f3 05       		.uleb128 0x5
 7824 14f4 03       		.byte	0x3
 7825 14f5 D8000000 		.4byte	uxCurrentNumberOfTasks
 7826 14f9 1C       		.uleb128 0x1c
 7827 14fa CB060000 		.4byte	.LASF202
 7828 14fe 01       		.byte	0x1
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 226


 7829 14ff 7701     		.2byte	0x177
 7830 1501 0B150000 		.4byte	0x150b
 7831 1505 05       		.uleb128 0x5
 7832 1506 03       		.byte	0x3
 7833 1507 DC000000 		.4byte	xTickCount
 7834 150b 08       		.uleb128 0x8
 7835 150c 44010000 		.4byte	0x144
 7836 1510 1C       		.uleb128 0x1c
 7837 1511 AE000000 		.4byte	.LASF203
 7838 1515 01       		.byte	0x1
 7839 1516 7801     		.2byte	0x178
 7840 1518 D0140000 		.4byte	0x14d0
 7841 151c 05       		.uleb128 0x5
 7842 151d 03       		.byte	0x3
 7843 151e E0000000 		.4byte	uxTopReadyPriority
 7844 1522 1C       		.uleb128 0x1c
 7845 1523 DA000000 		.4byte	.LASF204
 7846 1527 01       		.byte	0x1
 7847 1528 7901     		.2byte	0x179
 7848 152a 34150000 		.4byte	0x1534
 7849 152e 05       		.uleb128 0x5
 7850 152f 03       		.byte	0x3
 7851 1530 E4000000 		.4byte	xSchedulerRunning
 7852 1534 08       		.uleb128 0x8
 7853 1535 2E010000 		.4byte	0x12e
 7854 1539 1C       		.uleb128 0x1c
 7855 153a 880A0000 		.4byte	.LASF205
 7856 153e 01       		.byte	0x1
 7857 153f 7A01     		.2byte	0x17a
 7858 1541 D0140000 		.4byte	0x14d0
 7859 1545 05       		.uleb128 0x5
 7860 1546 03       		.byte	0x3
 7861 1547 E8000000 		.4byte	uxPendedTicks
 7862 154b 1C       		.uleb128 0x1c
 7863 154c D50D0000 		.4byte	.LASF206
 7864 1550 01       		.byte	0x1
 7865 1551 7B01     		.2byte	0x17b
 7866 1553 34150000 		.4byte	0x1534
 7867 1557 05       		.uleb128 0x5
 7868 1558 03       		.byte	0x3
 7869 1559 EC000000 		.4byte	xYieldPending
 7870 155d 1C       		.uleb128 0x1c
 7871 155e 0B090000 		.4byte	.LASF207
 7872 1562 01       		.byte	0x1
 7873 1563 7C01     		.2byte	0x17c
 7874 1565 34150000 		.4byte	0x1534
 7875 1569 05       		.uleb128 0x5
 7876 156a 03       		.byte	0x3
 7877 156b F0000000 		.4byte	xNumOfOverflows
 7878 156f 1C       		.uleb128 0x1c
 7879 1570 40080000 		.4byte	.LASF208
 7880 1574 01       		.byte	0x1
 7881 1575 7D01     		.2byte	0x17d
 7882 1577 39010000 		.4byte	0x139
 7883 157b 05       		.uleb128 0x5
 7884 157c 03       		.byte	0x3
 7885 157d F4000000 		.4byte	uxTaskNumber
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 227


 7886 1581 1C       		.uleb128 0x1c
 7887 1582 A3060000 		.4byte	.LASF209
 7888 1586 01       		.byte	0x1
 7889 1587 7E01     		.2byte	0x17e
 7890 1589 0B150000 		.4byte	0x150b
 7891 158d 05       		.uleb128 0x5
 7892 158e 03       		.byte	0x3
 7893 158f F8000000 		.4byte	xNextTaskUnblockTime
 7894 1593 1C       		.uleb128 0x1c
 7895 1594 27090000 		.4byte	.LASF210
 7896 1598 01       		.byte	0x1
 7897 1599 7F01     		.2byte	0x17f
 7898 159b 2D020000 		.4byte	0x22d
 7899 159f 05       		.uleb128 0x5
 7900 15a0 03       		.byte	0x3
 7901 15a1 FC000000 		.4byte	xIdleTaskHandle
 7902 15a5 1C       		.uleb128 0x1c
 7903 15a6 330D0000 		.4byte	.LASF211
 7904 15aa 01       		.byte	0x1
 7905 15ab 8901     		.2byte	0x189
 7906 15ad D0140000 		.4byte	0x14d0
 7907 15b1 05       		.uleb128 0x5
 7908 15b2 03       		.byte	0x3
 7909 15b3 00010000 		.4byte	uxSchedulerSuspended
 7910 15b7 2C       		.uleb128 0x2c
 7911 15b8 62090000 		.4byte	.LASF212
 7912 15bc 09       		.byte	0x9
 7913 15bd 9606     		.2byte	0x696
 7914 15bf C3150000 		.4byte	0x15c3
 7915 15c3 08       		.uleb128 0x8
 7916 15c4 D9000000 		.4byte	0xd9
 7917 15c8 2D       		.uleb128 0x2d
 7918 15c9 A10C0000 		.4byte	.LASF213
 7919 15cd 01       		.byte	0x1
 7920 15ce 5E01     		.2byte	0x15e
 7921 15d0 DA150000 		.4byte	0x15da
 7922 15d4 05       		.uleb128 0x5
 7923 15d5 03       		.byte	0x3
 7924 15d6 00000000 		.4byte	pxCurrentTCB
 7925 15da 08       		.uleb128 0x8
 7926 15db E1040000 		.4byte	0x4e1
 7927 15df 00       		.byte	0
 7928              		.section	.debug_abbrev,"",%progbits
 7929              	.Ldebug_abbrev0:
 7930 0000 01       		.uleb128 0x1
 7931 0001 11       		.uleb128 0x11
 7932 0002 01       		.byte	0x1
 7933 0003 25       		.uleb128 0x25
 7934 0004 0E       		.uleb128 0xe
 7935 0005 13       		.uleb128 0x13
 7936 0006 0B       		.uleb128 0xb
 7937 0007 03       		.uleb128 0x3
 7938 0008 0E       		.uleb128 0xe
 7939 0009 1B       		.uleb128 0x1b
 7940 000a 0E       		.uleb128 0xe
 7941 000b 55       		.uleb128 0x55
 7942 000c 17       		.uleb128 0x17
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 228


 7943 000d 11       		.uleb128 0x11
 7944 000e 01       		.uleb128 0x1
 7945 000f 10       		.uleb128 0x10
 7946 0010 17       		.uleb128 0x17
 7947 0011 00       		.byte	0
 7948 0012 00       		.byte	0
 7949 0013 02       		.uleb128 0x2
 7950 0014 16       		.uleb128 0x16
 7951 0015 00       		.byte	0
 7952 0016 03       		.uleb128 0x3
 7953 0017 0E       		.uleb128 0xe
 7954 0018 3A       		.uleb128 0x3a
 7955 0019 0B       		.uleb128 0xb
 7956 001a 3B       		.uleb128 0x3b
 7957 001b 0B       		.uleb128 0xb
 7958 001c 49       		.uleb128 0x49
 7959 001d 13       		.uleb128 0x13
 7960 001e 00       		.byte	0
 7961 001f 00       		.byte	0
 7962 0020 03       		.uleb128 0x3
 7963 0021 24       		.uleb128 0x24
 7964 0022 00       		.byte	0
 7965 0023 0B       		.uleb128 0xb
 7966 0024 0B       		.uleb128 0xb
 7967 0025 3E       		.uleb128 0x3e
 7968 0026 0B       		.uleb128 0xb
 7969 0027 03       		.uleb128 0x3
 7970 0028 0E       		.uleb128 0xe
 7971 0029 00       		.byte	0
 7972 002a 00       		.byte	0
 7973 002b 04       		.uleb128 0x4
 7974 002c 24       		.uleb128 0x24
 7975 002d 00       		.byte	0
 7976 002e 0B       		.uleb128 0xb
 7977 002f 0B       		.uleb128 0xb
 7978 0030 3E       		.uleb128 0x3e
 7979 0031 0B       		.uleb128 0xb
 7980 0032 03       		.uleb128 0x3
 7981 0033 08       		.uleb128 0x8
 7982 0034 00       		.byte	0
 7983 0035 00       		.byte	0
 7984 0036 05       		.uleb128 0x5
 7985 0037 0F       		.uleb128 0xf
 7986 0038 00       		.byte	0
 7987 0039 0B       		.uleb128 0xb
 7988 003a 0B       		.uleb128 0xb
 7989 003b 00       		.byte	0
 7990 003c 00       		.byte	0
 7991 003d 06       		.uleb128 0x6
 7992 003e 0F       		.uleb128 0xf
 7993 003f 00       		.byte	0
 7994 0040 0B       		.uleb128 0xb
 7995 0041 0B       		.uleb128 0xb
 7996 0042 49       		.uleb128 0x49
 7997 0043 13       		.uleb128 0x13
 7998 0044 00       		.byte	0
 7999 0045 00       		.byte	0
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 229


 8000 0046 07       		.uleb128 0x7
 8001 0047 26       		.uleb128 0x26
 8002 0048 00       		.byte	0
 8003 0049 49       		.uleb128 0x49
 8004 004a 13       		.uleb128 0x13
 8005 004b 00       		.byte	0
 8006 004c 00       		.byte	0
 8007 004d 08       		.uleb128 0x8
 8008 004e 35       		.uleb128 0x35
 8009 004f 00       		.byte	0
 8010 0050 49       		.uleb128 0x49
 8011 0051 13       		.uleb128 0x13
 8012 0052 00       		.byte	0
 8013 0053 00       		.byte	0
 8014 0054 09       		.uleb128 0x9
 8015 0055 15       		.uleb128 0x15
 8016 0056 01       		.byte	0x1
 8017 0057 27       		.uleb128 0x27
 8018 0058 19       		.uleb128 0x19
 8019 0059 01       		.uleb128 0x1
 8020 005a 13       		.uleb128 0x13
 8021 005b 00       		.byte	0
 8022 005c 00       		.byte	0
 8023 005d 0A       		.uleb128 0xa
 8024 005e 05       		.uleb128 0x5
 8025 005f 00       		.byte	0
 8026 0060 49       		.uleb128 0x49
 8027 0061 13       		.uleb128 0x13
 8028 0062 00       		.byte	0
 8029 0063 00       		.byte	0
 8030 0064 0B       		.uleb128 0xb
 8031 0065 13       		.uleb128 0x13
 8032 0066 01       		.byte	0x1
 8033 0067 03       		.uleb128 0x3
 8034 0068 0E       		.uleb128 0xe
 8035 0069 0B       		.uleb128 0xb
 8036 006a 0B       		.uleb128 0xb
 8037 006b 3A       		.uleb128 0x3a
 8038 006c 0B       		.uleb128 0xb
 8039 006d 3B       		.uleb128 0x3b
 8040 006e 0B       		.uleb128 0xb
 8041 006f 01       		.uleb128 0x1
 8042 0070 13       		.uleb128 0x13
 8043 0071 00       		.byte	0
 8044 0072 00       		.byte	0
 8045 0073 0C       		.uleb128 0xc
 8046 0074 0D       		.uleb128 0xd
 8047 0075 00       		.byte	0
 8048 0076 03       		.uleb128 0x3
 8049 0077 0E       		.uleb128 0xe
 8050 0078 3A       		.uleb128 0x3a
 8051 0079 0B       		.uleb128 0xb
 8052 007a 3B       		.uleb128 0x3b
 8053 007b 0B       		.uleb128 0xb
 8054 007c 49       		.uleb128 0x49
 8055 007d 13       		.uleb128 0x13
 8056 007e 38       		.uleb128 0x38
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 230


 8057 007f 0B       		.uleb128 0xb
 8058 0080 00       		.byte	0
 8059 0081 00       		.byte	0
 8060 0082 0D       		.uleb128 0xd
 8061 0083 04       		.uleb128 0x4
 8062 0084 01       		.byte	0x1
 8063 0085 0B       		.uleb128 0xb
 8064 0086 0B       		.uleb128 0xb
 8065 0087 3A       		.uleb128 0x3a
 8066 0088 0B       		.uleb128 0xb
 8067 0089 3B       		.uleb128 0x3b
 8068 008a 0B       		.uleb128 0xb
 8069 008b 01       		.uleb128 0x1
 8070 008c 13       		.uleb128 0x13
 8071 008d 00       		.byte	0
 8072 008e 00       		.byte	0
 8073 008f 0E       		.uleb128 0xe
 8074 0090 28       		.uleb128 0x28
 8075 0091 00       		.byte	0
 8076 0092 03       		.uleb128 0x3
 8077 0093 0E       		.uleb128 0xe
 8078 0094 1C       		.uleb128 0x1c
 8079 0095 0D       		.uleb128 0xd
 8080 0096 00       		.byte	0
 8081 0097 00       		.byte	0
 8082 0098 0F       		.uleb128 0xf
 8083 0099 13       		.uleb128 0x13
 8084 009a 01       		.byte	0x1
 8085 009b 03       		.uleb128 0x3
 8086 009c 0E       		.uleb128 0xe
 8087 009d 0B       		.uleb128 0xb
 8088 009e 0B       		.uleb128 0xb
 8089 009f 3A       		.uleb128 0x3a
 8090 00a0 0B       		.uleb128 0xb
 8091 00a1 3B       		.uleb128 0x3b
 8092 00a2 05       		.uleb128 0x5
 8093 00a3 01       		.uleb128 0x1
 8094 00a4 13       		.uleb128 0x13
 8095 00a5 00       		.byte	0
 8096 00a6 00       		.byte	0
 8097 00a7 10       		.uleb128 0x10
 8098 00a8 0D       		.uleb128 0xd
 8099 00a9 00       		.byte	0
 8100 00aa 03       		.uleb128 0x3
 8101 00ab 0E       		.uleb128 0xe
 8102 00ac 3A       		.uleb128 0x3a
 8103 00ad 0B       		.uleb128 0xb
 8104 00ae 3B       		.uleb128 0x3b
 8105 00af 05       		.uleb128 0x5
 8106 00b0 49       		.uleb128 0x49
 8107 00b1 13       		.uleb128 0x13
 8108 00b2 38       		.uleb128 0x38
 8109 00b3 0B       		.uleb128 0xb
 8110 00b4 00       		.byte	0
 8111 00b5 00       		.byte	0
 8112 00b6 11       		.uleb128 0x11
 8113 00b7 01       		.uleb128 0x1
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 231


 8114 00b8 01       		.byte	0x1
 8115 00b9 49       		.uleb128 0x49
 8116 00ba 13       		.uleb128 0x13
 8117 00bb 01       		.uleb128 0x1
 8118 00bc 13       		.uleb128 0x13
 8119 00bd 00       		.byte	0
 8120 00be 00       		.byte	0
 8121 00bf 12       		.uleb128 0x12
 8122 00c0 21       		.uleb128 0x21
 8123 00c1 00       		.byte	0
 8124 00c2 49       		.uleb128 0x49
 8125 00c3 13       		.uleb128 0x13
 8126 00c4 2F       		.uleb128 0x2f
 8127 00c5 0B       		.uleb128 0xb
 8128 00c6 00       		.byte	0
 8129 00c7 00       		.byte	0
 8130 00c8 13       		.uleb128 0x13
 8131 00c9 16       		.uleb128 0x16
 8132 00ca 00       		.byte	0
 8133 00cb 03       		.uleb128 0x3
 8134 00cc 0E       		.uleb128 0xe
 8135 00cd 3A       		.uleb128 0x3a
 8136 00ce 0B       		.uleb128 0xb
 8137 00cf 3B       		.uleb128 0x3b
 8138 00d0 05       		.uleb128 0x5
 8139 00d1 49       		.uleb128 0x49
 8140 00d2 13       		.uleb128 0x13
 8141 00d3 00       		.byte	0
 8142 00d4 00       		.byte	0
 8143 00d5 14       		.uleb128 0x14
 8144 00d6 2E       		.uleb128 0x2e
 8145 00d7 01       		.byte	0x1
 8146 00d8 03       		.uleb128 0x3
 8147 00d9 0E       		.uleb128 0xe
 8148 00da 3A       		.uleb128 0x3a
 8149 00db 0B       		.uleb128 0xb
 8150 00dc 3B       		.uleb128 0x3b
 8151 00dd 0B       		.uleb128 0xb
 8152 00de 27       		.uleb128 0x27
 8153 00df 19       		.uleb128 0x19
 8154 00e0 49       		.uleb128 0x49
 8155 00e1 13       		.uleb128 0x13
 8156 00e2 20       		.uleb128 0x20
 8157 00e3 0B       		.uleb128 0xb
 8158 00e4 01       		.uleb128 0x1
 8159 00e5 13       		.uleb128 0x13
 8160 00e6 00       		.byte	0
 8161 00e7 00       		.byte	0
 8162 00e8 15       		.uleb128 0x15
 8163 00e9 34       		.uleb128 0x34
 8164 00ea 00       		.byte	0
 8165 00eb 03       		.uleb128 0x3
 8166 00ec 0E       		.uleb128 0xe
 8167 00ed 3A       		.uleb128 0x3a
 8168 00ee 0B       		.uleb128 0xb
 8169 00ef 3B       		.uleb128 0x3b
 8170 00f0 0B       		.uleb128 0xb
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 232


 8171 00f1 49       		.uleb128 0x49
 8172 00f2 13       		.uleb128 0x13
 8173 00f3 00       		.byte	0
 8174 00f4 00       		.byte	0
 8175 00f5 16       		.uleb128 0x16
 8176 00f6 2E       		.uleb128 0x2e
 8177 00f7 01       		.byte	0x1
 8178 00f8 03       		.uleb128 0x3
 8179 00f9 0E       		.uleb128 0xe
 8180 00fa 3A       		.uleb128 0x3a
 8181 00fb 0B       		.uleb128 0xb
 8182 00fc 3B       		.uleb128 0x3b
 8183 00fd 05       		.uleb128 0x5
 8184 00fe 27       		.uleb128 0x27
 8185 00ff 19       		.uleb128 0x19
 8186 0100 20       		.uleb128 0x20
 8187 0101 0B       		.uleb128 0xb
 8188 0102 01       		.uleb128 0x1
 8189 0103 13       		.uleb128 0x13
 8190 0104 00       		.byte	0
 8191 0105 00       		.byte	0
 8192 0106 17       		.uleb128 0x17
 8193 0107 05       		.uleb128 0x5
 8194 0108 00       		.byte	0
 8195 0109 03       		.uleb128 0x3
 8196 010a 0E       		.uleb128 0xe
 8197 010b 3A       		.uleb128 0x3a
 8198 010c 0B       		.uleb128 0xb
 8199 010d 3B       		.uleb128 0x3b
 8200 010e 05       		.uleb128 0x5
 8201 010f 49       		.uleb128 0x49
 8202 0110 13       		.uleb128 0x13
 8203 0111 00       		.byte	0
 8204 0112 00       		.byte	0
 8205 0113 18       		.uleb128 0x18
 8206 0114 2E       		.uleb128 0x2e
 8207 0115 01       		.byte	0x1
 8208 0116 03       		.uleb128 0x3
 8209 0117 0E       		.uleb128 0xe
 8210 0118 3A       		.uleb128 0x3a
 8211 0119 0B       		.uleb128 0xb
 8212 011a 3B       		.uleb128 0x3b
 8213 011b 0B       		.uleb128 0xb
 8214 011c 27       		.uleb128 0x27
 8215 011d 19       		.uleb128 0x19
 8216 011e 20       		.uleb128 0x20
 8217 011f 0B       		.uleb128 0xb
 8218 0120 01       		.uleb128 0x1
 8219 0121 13       		.uleb128 0x13
 8220 0122 00       		.byte	0
 8221 0123 00       		.byte	0
 8222 0124 19       		.uleb128 0x19
 8223 0125 05       		.uleb128 0x5
 8224 0126 00       		.byte	0
 8225 0127 03       		.uleb128 0x3
 8226 0128 0E       		.uleb128 0xe
 8227 0129 3A       		.uleb128 0x3a
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 233


 8228 012a 0B       		.uleb128 0xb
 8229 012b 3B       		.uleb128 0x3b
 8230 012c 0B       		.uleb128 0xb
 8231 012d 49       		.uleb128 0x49
 8232 012e 13       		.uleb128 0x13
 8233 012f 00       		.byte	0
 8234 0130 00       		.byte	0
 8235 0131 1A       		.uleb128 0x1a
 8236 0132 2E       		.uleb128 0x2e
 8237 0133 01       		.byte	0x1
 8238 0134 3F       		.uleb128 0x3f
 8239 0135 19       		.uleb128 0x19
 8240 0136 03       		.uleb128 0x3
 8241 0137 0E       		.uleb128 0xe
 8242 0138 3A       		.uleb128 0x3a
 8243 0139 0B       		.uleb128 0xb
 8244 013a 3B       		.uleb128 0x3b
 8245 013b 05       		.uleb128 0x5
 8246 013c 27       		.uleb128 0x27
 8247 013d 19       		.uleb128 0x19
 8248 013e 49       		.uleb128 0x49
 8249 013f 13       		.uleb128 0x13
 8250 0140 11       		.uleb128 0x11
 8251 0141 01       		.uleb128 0x1
 8252 0142 12       		.uleb128 0x12
 8253 0143 06       		.uleb128 0x6
 8254 0144 40       		.uleb128 0x40
 8255 0145 18       		.uleb128 0x18
 8256 0146 9642     		.uleb128 0x2116
 8257 0148 19       		.uleb128 0x19
 8258 0149 01       		.uleb128 0x1
 8259 014a 13       		.uleb128 0x13
 8260 014b 00       		.byte	0
 8261 014c 00       		.byte	0
 8262 014d 1B       		.uleb128 0x1b
 8263 014e 05       		.uleb128 0x5
 8264 014f 00       		.byte	0
 8265 0150 03       		.uleb128 0x3
 8266 0151 0E       		.uleb128 0xe
 8267 0152 3A       		.uleb128 0x3a
 8268 0153 0B       		.uleb128 0xb
 8269 0154 3B       		.uleb128 0x3b
 8270 0155 05       		.uleb128 0x5
 8271 0156 49       		.uleb128 0x49
 8272 0157 13       		.uleb128 0x13
 8273 0158 02       		.uleb128 0x2
 8274 0159 18       		.uleb128 0x18
 8275 015a 00       		.byte	0
 8276 015b 00       		.byte	0
 8277 015c 1C       		.uleb128 0x1c
 8278 015d 34       		.uleb128 0x34
 8279 015e 00       		.byte	0
 8280 015f 03       		.uleb128 0x3
 8281 0160 0E       		.uleb128 0xe
 8282 0161 3A       		.uleb128 0x3a
 8283 0162 0B       		.uleb128 0xb
 8284 0163 3B       		.uleb128 0x3b
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 234


 8285 0164 05       		.uleb128 0x5
 8286 0165 49       		.uleb128 0x49
 8287 0166 13       		.uleb128 0x13
 8288 0167 02       		.uleb128 0x2
 8289 0168 18       		.uleb128 0x18
 8290 0169 00       		.byte	0
 8291 016a 00       		.byte	0
 8292 016b 1D       		.uleb128 0x1d
 8293 016c 0B       		.uleb128 0xb
 8294 016d 01       		.byte	0x1
 8295 016e 11       		.uleb128 0x11
 8296 016f 01       		.uleb128 0x1
 8297 0170 12       		.uleb128 0x12
 8298 0171 06       		.uleb128 0x6
 8299 0172 00       		.byte	0
 8300 0173 00       		.byte	0
 8301 0174 1E       		.uleb128 0x1e
 8302 0175 2E       		.uleb128 0x2e
 8303 0176 01       		.byte	0x1
 8304 0177 03       		.uleb128 0x3
 8305 0178 0E       		.uleb128 0xe
 8306 0179 3A       		.uleb128 0x3a
 8307 017a 0B       		.uleb128 0xb
 8308 017b 3B       		.uleb128 0x3b
 8309 017c 05       		.uleb128 0x5
 8310 017d 27       		.uleb128 0x27
 8311 017e 19       		.uleb128 0x19
 8312 017f 11       		.uleb128 0x11
 8313 0180 01       		.uleb128 0x1
 8314 0181 12       		.uleb128 0x12
 8315 0182 06       		.uleb128 0x6
 8316 0183 40       		.uleb128 0x40
 8317 0184 18       		.uleb128 0x18
 8318 0185 9642     		.uleb128 0x2116
 8319 0187 19       		.uleb128 0x19
 8320 0188 01       		.uleb128 0x1
 8321 0189 13       		.uleb128 0x13
 8322 018a 00       		.byte	0
 8323 018b 00       		.byte	0
 8324 018c 1F       		.uleb128 0x1f
 8325 018d 34       		.uleb128 0x34
 8326 018e 00       		.byte	0
 8327 018f 03       		.uleb128 0x3
 8328 0190 08       		.uleb128 0x8
 8329 0191 3A       		.uleb128 0x3a
 8330 0192 0B       		.uleb128 0xb
 8331 0193 3B       		.uleb128 0x3b
 8332 0194 05       		.uleb128 0x5
 8333 0195 49       		.uleb128 0x49
 8334 0196 13       		.uleb128 0x13
 8335 0197 02       		.uleb128 0x2
 8336 0198 18       		.uleb128 0x18
 8337 0199 00       		.byte	0
 8338 019a 00       		.byte	0
 8339 019b 20       		.uleb128 0x20
 8340 019c 2E       		.uleb128 0x2e
 8341 019d 01       		.byte	0x1
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 235


 8342 019e 3F       		.uleb128 0x3f
 8343 019f 19       		.uleb128 0x19
 8344 01a0 03       		.uleb128 0x3
 8345 01a1 0E       		.uleb128 0xe
 8346 01a2 3A       		.uleb128 0x3a
 8347 01a3 0B       		.uleb128 0xb
 8348 01a4 3B       		.uleb128 0x3b
 8349 01a5 05       		.uleb128 0x5
 8350 01a6 27       		.uleb128 0x27
 8351 01a7 19       		.uleb128 0x19
 8352 01a8 11       		.uleb128 0x11
 8353 01a9 01       		.uleb128 0x1
 8354 01aa 12       		.uleb128 0x12
 8355 01ab 06       		.uleb128 0x6
 8356 01ac 40       		.uleb128 0x40
 8357 01ad 18       		.uleb128 0x18
 8358 01ae 9642     		.uleb128 0x2116
 8359 01b0 19       		.uleb128 0x19
 8360 01b1 01       		.uleb128 0x1
 8361 01b2 13       		.uleb128 0x13
 8362 01b3 00       		.byte	0
 8363 01b4 00       		.byte	0
 8364 01b5 21       		.uleb128 0x21
 8365 01b6 2E       		.uleb128 0x2e
 8366 01b7 01       		.byte	0x1
 8367 01b8 3F       		.uleb128 0x3f
 8368 01b9 19       		.uleb128 0x19
 8369 01ba 03       		.uleb128 0x3
 8370 01bb 0E       		.uleb128 0xe
 8371 01bc 3A       		.uleb128 0x3a
 8372 01bd 0B       		.uleb128 0xb
 8373 01be 3B       		.uleb128 0x3b
 8374 01bf 05       		.uleb128 0x5
 8375 01c0 27       		.uleb128 0x27
 8376 01c1 19       		.uleb128 0x19
 8377 01c2 49       		.uleb128 0x49
 8378 01c3 13       		.uleb128 0x13
 8379 01c4 11       		.uleb128 0x11
 8380 01c5 01       		.uleb128 0x1
 8381 01c6 12       		.uleb128 0x12
 8382 01c7 06       		.uleb128 0x6
 8383 01c8 40       		.uleb128 0x40
 8384 01c9 18       		.uleb128 0x18
 8385 01ca 9742     		.uleb128 0x2117
 8386 01cc 19       		.uleb128 0x19
 8387 01cd 01       		.uleb128 0x1
 8388 01ce 13       		.uleb128 0x13
 8389 01cf 00       		.byte	0
 8390 01d0 00       		.byte	0
 8391 01d1 22       		.uleb128 0x22
 8392 01d2 1D       		.uleb128 0x1d
 8393 01d3 01       		.byte	0x1
 8394 01d4 31       		.uleb128 0x31
 8395 01d5 13       		.uleb128 0x13
 8396 01d6 11       		.uleb128 0x11
 8397 01d7 01       		.uleb128 0x1
 8398 01d8 12       		.uleb128 0x12
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 236


 8399 01d9 06       		.uleb128 0x6
 8400 01da 58       		.uleb128 0x58
 8401 01db 0B       		.uleb128 0xb
 8402 01dc 59       		.uleb128 0x59
 8403 01dd 05       		.uleb128 0x5
 8404 01de 01       		.uleb128 0x1
 8405 01df 13       		.uleb128 0x13
 8406 01e0 00       		.byte	0
 8407 01e1 00       		.byte	0
 8408 01e2 23       		.uleb128 0x23
 8409 01e3 34       		.uleb128 0x34
 8410 01e4 00       		.byte	0
 8411 01e5 31       		.uleb128 0x31
 8412 01e6 13       		.uleb128 0x13
 8413 01e7 02       		.uleb128 0x2
 8414 01e8 18       		.uleb128 0x18
 8415 01e9 00       		.byte	0
 8416 01ea 00       		.byte	0
 8417 01eb 24       		.uleb128 0x24
 8418 01ec 1D       		.uleb128 0x1d
 8419 01ed 01       		.byte	0x1
 8420 01ee 31       		.uleb128 0x31
 8421 01ef 13       		.uleb128 0x13
 8422 01f0 11       		.uleb128 0x11
 8423 01f1 01       		.uleb128 0x1
 8424 01f2 12       		.uleb128 0x12
 8425 01f3 06       		.uleb128 0x6
 8426 01f4 58       		.uleb128 0x58
 8427 01f5 0B       		.uleb128 0xb
 8428 01f6 59       		.uleb128 0x59
 8429 01f7 05       		.uleb128 0x5
 8430 01f8 00       		.byte	0
 8431 01f9 00       		.byte	0
 8432 01fa 25       		.uleb128 0x25
 8433 01fb 05       		.uleb128 0x5
 8434 01fc 00       		.byte	0
 8435 01fd 31       		.uleb128 0x31
 8436 01fe 13       		.uleb128 0x13
 8437 01ff 02       		.uleb128 0x2
 8438 0200 18       		.uleb128 0x18
 8439 0201 00       		.byte	0
 8440 0202 00       		.byte	0
 8441 0203 26       		.uleb128 0x26
 8442 0204 2E       		.uleb128 0x2e
 8443 0205 01       		.byte	0x1
 8444 0206 03       		.uleb128 0x3
 8445 0207 0E       		.uleb128 0xe
 8446 0208 3A       		.uleb128 0x3a
 8447 0209 0B       		.uleb128 0xb
 8448 020a 3B       		.uleb128 0x3b
 8449 020b 05       		.uleb128 0x5
 8450 020c 27       		.uleb128 0x27
 8451 020d 19       		.uleb128 0x19
 8452 020e 49       		.uleb128 0x49
 8453 020f 13       		.uleb128 0x13
 8454 0210 11       		.uleb128 0x11
 8455 0211 01       		.uleb128 0x1
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 237


 8456 0212 12       		.uleb128 0x12
 8457 0213 06       		.uleb128 0x6
 8458 0214 40       		.uleb128 0x40
 8459 0215 18       		.uleb128 0x18
 8460 0216 9742     		.uleb128 0x2117
 8461 0218 19       		.uleb128 0x19
 8462 0219 01       		.uleb128 0x1
 8463 021a 13       		.uleb128 0x13
 8464 021b 00       		.byte	0
 8465 021c 00       		.byte	0
 8466 021d 27       		.uleb128 0x27
 8467 021e 2E       		.uleb128 0x2e
 8468 021f 00       		.byte	0
 8469 0220 3F       		.uleb128 0x3f
 8470 0221 19       		.uleb128 0x19
 8471 0222 03       		.uleb128 0x3
 8472 0223 0E       		.uleb128 0xe
 8473 0224 3A       		.uleb128 0x3a
 8474 0225 0B       		.uleb128 0xb
 8475 0226 3B       		.uleb128 0x3b
 8476 0227 05       		.uleb128 0x5
 8477 0228 27       		.uleb128 0x27
 8478 0229 19       		.uleb128 0x19
 8479 022a 11       		.uleb128 0x11
 8480 022b 01       		.uleb128 0x1
 8481 022c 12       		.uleb128 0x12
 8482 022d 06       		.uleb128 0x6
 8483 022e 40       		.uleb128 0x40
 8484 022f 18       		.uleb128 0x18
 8485 0230 9742     		.uleb128 0x2117
 8486 0232 19       		.uleb128 0x19
 8487 0233 00       		.byte	0
 8488 0234 00       		.byte	0
 8489 0235 28       		.uleb128 0x28
 8490 0236 2E       		.uleb128 0x2e
 8491 0237 00       		.byte	0
 8492 0238 3F       		.uleb128 0x3f
 8493 0239 19       		.uleb128 0x19
 8494 023a 03       		.uleb128 0x3
 8495 023b 0E       		.uleb128 0xe
 8496 023c 3A       		.uleb128 0x3a
 8497 023d 0B       		.uleb128 0xb
 8498 023e 3B       		.uleb128 0x3b
 8499 023f 05       		.uleb128 0x5
 8500 0240 27       		.uleb128 0x27
 8501 0241 19       		.uleb128 0x19
 8502 0242 49       		.uleb128 0x49
 8503 0243 13       		.uleb128 0x13
 8504 0244 11       		.uleb128 0x11
 8505 0245 01       		.uleb128 0x1
 8506 0246 12       		.uleb128 0x12
 8507 0247 06       		.uleb128 0x6
 8508 0248 40       		.uleb128 0x40
 8509 0249 18       		.uleb128 0x18
 8510 024a 9742     		.uleb128 0x2117
 8511 024c 19       		.uleb128 0x19
 8512 024d 00       		.byte	0
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 238


 8513 024e 00       		.byte	0
 8514 024f 29       		.uleb128 0x29
 8515 0250 0B       		.uleb128 0xb
 8516 0251 01       		.byte	0x1
 8517 0252 11       		.uleb128 0x11
 8518 0253 01       		.uleb128 0x1
 8519 0254 12       		.uleb128 0x12
 8520 0255 06       		.uleb128 0x6
 8521 0256 01       		.uleb128 0x1
 8522 0257 13       		.uleb128 0x13
 8523 0258 00       		.byte	0
 8524 0259 00       		.byte	0
 8525 025a 2A       		.uleb128 0x2a
 8526 025b 2E       		.uleb128 0x2e
 8527 025c 01       		.byte	0x1
 8528 025d 3F       		.uleb128 0x3f
 8529 025e 19       		.uleb128 0x19
 8530 025f 03       		.uleb128 0x3
 8531 0260 0E       		.uleb128 0xe
 8532 0261 3A       		.uleb128 0x3a
 8533 0262 0B       		.uleb128 0xb
 8534 0263 3B       		.uleb128 0x3b
 8535 0264 05       		.uleb128 0x5
 8536 0265 27       		.uleb128 0x27
 8537 0266 19       		.uleb128 0x19
 8538 0267 11       		.uleb128 0x11
 8539 0268 01       		.uleb128 0x1
 8540 0269 12       		.uleb128 0x12
 8541 026a 06       		.uleb128 0x6
 8542 026b 40       		.uleb128 0x40
 8543 026c 18       		.uleb128 0x18
 8544 026d 9742     		.uleb128 0x2117
 8545 026f 19       		.uleb128 0x19
 8546 0270 01       		.uleb128 0x1
 8547 0271 13       		.uleb128 0x13
 8548 0272 00       		.byte	0
 8549 0273 00       		.byte	0
 8550 0274 2B       		.uleb128 0x2b
 8551 0275 2E       		.uleb128 0x2e
 8552 0276 01       		.byte	0x1
 8553 0277 03       		.uleb128 0x3
 8554 0278 0E       		.uleb128 0xe
 8555 0279 3A       		.uleb128 0x3a
 8556 027a 0B       		.uleb128 0xb
 8557 027b 3B       		.uleb128 0x3b
 8558 027c 05       		.uleb128 0x5
 8559 027d 27       		.uleb128 0x27
 8560 027e 19       		.uleb128 0x19
 8561 027f 11       		.uleb128 0x11
 8562 0280 01       		.uleb128 0x1
 8563 0281 12       		.uleb128 0x12
 8564 0282 06       		.uleb128 0x6
 8565 0283 40       		.uleb128 0x40
 8566 0284 18       		.uleb128 0x18
 8567 0285 9742     		.uleb128 0x2117
 8568 0287 19       		.uleb128 0x19
 8569 0288 01       		.uleb128 0x1
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 239


 8570 0289 13       		.uleb128 0x13
 8571 028a 00       		.byte	0
 8572 028b 00       		.byte	0
 8573 028c 2C       		.uleb128 0x2c
 8574 028d 34       		.uleb128 0x34
 8575 028e 00       		.byte	0
 8576 028f 03       		.uleb128 0x3
 8577 0290 0E       		.uleb128 0xe
 8578 0291 3A       		.uleb128 0x3a
 8579 0292 0B       		.uleb128 0xb
 8580 0293 3B       		.uleb128 0x3b
 8581 0294 05       		.uleb128 0x5
 8582 0295 49       		.uleb128 0x49
 8583 0296 13       		.uleb128 0x13
 8584 0297 3F       		.uleb128 0x3f
 8585 0298 19       		.uleb128 0x19
 8586 0299 3C       		.uleb128 0x3c
 8587 029a 19       		.uleb128 0x19
 8588 029b 00       		.byte	0
 8589 029c 00       		.byte	0
 8590 029d 2D       		.uleb128 0x2d
 8591 029e 34       		.uleb128 0x34
 8592 029f 00       		.byte	0
 8593 02a0 03       		.uleb128 0x3
 8594 02a1 0E       		.uleb128 0xe
 8595 02a2 3A       		.uleb128 0x3a
 8596 02a3 0B       		.uleb128 0xb
 8597 02a4 3B       		.uleb128 0x3b
 8598 02a5 05       		.uleb128 0x5
 8599 02a6 49       		.uleb128 0x49
 8600 02a7 13       		.uleb128 0x13
 8601 02a8 3F       		.uleb128 0x3f
 8602 02a9 19       		.uleb128 0x19
 8603 02aa 02       		.uleb128 0x2
 8604 02ab 18       		.uleb128 0x18
 8605 02ac 00       		.byte	0
 8606 02ad 00       		.byte	0
 8607 02ae 00       		.byte	0
 8608              		.section	.debug_aranges,"",%progbits
 8609 0000 A4010000 		.4byte	0x1a4
 8610 0004 0200     		.2byte	0x2
 8611 0006 00000000 		.4byte	.Ldebug_info0
 8612 000a 04       		.byte	0x4
 8613 000b 00       		.byte	0
 8614 000c 0000     		.2byte	0
 8615 000e 0000     		.2byte	0
 8616 0010 00000000 		.4byte	.LFB68
 8617 0014 7E000000 		.4byte	.LFE68-.LFB68
 8618 0018 00000000 		.4byte	.LFB69
 8619 001c EC000000 		.4byte	.LFE69-.LFB69
 8620 0020 00000000 		.4byte	.LFB70
 8621 0024 D8000000 		.4byte	.LFE70-.LFB70
 8622 0028 00000000 		.4byte	.LFB71
 8623 002c FC000000 		.4byte	.LFE71-.LFB71
 8624 0030 00000000 		.4byte	.LFB72
 8625 0034 A0000000 		.4byte	.LFE72-.LFB72
 8626 0038 00000000 		.4byte	.LFB73
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 240


 8627 003c 44000000 		.4byte	.LFE73-.LFB73
 8628 0040 00000000 		.4byte	.LFB74
 8629 0044 98000000 		.4byte	.LFE74-.LFB74
 8630 0048 00000000 		.4byte	.LFB75
 8631 004c 34000000 		.4byte	.LFE75-.LFB75
 8632 0050 00000000 		.4byte	.LFB76
 8633 0054 58000000 		.4byte	.LFE76-.LFB76
 8634 0058 00000000 		.4byte	.LFB77
 8635 005c 44010000 		.4byte	.LFE77-.LFB77
 8636 0060 00000000 		.4byte	.LFB78
 8637 0064 EC000000 		.4byte	.LFE78-.LFB78
 8638 0068 00000000 		.4byte	.LFB79
 8639 006c 5C000000 		.4byte	.LFE79-.LFB79
 8640 0070 00000000 		.4byte	.LFB80
 8641 0074 A0000000 		.4byte	.LFE80-.LFB80
 8642 0078 00000000 		.4byte	.LFB81
 8643 007c C4000000 		.4byte	.LFE81-.LFB81
 8644 0080 00000000 		.4byte	.LFB82
 8645 0084 6C000000 		.4byte	.LFE82-.LFB82
 8646 0088 00000000 		.4byte	.LFB83
 8647 008c 2C000000 		.4byte	.LFE83-.LFB83
 8648 0090 00000000 		.4byte	.LFB84
 8649 0094 1C000000 		.4byte	.LFE84-.LFB84
 8650 0098 00000000 		.4byte	.LFB85
 8651 009c 20010000 		.4byte	.LFE85-.LFB85
 8652 00a0 00000000 		.4byte	.LFB86
 8653 00a4 20000000 		.4byte	.LFE86-.LFB86
 8654 00a8 00000000 		.4byte	.LFB87
 8655 00ac 24000000 		.4byte	.LFE87-.LFB87
 8656 00b0 00000000 		.4byte	.LFB88
 8657 00b4 18000000 		.4byte	.LFE88-.LFB88
 8658 00b8 00000000 		.4byte	.LFB89
 8659 00bc 2C000000 		.4byte	.LFE89-.LFB89
 8660 00c0 00000000 		.4byte	.LFB90
 8661 00c4 5C010000 		.4byte	.LFE90-.LFB90
 8662 00c8 00000000 		.4byte	.LFB91
 8663 00cc D4000000 		.4byte	.LFE91-.LFB91
 8664 00d0 00000000 		.4byte	.LFB92
 8665 00d4 2C000000 		.4byte	.LFE92-.LFB92
 8666 00d8 00000000 		.4byte	.LFB93
 8667 00dc 38000000 		.4byte	.LFE93-.LFB93
 8668 00e0 00000000 		.4byte	.LFB94
 8669 00e4 AC000000 		.4byte	.LFE94-.LFB94
 8670 00e8 00000000 		.4byte	.LFB95
 8671 00ec 94000000 		.4byte	.LFE95-.LFB95
 8672 00f0 00000000 		.4byte	.LFB96
 8673 00f4 2C000000 		.4byte	.LFE96-.LFB96
 8674 00f8 00000000 		.4byte	.LFB97
 8675 00fc 88000000 		.4byte	.LFE97-.LFB97
 8676 0100 00000000 		.4byte	.LFB98
 8677 0104 18000000 		.4byte	.LFE98-.LFB98
 8678 0108 00000000 		.4byte	.LFB99
 8679 010c 0E000000 		.4byte	.LFE99-.LFB99
 8680 0110 00000000 		.4byte	.LFB100
 8681 0114 7C000000 		.4byte	.LFE100-.LFB100
 8682 0118 00000000 		.4byte	.LFB101
 8683 011c 74000000 		.4byte	.LFE101-.LFB101
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 241


 8684 0120 00000000 		.4byte	.LFB102
 8685 0124 38000000 		.4byte	.LFE102-.LFB102
 8686 0128 00000000 		.4byte	.LFB103
 8687 012c 38000000 		.4byte	.LFE103-.LFB103
 8688 0130 00000000 		.4byte	.LFB104
 8689 0134 1E000000 		.4byte	.LFE104-.LFB104
 8690 0138 00000000 		.4byte	.LFB105
 8691 013c 48000000 		.4byte	.LFE105-.LFB105
 8692 0140 00000000 		.4byte	.LFB106
 8693 0144 20000000 		.4byte	.LFE106-.LFB106
 8694 0148 00000000 		.4byte	.LFB107
 8695 014c F0000000 		.4byte	.LFE107-.LFB107
 8696 0150 00000000 		.4byte	.LFB108
 8697 0154 CC000000 		.4byte	.LFE108-.LFB108
 8698 0158 00000000 		.4byte	.LFB109
 8699 015c 30000000 		.4byte	.LFE109-.LFB109
 8700 0160 00000000 		.4byte	.LFB110
 8701 0164 28000000 		.4byte	.LFE110-.LFB110
 8702 0168 00000000 		.4byte	.LFB111
 8703 016c 90000000 		.4byte	.LFE111-.LFB111
 8704 0170 00000000 		.4byte	.LFB112
 8705 0174 B4000000 		.4byte	.LFE112-.LFB112
 8706 0178 00000000 		.4byte	.LFB113
 8707 017c 10010000 		.4byte	.LFE113-.LFB113
 8708 0180 00000000 		.4byte	.LFB114
 8709 0184 54010000 		.4byte	.LFE114-.LFB114
 8710 0188 00000000 		.4byte	.LFB115
 8711 018c E8000000 		.4byte	.LFE115-.LFB115
 8712 0190 00000000 		.4byte	.LFB116
 8713 0194 4C000000 		.4byte	.LFE116-.LFB116
 8714 0198 00000000 		.4byte	.LFB117
 8715 019c C8000000 		.4byte	.LFE117-.LFB117
 8716 01a0 00000000 		.4byte	0
 8717 01a4 00000000 		.4byte	0
 8718              		.section	.debug_ranges,"",%progbits
 8719              	.Ldebug_ranges0:
 8720 0000 00000000 		.4byte	.LFB68
 8721 0004 7E000000 		.4byte	.LFE68
 8722 0008 00000000 		.4byte	.LFB69
 8723 000c EC000000 		.4byte	.LFE69
 8724 0010 00000000 		.4byte	.LFB70
 8725 0014 D8000000 		.4byte	.LFE70
 8726 0018 00000000 		.4byte	.LFB71
 8727 001c FC000000 		.4byte	.LFE71
 8728 0020 00000000 		.4byte	.LFB72
 8729 0024 A0000000 		.4byte	.LFE72
 8730 0028 00000000 		.4byte	.LFB73
 8731 002c 44000000 		.4byte	.LFE73
 8732 0030 00000000 		.4byte	.LFB74
 8733 0034 98000000 		.4byte	.LFE74
 8734 0038 00000000 		.4byte	.LFB75
 8735 003c 34000000 		.4byte	.LFE75
 8736 0040 00000000 		.4byte	.LFB76
 8737 0044 58000000 		.4byte	.LFE76
 8738 0048 00000000 		.4byte	.LFB77
 8739 004c 44010000 		.4byte	.LFE77
 8740 0050 00000000 		.4byte	.LFB78
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 242


 8741 0054 EC000000 		.4byte	.LFE78
 8742 0058 00000000 		.4byte	.LFB79
 8743 005c 5C000000 		.4byte	.LFE79
 8744 0060 00000000 		.4byte	.LFB80
 8745 0064 A0000000 		.4byte	.LFE80
 8746 0068 00000000 		.4byte	.LFB81
 8747 006c C4000000 		.4byte	.LFE81
 8748 0070 00000000 		.4byte	.LFB82
 8749 0074 6C000000 		.4byte	.LFE82
 8750 0078 00000000 		.4byte	.LFB83
 8751 007c 2C000000 		.4byte	.LFE83
 8752 0080 00000000 		.4byte	.LFB84
 8753 0084 1C000000 		.4byte	.LFE84
 8754 0088 00000000 		.4byte	.LFB85
 8755 008c 20010000 		.4byte	.LFE85
 8756 0090 00000000 		.4byte	.LFB86
 8757 0094 20000000 		.4byte	.LFE86
 8758 0098 00000000 		.4byte	.LFB87
 8759 009c 24000000 		.4byte	.LFE87
 8760 00a0 00000000 		.4byte	.LFB88
 8761 00a4 18000000 		.4byte	.LFE88
 8762 00a8 00000000 		.4byte	.LFB89
 8763 00ac 2C000000 		.4byte	.LFE89
 8764 00b0 00000000 		.4byte	.LFB90
 8765 00b4 5C010000 		.4byte	.LFE90
 8766 00b8 00000000 		.4byte	.LFB91
 8767 00bc D4000000 		.4byte	.LFE91
 8768 00c0 00000000 		.4byte	.LFB92
 8769 00c4 2C000000 		.4byte	.LFE92
 8770 00c8 00000000 		.4byte	.LFB93
 8771 00cc 38000000 		.4byte	.LFE93
 8772 00d0 00000000 		.4byte	.LFB94
 8773 00d4 AC000000 		.4byte	.LFE94
 8774 00d8 00000000 		.4byte	.LFB95
 8775 00dc 94000000 		.4byte	.LFE95
 8776 00e0 00000000 		.4byte	.LFB96
 8777 00e4 2C000000 		.4byte	.LFE96
 8778 00e8 00000000 		.4byte	.LFB97
 8779 00ec 88000000 		.4byte	.LFE97
 8780 00f0 00000000 		.4byte	.LFB98
 8781 00f4 18000000 		.4byte	.LFE98
 8782 00f8 00000000 		.4byte	.LFB99
 8783 00fc 0E000000 		.4byte	.LFE99
 8784 0100 00000000 		.4byte	.LFB100
 8785 0104 7C000000 		.4byte	.LFE100
 8786 0108 00000000 		.4byte	.LFB101
 8787 010c 74000000 		.4byte	.LFE101
 8788 0110 00000000 		.4byte	.LFB102
 8789 0114 38000000 		.4byte	.LFE102
 8790 0118 00000000 		.4byte	.LFB103
 8791 011c 38000000 		.4byte	.LFE103
 8792 0120 00000000 		.4byte	.LFB104
 8793 0124 1E000000 		.4byte	.LFE104
 8794 0128 00000000 		.4byte	.LFB105
 8795 012c 48000000 		.4byte	.LFE105
 8796 0130 00000000 		.4byte	.LFB106
 8797 0134 20000000 		.4byte	.LFE106
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 243


 8798 0138 00000000 		.4byte	.LFB107
 8799 013c F0000000 		.4byte	.LFE107
 8800 0140 00000000 		.4byte	.LFB108
 8801 0144 CC000000 		.4byte	.LFE108
 8802 0148 00000000 		.4byte	.LFB109
 8803 014c 30000000 		.4byte	.LFE109
 8804 0150 00000000 		.4byte	.LFB110
 8805 0154 28000000 		.4byte	.LFE110
 8806 0158 00000000 		.4byte	.LFB111
 8807 015c 90000000 		.4byte	.LFE111
 8808 0160 00000000 		.4byte	.LFB112
 8809 0164 B4000000 		.4byte	.LFE112
 8810 0168 00000000 		.4byte	.LFB113
 8811 016c 10010000 		.4byte	.LFE113
 8812 0170 00000000 		.4byte	.LFB114
 8813 0174 54010000 		.4byte	.LFE114
 8814 0178 00000000 		.4byte	.LFB115
 8815 017c E8000000 		.4byte	.LFE115
 8816 0180 00000000 		.4byte	.LFB116
 8817 0184 4C000000 		.4byte	.LFE116
 8818 0188 00000000 		.4byte	.LFB117
 8819 018c C8000000 		.4byte	.LFE117
 8820 0190 00000000 		.4byte	0
 8821 0194 00000000 		.4byte	0
 8822              		.section	.debug_line,"",%progbits
 8823              	.Ldebug_line0:
 8824 0000 850A0000 		.section	.debug_str,"MS",%progbits,1
 8824      02003B02 
 8824      00000201 
 8824      FB0E0D00 
 8824      01010101 
 8825              	.LASF65:
 8826 0000 70635461 		.ascii	"pcTaskName\000"
 8826      736B4E61 
 8826      6D6500
 8827              	.LASF37:
 8828 000b 75784E75 		.ascii	"uxNumberOfItems\000"
 8828      6D626572 
 8828      4F664974 
 8828      656D7300 
 8829              	.LASF63:
 8830 001b 75785072 		.ascii	"uxPriority\000"
 8830      696F7269 
 8830      747900
 8831              	.LASF139:
 8832 0026 7078436F 		.ascii	"pxConstList\000"
 8832      6E73744C 
 8832      69737400 
 8833              	.LASF107:
 8834 0032 70785374 		.ascii	"pxStateList\000"
 8834      6174654C 
 8834      69737400 
 8835              	.LASF45:
 8836 003e 65537573 		.ascii	"eSuspended\000"
 8836      70656E64 
 8836      656400
 8837              	.LASF47:
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 244


 8838 0049 65496E76 		.ascii	"eInvalid\000"
 8838      616C6964 
 8838      00
 8839              	.LASF126:
 8840 0052 75785065 		.ascii	"uxPendedCounts\000"
 8840      6E646564 
 8840      436F756E 
 8840      747300
 8841              	.LASF178:
 8842 0061 756C4269 		.ascii	"ulBitsToClearOnExit\000"
 8842      7473546F 
 8842      436C6561 
 8842      724F6E45 
 8842      78697400 
 8843              	.LASF89:
 8844 0075 70727649 		.ascii	"prvInitialiseNewTask\000"
 8844      6E697469 
 8844      616C6973 
 8844      654E6577 
 8844      5461736B 
 8845              	.LASF187:
 8846 008a 70784869 		.ascii	"pxHigherPriorityTaskWoken\000"
 8846      67686572 
 8846      5072696F 
 8846      72697479 
 8846      5461736B 
 8847              	.LASF49:
 8848 00a4 654E6F41 		.ascii	"eNoAction\000"
 8848      6374696F 
 8848      6E00
 8849              	.LASF203:
 8850 00ae 7578546F 		.ascii	"uxTopReadyPriority\000"
 8850      70526561 
 8850      64795072 
 8850      696F7269 
 8850      747900
 8851              	.LASF0:
 8852 00c1 756E7369 		.ascii	"unsigned int\000"
 8852      676E6564 
 8852      20696E74 
 8852      00
 8853              	.LASF141:
 8854 00ce 70784576 		.ascii	"pxEventList\000"
 8854      656E744C 
 8854      69737400 
 8855              	.LASF204:
 8856 00da 78536368 		.ascii	"xSchedulerRunning\000"
 8856      6564756C 
 8856      65725275 
 8856      6E6E696E 
 8856      6700
 8857              	.LASF38:
 8858 00ec 7078496E 		.ascii	"pxIndex\000"
 8858      64657800 
 8859              	.LASF167:
 8860 00f4 76546173 		.ascii	"vTaskPriorityInherit\000"
 8860      6B507269 
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 245


 8860      6F726974 
 8860      79496E68 
 8860      65726974 
 8861              	.LASF23:
 8862 0109 53746163 		.ascii	"StackType_t\000"
 8862      6B547970 
 8862      655F7400 
 8863              	.LASF55:
 8864 0115 7854494D 		.ascii	"xTIME_OUT\000"
 8864      455F4F55 
 8864      5400
 8865              	.LASF199:
 8866 011f 75784465 		.ascii	"uxDeletedTasksWaitingCleanUp\000"
 8866      6C657465 
 8866      64546173 
 8866      6B735761 
 8866      6974696E 
 8867              	.LASF8:
 8868 013c 5F5F696E 		.ascii	"__int32_t\000"
 8868      7433325F 
 8868      7400
 8869              	.LASF33:
 8870 0146 784C4953 		.ascii	"xLIST_ITEM\000"
 8870      545F4954 
 8870      454D00
 8871              	.LASF192:
 8872 0151 70785265 		.ascii	"pxReadyTasksLists\000"
 8872      61647954 
 8872      61736B73 
 8872      4C697374 
 8872      7300
 8873              	.LASF185:
 8874 0163 75634F72 		.ascii	"ucOriginalNotifyState\000"
 8874      6967696E 
 8874      616C4E6F 
 8874      74696679 
 8874      53746174 
 8875              	.LASF148:
 8876 0179 76546173 		.ascii	"vTaskSetTimeOutState\000"
 8876      6B536574 
 8876      54696D65 
 8876      4F757453 
 8876      74617465 
 8877              	.LASF186:
 8878 018e 78546173 		.ascii	"xTaskGenericNotifyFromISR\000"
 8878      6B47656E 
 8878      65726963 
 8878      4E6F7469 
 8878      66794672 
 8879              	.LASF132:
 8880 01a8 78546173 		.ascii	"xTaskIncrementTick\000"
 8880      6B496E63 
 8880      72656D65 
 8880      6E745469 
 8880      636B00
 8881              	.LASF79:
 8882 01bb 756C4269 		.ascii	"ulBitmap\000"
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 246


 8882      746D6170 
 8882      00
 8883              	.LASF193:
 8884 01c4 7844656C 		.ascii	"xDelayedTaskList1\000"
 8884      61796564 
 8884      5461736B 
 8884      4C697374 
 8884      3100
 8885              	.LASF194:
 8886 01d6 7844656C 		.ascii	"xDelayedTaskList2\000"
 8886      61796564 
 8886      5461736B 
 8886      4C697374 
 8886      3200
 8887              	.LASF56:
 8888 01e8 784F7665 		.ascii	"xOverflowCount\000"
 8888      72666C6F 
 8888      77436F75 
 8888      6E7400
 8889              	.LASF106:
 8890 01f7 65526574 		.ascii	"eReturn\000"
 8890      75726E00 
 8891              	.LASF120:
 8892 01ff 78546173 		.ascii	"xTaskToResume\000"
 8892      6B546F52 
 8892      6573756D 
 8892      6500
 8893              	.LASF109:
 8894 020d 75785265 		.ascii	"uxReturn\000"
 8894      7475726E 
 8894      00
 8895              	.LASF171:
 8896 0216 75785461 		.ascii	"uxTaskGetNumberOfTasks\000"
 8896      736B4765 
 8896      744E756D 
 8896      6265724F 
 8896      66546173 
 8897              	.LASF82:
 8898 022d 70634E61 		.ascii	"pcName\000"
 8898      6D6500
 8899              	.LASF70:
 8900 0234 74736B54 		.ascii	"tskTCB\000"
 8900      434200
 8901              	.LASF122:
 8902 023b 75785361 		.ascii	"uxSavedInterruptStatus\000"
 8902      76656449 
 8902      6E746572 
 8902      72757074 
 8902      53746174 
 8903              	.LASF19:
 8904 0252 75696E74 		.ascii	"uint32_t\000"
 8904      33325F74 
 8904      00
 8905              	.LASF69:
 8906 025b 75634E6F 		.ascii	"ucNotifyState\000"
 8906      74696679 
 8906      53746174 
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 247


 8906      6500
 8907              	.LASF116:
 8908 0269 78596965 		.ascii	"xYieldRequired\000"
 8908      6C645265 
 8908      71756972 
 8908      656400
 8909              	.LASF72:
 8910 0278 756C4F72 		.ascii	"ulOriginalBASEPRI\000"
 8910      6967696E 
 8910      616C4241 
 8910      53455052 
 8910      4900
 8911              	.LASF180:
 8912 028a 78546173 		.ascii	"xTaskGenericNotify\000"
 8912      6B47656E 
 8912      65726963 
 8912      4E6F7469 
 8912      667900
 8913              	.LASF20:
 8914 029d 666C6F61 		.ascii	"float\000"
 8914      7400
 8915              	.LASF145:
 8916 02a3 7078556E 		.ascii	"pxUnblockedTCB\000"
 8916      626C6F63 
 8916      6B656454 
 8916      434200
 8917              	.LASF83:
 8918 02b2 75735374 		.ascii	"usStackDepth\000"
 8918      61636B44 
 8918      65707468 
 8918      00
 8919              	.LASF174:
 8920 02bf 78436C65 		.ascii	"xClearCountOnExit\000"
 8920      6172436F 
 8920      756E744F 
 8920      6E457869 
 8920      7400
 8921              	.LASF52:
 8922 02d1 65536574 		.ascii	"eSetValueWithOverwrite\000"
 8922      56616C75 
 8922      65576974 
 8922      684F7665 
 8922      72777269 
 8923              	.LASF13:
 8924 02e8 6C6F6E67 		.ascii	"long long unsigned int\000"
 8924      206C6F6E 
 8924      6720756E 
 8924      7369676E 
 8924      65642069 
 8925              	.LASF129:
 8926 02ff 78546173 		.ascii	"xTaskGetTickCountFromISR\000"
 8926      6B476574 
 8926      5469636B 
 8926      436F756E 
 8926      7446726F 
 8927              	.LASF111:
 8928 0318 75785361 		.ascii	"uxSavedInterruptState\000"
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 248


 8928      76656449 
 8928      6E746572 
 8928      72757074 
 8928      53746174 
 8929              	.LASF177:
 8930 032e 756C4269 		.ascii	"ulBitsToClearOnEntry\000"
 8930      7473546F 
 8930      436C6561 
 8930      724F6E45 
 8930      6E747279 
 8931              	.LASF197:
 8932 0343 7850656E 		.ascii	"xPendingReadyList\000"
 8932      64696E67 
 8932      52656164 
 8932      794C6973 
 8932      7400
 8933              	.LASF29:
 8934 0355 70785072 		.ascii	"pxPrevious\000"
 8934      6576696F 
 8934      757300
 8935              	.LASF198:
 8936 0360 78546173 		.ascii	"xTasksWaitingTermination\000"
 8936      6B735761 
 8936      6974696E 
 8936      67546572 
 8936      6D696E61 
 8937              	.LASF6:
 8938 0379 5F5F7569 		.ascii	"__uint16_t\000"
 8938      6E743136 
 8938      5F7400
 8939              	.LASF121:
 8940 0384 78546173 		.ascii	"xTaskResumeFromISR\000"
 8940      6B526573 
 8940      756D6546 
 8940      726F6D49 
 8940      535200
 8941              	.LASF152:
 8942 0397 76546173 		.ascii	"vTaskSuspendAll\000"
 8942      6B537573 
 8942      70656E64 
 8942      416C6C00 
 8943              	.LASF162:
 8944 03a7 75785461 		.ascii	"uxTaskGetStackHighWaterMark\000"
 8944      736B4765 
 8944      74537461 
 8944      636B4869 
 8944      67685761 
 8945              	.LASF54:
 8946 03c3 654E6F74 		.ascii	"eNotifyAction\000"
 8946      69667941 
 8946      6374696F 
 8946      6E00
 8947              	.LASF2:
 8948 03d1 73697A65 		.ascii	"size_t\000"
 8948      5F7400
 8949              	.LASF51:
 8950 03d8 65496E63 		.ascii	"eIncrement\000"
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 249


 8950      72656D65 
 8950      6E7400
 8951              	.LASF34:
 8952 03e3 784D494E 		.ascii	"xMINI_LIST_ITEM\000"
 8952      495F4C49 
 8952      53545F49 
 8952      54454D00 
 8953              	.LASF160:
 8954 03f3 70756353 		.ascii	"pucStackByte\000"
 8954      7461636B 
 8954      42797465 
 8954      00
 8955              	.LASF36:
 8956 0400 784C4953 		.ascii	"xLIST\000"
 8956      5400
 8957              	.LASF124:
 8958 0406 76546173 		.ascii	"vTaskEndScheduler\000"
 8958      6B456E64 
 8958      53636865 
 8958      64756C65 
 8958      7200
 8959              	.LASF108:
 8960 0418 75785461 		.ascii	"uxTaskPriorityGet\000"
 8960      736B5072 
 8960      696F7269 
 8960      74794765 
 8960      7400
 8961              	.LASF100:
 8962 042a 78436F6E 		.ascii	"xConstTickCount\000"
 8962      73745469 
 8962      636B436F 
 8962      756E7400 
 8963              	.LASF200:
 8964 043a 78537573 		.ascii	"xSuspendedTaskList\000"
 8964      70656E64 
 8964      65645461 
 8964      736B4C69 
 8964      737400
 8965              	.LASF74:
 8966 044d 76506F72 		.ascii	"vPortSetBASEPRI\000"
 8966      74536574 
 8966      42415345 
 8966      50524900 
 8967              	.LASF59:
 8968 045d 74736B54 		.ascii	"tskTaskControlBlock\000"
 8968      61736B43 
 8968      6F6E7472 
 8968      6F6C426C 
 8968      6F636B00 
 8969              	.LASF196:
 8970 0471 70784F76 		.ascii	"pxOverflowDelayedTaskList\000"
 8970      6572666C 
 8970      6F774465 
 8970      6C617965 
 8970      64546173 
 8971              	.LASF134:
 8972 048b 70785465 		.ascii	"pxTemp\000"
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 250


 8972      6D7000
 8973              	.LASF140:
 8974 0492 76546173 		.ascii	"vTaskPlaceOnEventList\000"
 8974      6B506C61 
 8974      63654F6E 
 8974      4576656E 
 8974      744C6973 
 8975              	.LASF101:
 8976 04a8 76546173 		.ascii	"vTaskDelay\000"
 8976      6B44656C 
 8976      617900
 8977              	.LASF172:
 8978 04b3 70765461 		.ascii	"pvTaskIncrementMutexHeldCount\000"
 8978      736B496E 
 8978      6372656D 
 8978      656E744D 
 8978      75746578 
 8979              	.LASF68:
 8980 04d1 756C4E6F 		.ascii	"ulNotifiedValue\000"
 8980      74696669 
 8980      65645661 
 8980      6C756500 
 8981              	.LASF67:
 8982 04e1 75784D75 		.ascii	"uxMutexesHeld\000"
 8982      74657865 
 8982      7348656C 
 8982      6400
 8983              	.LASF169:
 8984 04ef 78546173 		.ascii	"xTaskPriorityDisinherit\000"
 8984      6B507269 
 8984      6F726974 
 8984      79446973 
 8984      696E6865 
 8985              	.LASF144:
 8986 0507 78546173 		.ascii	"xTaskRemoveFromEventList\000"
 8986      6B52656D 
 8986      6F766546 
 8986      726F6D45 
 8986      76656E74 
 8987              	.LASF15:
 8988 0520 63686172 		.ascii	"char\000"
 8988      00
 8989              	.LASF32:
 8990 0525 4C697374 		.ascii	"ListItem_t\000"
 8990      4974656D 
 8990      5F7400
 8991              	.LASF53:
 8992 0530 65536574 		.ascii	"eSetValueWithoutOverwrite\000"
 8992      56616C75 
 8992      65576974 
 8992      686F7574 
 8992      4F766572 
 8993              	.LASF73:
 8994 054a 756C4E65 		.ascii	"ulNewBASEPRI\000"
 8994      77424153 
 8994      45505249 
 8994      00
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 251


 8995              	.LASF25:
 8996 0557 55426173 		.ascii	"UBaseType_t\000"
 8996      65547970 
 8996      655F7400 
 8997              	.LASF88:
 8998 0563 756C5374 		.ascii	"ulStackDepth\000"
 8998      61636B44 
 8998      65707468 
 8998      00
 8999              	.LASF99:
 9000 0570 7853686F 		.ascii	"xShouldDelay\000"
 9000      756C6444 
 9000      656C6179 
 9000      00
 9001              	.LASF154:
 9002 057d 70727649 		.ascii	"prvIdleTask\000"
 9002      646C6554 
 9002      61736B00 
 9003              	.LASF39:
 9004 0589 784C6973 		.ascii	"xListEnd\000"
 9004      74456E64 
 9004      00
 9005              	.LASF157:
 9006 0592 784C6973 		.ascii	"xListIsEmpty\000"
 9006      74497345 
 9006      6D707479 
 9006      00
 9007              	.LASF173:
 9008 059f 756C5461 		.ascii	"ulTaskNotifyTake\000"
 9008      736B4E6F 
 9008      74696679 
 9008      54616B65 
 9008      00
 9009              	.LASF35:
 9010 05b0 4D696E69 		.ascii	"MiniListItem_t\000"
 9010      4C697374 
 9010      4974656D 
 9010      5F7400
 9011              	.LASF176:
 9012 05bf 78546173 		.ascii	"xTaskNotifyWait\000"
 9012      6B4E6F74 
 9012      69667957 
 9012      61697400 
 9013              	.LASF103:
 9014 05cf 78546173 		.ascii	"xTaskCreate\000"
 9014      6B437265 
 9014      61746500 
 9015              	.LASF90:
 9016 05db 70727641 		.ascii	"prvAddNewTaskToReadyList\000"
 9016      64644E65 
 9016      77546173 
 9016      6B546F52 
 9016      65616479 
 9017              	.LASF16:
 9018 05f4 75696E74 		.ascii	"uint8_t\000"
 9018      385F7400 
 9019              	.LASF43:
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 252


 9020 05fc 65526561 		.ascii	"eReady\000"
 9020      647900
 9021              	.LASF104:
 9022 0603 65546173 		.ascii	"eTaskGetState\000"
 9022      6B476574 
 9022      53746174 
 9022      6500
 9023              	.LASF86:
 9024 0611 70784E65 		.ascii	"pxNewTCB\000"
 9024      77544342 
 9024      00
 9025              	.LASF216:
 9026 061a 433A5C55 		.ascii	"C:\\Users\\NGGMLGM\\Documents\\UWE\\GDIP\\GDIP\\Fre"
 9026      73657273 
 9026      5C4E4747 
 9026      4D4C474D 
 9026      5C446F63 
 9027 0646 6552544F 		.ascii	"eRTOS\\Demo\\CORTEX_CY8C5588_PSoC_Creator_GCC\\Free"
 9027      535C4465 
 9027      6D6F5C43 
 9027      4F525445 
 9027      585F4359 
 9028 0676 52544F53 		.ascii	"RTOS_Demo.cydsn\000"
 9028      5F44656D 
 9028      6F2E6379 
 9028      64736E00 
 9029              	.LASF81:
 9030 0686 70785461 		.ascii	"pxTaskCode\000"
 9030      736B436F 
 9030      646500
 9031              	.LASF127:
 9032 0691 78546173 		.ascii	"xTaskGetTickCount\000"
 9032      6B476574 
 9032      5469636B 
 9032      436F756E 
 9032      7400
 9033              	.LASF209:
 9034 06a3 784E6578 		.ascii	"xNextTaskUnblockTime\000"
 9034      74546173 
 9034      6B556E62 
 9034      6C6F636B 
 9034      54696D65 
 9035              	.LASF76:
 9036 06b8 756C506F 		.ascii	"ulPortRaiseBASEPRI\000"
 9036      72745261 
 9036      69736542 
 9036      41534550 
 9036      524900
 9037              	.LASF202:
 9038 06cb 78546963 		.ascii	"xTickCount\000"
 9038      6B436F75 
 9038      6E7400
 9039              	.LASF12:
 9040 06d6 6C6F6E67 		.ascii	"long long int\000"
 9040      206C6F6E 
 9040      6720696E 
 9040      7400
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 253


 9041              	.LASF46:
 9042 06e4 6544656C 		.ascii	"eDeleted\000"
 9042      65746564 
 9042      00
 9043              	.LASF77:
 9044 06ed 7563506F 		.ascii	"ucPortCountLeadingZeros\000"
 9044      7274436F 
 9044      756E744C 
 9044      65616469 
 9044      6E675A65 
 9045              	.LASF133:
 9046 0705 78537769 		.ascii	"xSwitchRequired\000"
 9046      74636852 
 9046      65717569 
 9046      72656400 
 9047              	.LASF24:
 9048 0715 42617365 		.ascii	"BaseType_t\000"
 9048      54797065 
 9048      5F7400
 9049              	.LASF137:
 9050 0720 756C4368 		.ascii	"ulCheckValue\000"
 9050      65636B56 
 9050      616C7565 
 9050      00
 9051              	.LASF165:
 9052 072d 70727652 		.ascii	"prvResetNextTaskUnblockTime\000"
 9052      65736574 
 9052      4E657874 
 9052      5461736B 
 9052      556E626C 
 9053              	.LASF57:
 9054 0749 7854696D 		.ascii	"xTimeOnEntering\000"
 9054      654F6E45 
 9054      6E746572 
 9054      696E6700 
 9055              	.LASF113:
 9056 0759 75784E65 		.ascii	"uxNewPriority\000"
 9056      77507269 
 9056      6F726974 
 9056      7900
 9057              	.LASF22:
 9058 0767 5461736B 		.ascii	"TaskFunction_t\000"
 9058      46756E63 
 9058      74696F6E 
 9058      5F7400
 9059              	.LASF28:
 9060 0776 70784E65 		.ascii	"pxNext\000"
 9060      787400
 9061              	.LASF214:
 9062 077d 474E5520 		.ascii	"GNU C 4.9.3 20150303 (release) [ARM/embedded-4_9-br"
 9062      4320342E 
 9062      392E3320 
 9062      32303135 
 9062      30333033 
 9063 07b0 616E6368 		.ascii	"anch revision 221220] -mcpu=cortex-m3 -mthumb -g -O"
 9063      20726576 
 9063      6973696F 
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 254


 9063      6E203232 
 9063      31323230 
 9064 07e3 30202D66 		.ascii	"0 -ffunction-sections -ffat-lto-objects\000"
 9064      66756E63 
 9064      74696F6E 
 9064      2D736563 
 9064      74696F6E 
 9065              	.LASF149:
 9066 080b 70785469 		.ascii	"pxTimeOut\000"
 9066      6D654F75 
 9066      7400
 9067              	.LASF110:
 9068 0815 75785461 		.ascii	"uxTaskPriorityGetFromISR\000"
 9068      736B5072 
 9068      696F7269 
 9068      74794765 
 9068      7446726F 
 9069              	.LASF161:
 9070 082e 756C436F 		.ascii	"ulCount\000"
 9070      756E7400 
 9071              	.LASF58:
 9072 0836 54696D65 		.ascii	"TimeOut_t\000"
 9072      4F75745F 
 9072      7400
 9073              	.LASF208:
 9074 0840 75785461 		.ascii	"uxTaskNumber\000"
 9074      736B4E75 
 9074      6D626572 
 9074      00
 9075              	.LASF41:
 9076 084d 5461736B 		.ascii	"TaskHandle_t\000"
 9076      48616E64 
 9076      6C655F74 
 9076      00
 9077              	.LASF183:
 9078 085a 65416374 		.ascii	"eAction\000"
 9078      696F6E00 
 9079              	.LASF78:
 9080 0862 756C4E65 		.ascii	"ulNewMaskValue\000"
 9080      774D6173 
 9080      6B56616C 
 9080      756500
 9081              	.LASF170:
 9082 0871 75785461 		.ascii	"uxTaskResetEventItemValue\000"
 9082      736B5265 
 9082      73657445 
 9082      76656E74 
 9082      4974656D 
 9083              	.LASF112:
 9084 088b 76546173 		.ascii	"vTaskPrioritySet\000"
 9084      6B507269 
 9084      6F726974 
 9084      79536574 
 9084      00
 9085              	.LASF48:
 9086 089c 65546173 		.ascii	"eTaskState\000"
 9086      6B537461 
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 255


 9086      746500
 9087              	.LASF40:
 9088 08a7 4C697374 		.ascii	"List_t\000"
 9088      5F7400
 9089              	.LASF131:
 9090 08ae 78546173 		.ascii	"xTaskToQuery\000"
 9090      6B546F51 
 9090      75657279 
 9090      00
 9091              	.LASF26:
 9092 08bb 5469636B 		.ascii	"TickType_t\000"
 9092      54797065 
 9092      5F7400
 9093              	.LASF181:
 9094 08c6 78546173 		.ascii	"xTaskToNotify\000"
 9094      6B546F4E 
 9094      6F746966 
 9094      7900
 9095              	.LASF105:
 9096 08d4 78546173 		.ascii	"xTask\000"
 9096      6B00
 9097              	.LASF50:
 9098 08da 65536574 		.ascii	"eSetBits\000"
 9098      42697473 
 9098      00
 9099              	.LASF17:
 9100 08e3 75696E74 		.ascii	"uint16_t\000"
 9100      31365F74 
 9100      00
 9101              	.LASF93:
 9102 08ec 76546173 		.ascii	"vTaskDelete\000"
 9102      6B44656C 
 9102      65746500 
 9103              	.LASF135:
 9104 08f8 76546173 		.ascii	"vTaskSwitchContext\000"
 9104      6B537769 
 9104      74636843 
 9104      6F6E7465 
 9104      787400
 9105              	.LASF207:
 9106 090b 784E756D 		.ascii	"xNumOfOverflows\000"
 9106      4F664F76 
 9106      6572666C 
 9106      6F777300 
 9107              	.LASF31:
 9108 091b 7076436F 		.ascii	"pvContainer\000"
 9108      6E746169 
 9108      6E657200 
 9109              	.LASF210:
 9110 0927 7849646C 		.ascii	"xIdleTaskHandle\000"
 9110      65546173 
 9110      6B48616E 
 9110      646C6500 
 9111              	.LASF5:
 9112 0937 73686F72 		.ascii	"short int\000"
 9112      7420696E 
 9112      7400
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 256


 9113              	.LASF84:
 9114 0941 70765061 		.ascii	"pvParameters\000"
 9114      72616D65 
 9114      74657273 
 9114      00
 9115              	.LASF27:
 9116 094e 78497465 		.ascii	"xItemValue\000"
 9116      6D56616C 
 9116      756500
 9117              	.LASF9:
 9118 0959 6C6F6E67 		.ascii	"long int\000"
 9118      20696E74 
 9118      00
 9119              	.LASF212:
 9120 0962 49544D5F 		.ascii	"ITM_RxBuffer\000"
 9120      52784275 
 9120      66666572 
 9120      00
 9121              	.LASF125:
 9122 096f 78546173 		.ascii	"xTaskResumeAll\000"
 9122      6B526573 
 9122      756D6541 
 9122      6C6C00
 9123              	.LASF188:
 9124 097e 76546173 		.ascii	"vTaskNotifyGiveFromISR\000"
 9124      6B4E6F74 
 9124      69667947 
 9124      69766546 
 9124      726F6D49 
 9125              	.LASF195:
 9126 0995 70784465 		.ascii	"pxDelayedTaskList\000"
 9126      6C617965 
 9126      64546173 
 9126      6B4C6973 
 9126      7400
 9127              	.LASF158:
 9128 09a7 70727654 		.ascii	"prvTaskIsTaskSuspended\000"
 9128      61736B49 
 9128      73546173 
 9128      6B537573 
 9128      70656E64 
 9129              	.LASF168:
 9130 09be 70784D75 		.ascii	"pxMutexHolder\000"
 9130      74657848 
 9130      6F6C6465 
 9130      7200
 9131              	.LASF64:
 9132 09cc 70785374 		.ascii	"pxStack\000"
 9132      61636B00 
 9133              	.LASF91:
 9134 09d4 78546173 		.ascii	"xTaskToDelete\000"
 9134      6B546F44 
 9134      656C6574 
 9134      6500
 9135              	.LASF182:
 9136 09e2 756C5661 		.ascii	"ulValue\000"
 9136      6C756500 
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 257


 9137              	.LASF118:
 9138 09ea 78546173 		.ascii	"xTaskToSuspend\000"
 9138      6B546F53 
 9138      75737065 
 9138      6E6400
 9139              	.LASF150:
 9140 09f9 78546173 		.ascii	"xTaskCheckForTimeOut\000"
 9140      6B436865 
 9140      636B466F 
 9140      7254696D 
 9140      654F7574 
 9141              	.LASF95:
 9142 0a0e 70785072 		.ascii	"pxPreviousWakeTime\000"
 9142      6576696F 
 9142      75735761 
 9142      6B655469 
 9142      6D6500
 9143              	.LASF3:
 9144 0a21 5F5F7569 		.ascii	"__uint8_t\000"
 9144      6E74385F 
 9144      7400
 9145              	.LASF80:
 9146 0a2b 75635265 		.ascii	"ucReturn\000"
 9146      7475726E 
 9146      00
 9147              	.LASF184:
 9148 0a34 70756C50 		.ascii	"pulPreviousNotificationValue\000"
 9148      72657669 
 9148      6F75734E 
 9148      6F746966 
 9148      69636174 
 9149              	.LASF179:
 9150 0a51 70756C4E 		.ascii	"pulNotificationValue\000"
 9150      6F746966 
 9150      69636174 
 9150      696F6E56 
 9150      616C7565 
 9151              	.LASF87:
 9152 0a66 78526574 		.ascii	"xReturn\000"
 9152      75726E00 
 9153              	.LASF14:
 9154 0a6e 73697A65 		.ascii	"sizetype\000"
 9154      74797065 
 9154      00
 9155              	.LASF153:
 9156 0a77 76546173 		.ascii	"vTaskMissedYield\000"
 9156      6B4D6973 
 9156      73656459 
 9156      69656C64 
 9156      00
 9157              	.LASF205:
 9158 0a88 75785065 		.ascii	"uxPendedTicks\000"
 9158      6E646564 
 9158      5469636B 
 9158      7300
 9159              	.LASF11:
 9160 0a96 6C6F6E67 		.ascii	"long unsigned int\000"
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 258


 9160      20756E73 
 9160      69676E65 
 9160      6420696E 
 9160      7400
 9161              	.LASF75:
 9162 0aa8 76506F72 		.ascii	"vPortRaiseBASEPRI\000"
 9162      74526169 
 9162      73654241 
 9162      53455052 
 9162      4900
 9163              	.LASF163:
 9164 0aba 70756345 		.ascii	"pucEndOfStack\000"
 9164      6E644F66 
 9164      53746163 
 9164      6B00
 9165              	.LASF130:
 9166 0ac8 70635461 		.ascii	"pcTaskGetName\000"
 9166      736B4765 
 9166      744E616D 
 9166      6500
 9167              	.LASF18:
 9168 0ad6 696E7433 		.ascii	"int32_t\000"
 9168      325F7400 
 9169              	.LASF128:
 9170 0ade 78546963 		.ascii	"xTicks\000"
 9170      6B7300
 9171              	.LASF123:
 9172 0ae5 76546173 		.ascii	"vTaskStartScheduler\000"
 9172      6B537461 
 9172      72745363 
 9172      68656475 
 9172      6C657200 
 9173              	.LASF191:
 9174 0af9 7843616E 		.ascii	"xCanBlockIndefinitely\000"
 9174      426C6F63 
 9174      6B496E64 
 9174      6566696E 
 9174      6974656C 
 9175              	.LASF42:
 9176 0b0f 6552756E 		.ascii	"eRunning\000"
 9176      6E696E67 
 9176      00
 9177              	.LASF136:
 9178 0b18 70756C53 		.ascii	"pulStack\000"
 9178      7461636B 
 9178      00
 9179              	.LASF102:
 9180 0b21 78546963 		.ascii	"xTicksToDelay\000"
 9180      6B73546F 
 9180      44656C61 
 9180      7900
 9181              	.LASF4:
 9182 0b2f 756E7369 		.ascii	"unsigned char\000"
 9182      676E6564 
 9182      20636861 
 9182      7200
 9183              	.LASF143:
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 259


 9184 0b3d 76546173 		.ascii	"vTaskPlaceOnUnorderedEventList\000"
 9184      6B506C61 
 9184      63654F6E 
 9184      556E6F72 
 9184      64657265 
 9185              	.LASF146:
 9186 0b5c 78546173 		.ascii	"xTaskRemoveFromUnorderedEventList\000"
 9186      6B52656D 
 9186      6F766546 
 9186      726F6D55 
 9186      6E6F7264 
 9187              	.LASF10:
 9188 0b7e 5F5F7569 		.ascii	"__uint32_t\000"
 9188      6E743332 
 9188      5F7400
 9189              	.LASF189:
 9190 0b89 78546173 		.ascii	"xTaskNotifyStateClear\000"
 9190      6B4E6F74 
 9190      69667953 
 9190      74617465 
 9190      436C6561 
 9191              	.LASF151:
 9192 0b9f 70785469 		.ascii	"pxTicksToWait\000"
 9192      636B7354 
 9192      6F576169 
 9192      7400
 9193              	.LASF138:
 9194 0bad 7578546F 		.ascii	"uxTopPriority\000"
 9194      70507269 
 9194      6F726974 
 9194      7900
 9195              	.LASF66:
 9196 0bbb 75784261 		.ascii	"uxBasePriority\000"
 9196      73655072 
 9196      696F7269 
 9196      747900
 9197              	.LASF94:
 9198 0bca 76546173 		.ascii	"vTaskDelayUntil\000"
 9198      6B44656C 
 9198      6179556E 
 9198      74696C00 
 9199              	.LASF62:
 9200 0bda 78457665 		.ascii	"xEventListItem\000"
 9200      6E744C69 
 9200      73744974 
 9200      656D00
 9201              	.LASF115:
 9202 0be9 75785072 		.ascii	"uxPriorityUsedOnEntry\000"
 9202      696F7269 
 9202      74795573 
 9202      65644F6E 
 9202      456E7472 
 9203              	.LASF71:
 9204 0bff 5443425F 		.ascii	"TCB_t\000"
 9204      7400
 9205              	.LASF142:
 9206 0c05 78546963 		.ascii	"xTicksToWait\000"
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 260


 9206      6B73546F 
 9206      57616974 
 9206      00
 9207              	.LASF30:
 9208 0c12 70764F77 		.ascii	"pvOwner\000"
 9208      6E657200 
 9209              	.LASF164:
 9210 0c1a 70727644 		.ascii	"prvDeleteTCB\000"
 9210      656C6574 
 9210      65544342 
 9210      00
 9211              	.LASF44:
 9212 0c27 65426C6F 		.ascii	"eBlocked\000"
 9212      636B6564 
 9212      00
 9213              	.LASF117:
 9214 0c30 76546173 		.ascii	"vTaskSuspend\000"
 9214      6B537573 
 9214      70656E64 
 9214      00
 9215              	.LASF98:
 9216 0c3d 78416C72 		.ascii	"xAlreadyYielded\000"
 9216      65616479 
 9216      5969656C 
 9216      64656400 
 9217              	.LASF166:
 9218 0c4d 78546173 		.ascii	"xTaskGetCurrentTaskHandle\000"
 9218      6B476574 
 9218      43757272 
 9218      656E7454 
 9218      61736B48 
 9219              	.LASF159:
 9220 0c67 70727654 		.ascii	"prvTaskCheckFreeStackSpace\000"
 9220      61736B43 
 9220      6865636B 
 9220      46726565 
 9220      53746163 
 9221              	.LASF190:
 9222 0c82 70727641 		.ascii	"prvAddCurrentTaskToDelayedList\000"
 9222      64644375 
 9222      7272656E 
 9222      74546173 
 9222      6B546F44 
 9223              	.LASF213:
 9224 0ca1 70784375 		.ascii	"pxCurrentTCB\000"
 9224      7272656E 
 9224      74544342 
 9224      00
 9225              	.LASF201:
 9226 0cae 75784375 		.ascii	"uxCurrentNumberOfTasks\000"
 9226      7272656E 
 9226      744E756D 
 9226      6265724F 
 9226      66546173 
 9227              	.LASF96:
 9228 0cc5 7854696D 		.ascii	"xTimeIncrement\000"
 9228      65496E63 
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 261


 9228      72656D65 
 9228      6E7400
 9229              	.LASF1:
 9230 0cd4 7369676E 		.ascii	"signed char\000"
 9230      65642063 
 9230      68617200 
 9231              	.LASF7:
 9232 0ce0 73686F72 		.ascii	"short unsigned int\000"
 9232      7420756E 
 9232      7369676E 
 9232      65642069 
 9232      6E7400
 9233              	.LASF97:
 9234 0cf3 7854696D 		.ascii	"xTimeToWake\000"
 9234      65546F57 
 9234      616B6500 
 9235              	.LASF61:
 9236 0cff 78537461 		.ascii	"xStateListItem\000"
 9236      74654C69 
 9236      73744974 
 9236      656D00
 9237              	.LASF92:
 9238 0d0e 70785443 		.ascii	"pxTCB\000"
 9238      4200
 9239              	.LASF215:
 9240 0d14 2E2E5C2E 		.ascii	"..\\..\\..\\Source\\tasks.c\000"
 9240      2E5C2E2E 
 9240      5C536F75 
 9240      7263655C 
 9240      7461736B 
 9241              	.LASF21:
 9242 0d2c 646F7562 		.ascii	"double\000"
 9242      6C6500
 9243              	.LASF211:
 9244 0d33 75785363 		.ascii	"uxSchedulerSuspended\000"
 9244      68656475 
 9244      6C657253 
 9244      75737065 
 9244      6E646564 
 9245              	.LASF60:
 9246 0d48 7078546F 		.ascii	"pxTopOfStack\000"
 9246      704F6653 
 9246      7461636B 
 9246      00
 9247              	.LASF119:
 9248 0d55 76546173 		.ascii	"vTaskResume\000"
 9248      6B526573 
 9248      756D6500 
 9249              	.LASF155:
 9250 0d61 70727649 		.ascii	"prvInitialiseTaskLists\000"
 9250      6E697469 
 9250      616C6973 
 9250      65546173 
 9250      6B4C6973 
 9251              	.LASF147:
 9252 0d78 70784576 		.ascii	"pxEventListItem\000"
 9252      656E744C 
ARM GAS  C:\Users\NGGMLGM\AppData\Local\Temp\ccOZBRcb.s 			page 262


 9252      69737449 
 9252      74656D00 
 9253              	.LASF85:
 9254 0d88 70784372 		.ascii	"pxCreatedTask\000"
 9254      65617465 
 9254      64546173 
 9254      6B00
 9255              	.LASF156:
 9256 0d96 70727643 		.ascii	"prvCheckTasksWaitingTermination\000"
 9256      6865636B 
 9256      5461736B 
 9256      73576169 
 9256      74696E67 
 9257              	.LASF175:
 9258 0db6 756C5265 		.ascii	"ulReturn\000"
 9258      7475726E 
 9258      00
 9259              	.LASF114:
 9260 0dbf 75784375 		.ascii	"uxCurrentBasePriority\000"
 9260      7272656E 
 9260      74426173 
 9260      65507269 
 9260      6F726974 
 9261              	.LASF206:
 9262 0dd5 78596965 		.ascii	"xYieldPending\000"
 9262      6C645065 
 9262      6E64696E 
 9262      6700
 9263              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 4.9.3 20150303 (release) [ARM/embedded-4_9-br
